
pdm_4ch.elf:     file format elf32-littlenios2
pdm_4ch.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00800250

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x00800020 paddr 0x00800020 align 2**12
         filesz 0x0001b540 memsz 0x0002b838 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000230  00800020  00800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000120a8  00800250  00800250  00001250  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00007a04  008122f8  008122f8  000132f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001864  00819cfc  00819cfc  0001acfc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000102f8  0081b560  0081b560  0001c560  2**2
                  ALLOC, SMALL_DATA
  6 .serialflash  00000000  00002020  00002020  0001c560  2**0
                  CONTENTS
  7 .onchip_flash 00000000  00080000  00080000  0001c560  2**0
                  CONTENTS
  8 .sdram        00000000  0082b858  0082b858  0001c560  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0001c560  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000c70  00000000  00000000  0001c588  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   000145d6  00000000  00000000  0001d1f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006b62  00000000  00000000  000317ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000091b8  00000000  00000000  00038330  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002d0c  00000000  00000000  000414e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000047f3  00000000  00000000  000441f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000bd92  00000000  00000000  000489e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000010  00000000  00000000  0005477c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001270  00000000  00000000  00054790  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  00059e71  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000a  00000000  00000000  00059e74  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00059e7e  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00059e7f  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  00059e80  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00059e84  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  00059e88  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000009  00000000  00000000  00059e8c  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000009  00000000  00000000  00059e95  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000009  00000000  00000000  00059e9e  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000004  00000000  00000000  00059ea7  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000014  00000000  00000000  00059eab  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000970f9  00000000  00000000  00059ebf  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00800020 l    d  .exceptions	00000000 .exceptions
00800250 l    d  .text	00000000 .text
008122f8 l    d  .rodata	00000000 .rodata
00819cfc l    d  .rwdata	00000000 .rwdata
0081b560 l    d  .bss	00000000 .bss
00002020 l    d  .serialflash	00000000 .serialflash
00080000 l    d  .onchip_flash	00000000 .onchip_flash
0082b858 l    d  .sdram	00000000 .sdram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../pdm_4ch_bsp//obj/HAL/src/crt0.o
00800284 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/Source/portable/GCC/NiosII/port_asm.o
00800020 l       .exceptions	00000000 save_context
0080009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
008000ac l       .exceptions	00000000 hw_irq_test
00800150 l       .exceptions	00000000 soft_exceptions
008000c0 l       .exceptions	00000000 hw_irq_handler
008000d4 l       .exceptions	00000000 restore_context
0080016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
00800678 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_2.c
0081b5f0 l     O .bss	00010000 ucHeap
0081b4e0 l     O .rwdata	00000002 heapSTRUCT_SIZE
0081b560 l     O .bss	00000008 xStart
0081b568 l     O .bss	00000008 xEnd
0081b4e4 l     O .rwdata	00000004 xFreeBytesRemaining
0081b570 l     O .bss	00000004 xHeapHasBeenInitialised.2579
00800c74 l     F .text	0000006c prvHeapInit
00000000 l    df *ABS*	00000000 queue.c
00800eac l     F .text	00000084 prvInitialiseNewQueue
00800f30 l     F .text	00000060 prvInitialiseMutex
00801984 l     F .text	0000018c prvCopyDataToQueue
00801d30 l     F .text	00000058 prvIsQueueFull
00801bac l     F .text	000000f4 prvUnlockQueue
00801b10 l     F .text	0000009c prvCopyDataFromQueue
00801ca0 l     F .text	00000050 prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
0082b5f0 l     O .bss	00000064 pxReadyTasksLists
0082b654 l     O .bss	00000014 xDelayedTaskList1
0082b668 l     O .bss	00000014 xDelayedTaskList2
0081b578 l     O .bss	00000004 pxDelayedTaskList
0081b57c l     O .bss	00000004 pxOverflowDelayedTaskList
0082b67c l     O .bss	00000014 xPendingReadyList
0082b690 l     O .bss	00000014 xTasksWaitingTermination
0081b580 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0082b6a4 l     O .bss	00000014 xSuspendedTaskList
0081b584 l     O .bss	00000004 uxCurrentNumberOfTasks
0081b588 l     O .bss	00000004 xTickCount
0081b58c l     O .bss	00000004 uxTopReadyPriority
0081b590 l     O .bss	00000004 xSchedulerRunning
0081b594 l     O .bss	00000004 uxPendedTicks
0081b598 l     O .bss	00000004 xYieldPending
0081b59c l     O .bss	00000004 xNumOfOverflows
0081b5a0 l     O .bss	00000004 uxTaskNumber
0081b5a4 l     O .bss	00000004 xNextTaskUnblockTime
0081b5a8 l     O .bss	00000004 xIdleTaskHandle
0081b5ac l     O .bss	00000004 uxSchedulerSuspended
00801eb8 l     F .text	000001d0 prvInitialiseNewTask
00802088 l     F .text	00000108 prvAddNewTaskToReadyList
0080335c l     F .text	000000c0 prvInitialiseTaskLists
00803588 l     F .text	00000044 prvDeleteTCB
008035cc l     F .text	00000068 prvResetNextTaskUnblockTime
008040c4 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
0080271c l     F .text	00000094 prvTaskIsTaskSuspended
00803340 l     F .text	0000001c prvIdleTask
0080341c l     F .text	000000a8 prvCheckTasksWaitingTermination
008034c4 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 adafruitFont.c
00000000 l    df *ABS*	00000000 font12.c
00000000 l    df *ABS*	00000000 font16.c
00000000 l    df *ABS*	00000000 font20.c
00000000 l    df *ABS*	00000000 font24.c
00000000 l    df *ABS*	00000000 ILI9341_nios.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 ft245_fifo.c
008059a8 l     F .text	00000058 FT245_IRQ_SERVICE
00000000 l    df *ABS*	00000000 grp_lcd.c
00000000 l    df *ABS*	00000000 pdm_main.c
00000000 l    df *ABS*	00000000 pdm_sub.c
00000000 l    df *ABS*	00000000 pdmmic.c
0081b5c0 l     O .bss	00000004 CoeffOfstCncl
00000000 l    df *ABS*	00000000 task_button.c
00000000 l    df *ABS*	00000000 task_com.c
00000000 l    df *ABS*	00000000 task_disp.c
00000000 l    df *ABS*	00000000 task_main.c
00000000 l    df *ABS*	00000000 task_sns.c
00000000 l    df *ABS*	00000000 wave_img.c
00000000 l    df *ABS*	00000000 w_pow.c
00000000 l    df *ABS*	00000000 e_pow.c
00000000 l    df *ABS*	00000000 e_sqrt.c
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_finite.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 s_nan.c
00000000 l    df *ABS*	00000000 s_rint.c
00819ba0 l     O .rodata	00000010 TWO52
00000000 l    df *ABS*	00000000 s_scalbn.c
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 addsf3.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 subsf3.c
00000000 l    df *ABS*	00000000 fixsfsi.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 impure.c
00819cfc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0080f8e0 l     F .text	00000034 alt_dev_reg
0081a120 l     O .rwdata	000000a4 dma_priv
0081a1c4 l     O .rwdata	0000001c dma_tx
0081a1e0 l     O .rwdata	0000001c dma_rx
0081a1fc l     O .rwdata	000000a4 dma_LCD_priv
0081a2a0 l     O .rwdata	0000001c dma_LCD_tx
0081a2bc l     O .rwdata	0000001c dma_LCD_rx
0081a2d8 l     O .rwdata	00001060 jtag_uart
00000000 l    df *ABS*	00000000 altera_avalon_dma.c
0080f9f4 l     F .text	00000034 alt_dma_txchan_reg
0080fa28 l     F .text	00000034 alt_dma_rxchan_reg
0080fb54 l     F .text	0000009c alt_avalon_dma_launch_txonly
0080fbf0 l     F .text	0000009c alt_avalon_dma_launch_rxonly
0080fc8c l     F .text	00000344 alt_avalon_dma_ioctl
00810344 l     F .text	000001c0 alt_avalon_dma_irq
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
008107dc l     F .text	0000020c altera_avalon_jtag_uart_irq
008109e8 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00811020 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
00811240 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00811354 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00811380 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dma_rxchan_open.c
00811460 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dma_txchan_open.c
008114f0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
008116d0 l     F .text	000000e4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00811830 l     F .text	0000003c alt_get_errno
0081186c l     F .text	000000ec alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00807f1c g     F .text	00000034 disable_PDM
00806948 g     F .text	0000012c glcd_put_string_Adafruit
00805e44 g     F .text	00000078 glcd_drawLine
0080f864 g     F .text	0000007c alt_main
008073b0 g     F .text	000000bc HostStsChk
0082b758 g     O .bss	00000100 alt_irq
0080adec g     F .text	00000014 fabs
008000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
00802fb8 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
00800c34 g     F .text	00000020 xPortGetFreeHeapSize
0080da48 g     F .text	00000088 .hidden __eqdf2
00805ebc g     F .text	0000006c glcd_drawHline
008023c4 g     F .text	00000058 uxTaskPriorityGet
008042e4 g     F .text	00000028 get_LCD_DMA_sts
00805dec g     F .text	00000058 glcd_PointSet
00810504 g     F .text	000000b4 alt_avalon_dma_init
0080b738 g     F .text	00000440 .hidden __divsf3
008038ac g     F .text	00000054 vTaskEnterCritical
0080132c g     F .text	000000e8 xQueueGenericSendFromISR
00802c50 g     F .text	00000040 pcTaskGetName
00809204 g     F .text	00000088 plotPoint
0080c548 g     F .text	00000070 .hidden __fixsfsi
00805934 g     F .text	0000002c getDMAsts
0082b6b8 g     O .bss	00000050 FntList
00806130 g     F .text	00000288 put_charPattern
0080dad0 g     F .text	000000dc .hidden __gtdf2
00811cdc g     F .text	00000024 altera_nios2_gen2_irq_init
0080f434 g     F .text	00000010 __errno
00805960 g     F .text	00000048 initFT245mod
00002000 g     F .entry	00000000 __reset
00800fec g     F .text	00000090 xQueueGiveMutexRecursive
0081b574 g     O .bss	00000004 pxCurrentTCB
0081b5ec g     O .bss	00000004 errno
00808698 g     F .text	00000194 task_button
0080430c g     F .text	00000040 init_LCD_DMA
0080928c g     F .text	00000370 DispWaveImg
0081b5dc g     O .bss	00000004 alt_argv
008234e0 g       *ABS*	00000000 _gp
0081b50c g     O .rwdata	00000004 pLCD_DMA
0080c064 g     F .text	000004e4 .hidden __subsf3
00815dae g     O .rodata	000002f8 FreeSerif18pt7bGlyphs
008049c8 g     F .text	00000198 BitBlt_9341
00807f50 g     F .text	00000280 CansellOffset
00802468 g     F .text	000001d4 vTaskPrioritySet
00805f28 g     F .text	0000006c glcd_drawVline
0081152c g     F .text	00000054 alt_dma_txchan_open
0081b514 g     O .rwdata	00000004 pFT245
0081b360 g     O .rwdata	00000180 alt_fd_list
00800620 g     F .text	00000038 xPortStartScheduler
00802a04 g     F .text	00000048 vTaskEndScheduler
00811640 g     F .text	00000090 alt_find_dev
0080f444 g     F .text	00000148 memcpy
00812944 g     O .rodata	0000000c FreeMono9pt7b
00802f68 g     F .text	00000050 vTaskPlaceOnEventList
0080ee88 g     F .text	000000dc .hidden __floatsidf
008117b4 g     F .text	0000007c alt_io_redirect
0080dbac g     F .text	000000f4 .hidden __ltdf2
00801808 g     F .text	0000007c xQueuePeekFromISR
008122f8 g       *ABS*	00000000 __DTOR_END__
00817119 g     O .rodata	00000ed8 Font20_Table
00808ba4 g     F .text	00000330 task_disp
00800b68 g     F .text	000000cc vPortFree
0080ae1c g     F .text	00000074 __fpclassifyd
00810be0 g     F .text	0000021c altera_avalon_jtag_uart_read
0080f378 g     F .text	00000064 .hidden __udivsi3
0081b5cc g     O .bss	00000004 sample_block
00803528 g     F .text	00000060 uxTaskGetStackHighWaterMark
0080031c g     F .text	0000008c vListInsertEnd
008081d0 g     F .text	0000034c MicCarivration
0082b708 g     O .bss	0000001c Ft245Data
00802888 g     F .text	000000ec xTaskResumeFromISR
00805af4 g     F .text	00000064 FT245_SendChar
008002f0 g     F .text	0000002c vListInitialiseItem
00806eac g     F .text	000000b8 uint16toAsciiHex
0081b540 g     O .rwdata	00000004 alt_max_fd
00800708 g     F .text	00000040 vPortSysTickHandler
00804540 g     F .text	00000488 init_9341
0080241c g     F .text	0000004c uxTaskPriorityGetFromISR
00800748 g     F .text	00000170 alt_irq_register
0080ef64 g     F .text	00000110 .hidden __extendsfdf2
0080c7cc g     F .text	000008ac .hidden __adddf3
0080fa5c g     F .text	000000f8 alt_avalon_dma_launch_bidir
0081b5b0 g     O .bss	00000004 GLCD_QUE
0081149c g     F .text	00000054 alt_dma_rxchan_open
0081b520 g     O .rwdata	00000004 __fdlib_version
0081b524 g     O .rwdata	00000004 _global_impure_ptr
0082b858 g       *ABS*	00000000 __bss_end
008008b8 g     F .text	000000e0 alt_iic_isr_register
00811bd4 g     F .text	00000108 alt_tick
0082b724 g     O .bss	0000000a CmdBuf
00800998 g     F .text	000001d0 pvPortMalloc
0080f818 g     F .text	0000004c alt_ic_irq_enabled
0080712c g     F .text	000000c4 char2AsciiHex
00801948 g     F .text	0000003c vQueueDelete
00800658 g     F .text	00000020 vPortEndScheduler
00807e7c g     F .text	00000068 init_PDM
00800288 g     F .text	00000068 vListInitialise
00811b38 g     F .text	0000009c alt_alarm_stop
0081b5d4 g     O .bss	00000004 alt_irq_active
00806d74 g     F .text	00000138 AsciiHex2uint16
0080017c g     F .exceptions	000000d4 alt_irq_handler
0081b338 g     O .rwdata	00000028 alt_dev_null
0081b4f0 g     O .rwdata	00000008 Font16
00802bdc g     F .text	00000028 xTaskGetTickCount
00801178 g     F .text	000001b4 xQueueGenericSend
0080aea4 g     F .text	000001ec rint
00813b3c g     O .rodata	0000103f FreeSans18pt7bBitmaps
00805d18 g     F .text	00000088 encodeRGB565
00805abc g     F .text	00000038 FT245_DisableRxIrq
0080ee08 g     F .text	00000080 .hidden __fixdfsi
008037a4 g     F .text	00000108 xTaskPriorityDisinherit
0080504c g     F .text	00000740 drawLine_9341
0081b538 g     O .rwdata	00000008 alt_dev_list
00810198 g     F .text	00000074 alt_avalon_dma_space
0081b4e8 g     O .rwdata	00000008 Font12
0080bb78 g     F .text	000000bc .hidden __gtsf2
0080301c g     F .text	00000100 xTaskRemoveFromEventList
0080dbac g     F .text	000000f4 .hidden __ledf2
0081b518 g     O .rwdata	00000004 pPDM
00805a00 g     F .text	00000040 FT245IRQregist
0080f3dc g     F .text	00000058 .hidden __umodsi3
0081b5b4 g     O .bss	00000004 SnsorQue
00809040 g     F .text	000001c4 task_sns
0082b858 g       *ABS*	00000000 end
00804498 g     F .text	000000a8 start_LCD_DMA_BufferFill
00802190 g     F .text	000000e8 vTaskDelete
0081071c g     F .text	000000c0 altera_avalon_jtag_uart_init
00808584 g     F .text	000000c4 setMicGain
00812950 g     O .rodata	00000ee5 FreeMonoBold18pt7bBitmaps
00806d1c g     F .text	00000058 InitCom
008039a4 g     F .text	00000038 pvTaskIncrementMutexHeldCount
008122f8 g       *ABS*	00000000 __CTOR_LIST__
00900000 g       *ABS*	00000000 __alt_stack_pointer
00811098 g     F .text	0000007c alt_avalon_timer_sc_init
0080f21c g     F .text	00000064 .hidden __clzsi2
00810dfc g     F .text	00000224 altera_avalon_jtag_uart_write
0081b5b8 g     O .bss	00000004 SendReqQue
0081b500 g     O .rwdata	00000008 Font24
0080323c g     F .text	000000dc xTaskCheckForTimeOut
00808b04 g     F .text	000000a0 disp_debug_str
008043f4 g     F .text	000000a4 start_LCD_DMA_FILL
0081020c g     F .text	00000138 alt_avalon_dma_send
00812144 g     F .text	00000180 __call_exitprocs
0081b54c g     O .rwdata	00000008 alt_dma_txchan_list
008039dc g     F .text	000000b0 ulTaskNotifyTake
00800250 g     F .text	00000038 _start
0081b5e4 g     O .bss	00000004 _alt_tick_rate
00802a4c g     F .text	0000002c vTaskSuspendAll
00813b30 g     O .rodata	0000000c FreeMonoBold18pt7b
00802c04 g     F .text	0000002c xTaskGetTickCountFromISR
00805da0 g     F .text	0000004c glcd_Init
0081b5e8 g     O .bss	00000004 _alt_nticks
0080f94c g     F .text	000000a8 alt_sys_init
0080c5b8 g     F .text	00000124 .hidden __floatsisf
00800480 g     F .text	00000098 uxListRemove
00814e80 g     O .rodata	00000f2e FreeSerif18pt7bBitmaps
0081202c g     F .text	00000118 __register_exitproc
00804ed8 g     F .text	0000004c ClearScreen_9341
00809ac0 g     F .text	000010a4 __ieee754_pow
00810a88 g     F .text	00000068 altera_avalon_jtag_uart_close
008095fc g     F .text	000004c4 pow
0080365c g     F .text	00000148 vTaskPriorityInherit
0080b248 g     F .text	00000028 .hidden __mulsi3
0080404c g     F .text	00000078 xTaskNotifyStateClear
008027b0 g     F .text	000000d8 vTaskResume
00804e1c g     F .text	000000bc Pset_9341
00802e70 g     F .text	000000f8 vTaskSwitchContext
008160c5 g     O .rodata	00000474 Font12_Table
0081b4f8 g     O .rwdata	00000008 Font20
008105b8 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00811e08 g     F .text	000000c4 alt_get_fd
0081b510 g     O .rwdata	00000004 pDMA
008041ac g     F .text	00000138 LoadFont
0082b748 g     O .bss	00000010 QUE_GLCD_LOCAL
00803a8c g     F .text	000000f4 xTaskNotifyWait
00816539 g     O .rodata	00000be0 Font16_Table
00805a40 g     F .text	0000007c FT245_EnableRxIrq
00811f18 g     F .text	0000007c memcmp
00810678 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0082b858 g       *ABS*	00000000 __alt_stack_base
008106c8 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
008071f0 g     F .text	000001c0 CmndSeq
0080263c g     F .text	000000e0 vTaskSuspend
0080d078 g     F .text	000009d0 .hidden __divdf3
00808648 g     F .text	00000050 setSampleFreq
00802c30 g     F .text	00000020 uxTaskGetNumberOfTasks
0080dca0 g     F .text	0000086c .hidden __muldf3
00806cb8 g     F .text	00000064 debug_print
00811d00 g     F .text	00000108 alt_find_file
008113bc g     F .text	000000a4 alt_dev_llist_insert
00804cc4 g     F .text	00000158 Rectangle_9341
0080107c g     F .text	000000a4 xQueueTakeMutexRecursive
00805888 g     F .text	00000044 init_DMAMOD
00803b80 g     F .text	000001b0 xTaskGenericNotify
00817ff1 g     O .rodata	00001ab8 Font24_Table
0081b560 g       *ABS*	00000000 __bss_start
0080f58c g     F .text	00000128 memset
00806a74 g     F .text	00000130 main
00810018 g     F .text	00000048 alt_avalon_dma_rx_ioctl
0081b5e0 g     O .bss	00000004 alt_envp
00810618 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
008003a8 g     F .text	000000d8 vListInsert
008160a8 g     O .rodata	0000000c FreeSerif18pt7b
008060bc g     F .text	00000074 glcd_BitBLT
0080ae90 g     F .text	00000008 matherr
0080f074 g     F .text	000001a8 .hidden __truncdfsf2
0081b554 g     O .rwdata	00000004 alt_errno
00802278 g     F .text	000000f0 vTaskDelayUntil
00801724 g     F .text	000000e4 xQueueReceiveFromISR
00805b58 g     F .text	000000b0 FT245_SendBlock
00804fb8 g     F .text	00000094 drawHline_9341
00803634 g     F .text	00000028 xTaskGetCurrentTaskHandle
00804f24 g     F .text	00000094 drawVline_9341
0080f280 g     F .text	00000084 .hidden __divsi3
00812300 g     O .rodata	0000034c FreeMono9pt7bBitmaps
00800e0c g     F .text	000000a0 xQueueGenericCreate
008122f8 g       *ABS*	00000000 __CTOR_END__
00002000 g       *ABS*	00000000 __alt_mem_serialflash
0080bc34 g     F .text	00000430 .hidden __mulsf3
0080ae00 g     F .text	0000001c finite
00801120 g     F .text	00000058 xQueueCreateCountingSemaphore
008122f8 g       *ABS*	00000000 __DTOR_LIST__
0080b22c g     F .text	0000001c copysign
00803d30 g     F .text	000001ec xTaskGenericNotifyFromISR
0080da48 g     F .text	00000088 .hidden __nedf2
0080f914 g     F .text	00000038 alt_irq_init
0080311c g     F .text	000000e4 xTaskRemoveFromUnorderedEventList
00811ab4 g     F .text	00000084 alt_release_fd
00802a78 g     F .text	00000164 xTaskResumeAll
0081b508 g     O .rwdata	00000004 pILI9341
008018c4 g     F .text	00000054 uxQueueSpacesAvailable
00819bb0 g     O .rodata	00000100 .hidden __clz_tab
00802974 g     F .text	00000090 vTaskStartScheduler
00811ecc g     F .text	00000014 atexit
0080bb78 g     F .text	000000bc .hidden __gesf2
00800518 g     F .text	00000028 prvReadGp
00801d88 g     F .text	00000048 xQueueIsQueueFullFromISR
00807ee4 g     F .text	00000038 enable_PDM
0081b528 g     O .rwdata	00000004 _impure_ptr
0081b5d8 g     O .bss	00000004 alt_argc
0081264c g     O .rodata	000002f8 FreeMono9pt7bGlyphs
0080b090 g     F .text	0000019c scalbn
008115e0 g     F .text	00000060 _do_dtors
00814b7c g     O .rodata	000002f8 FreeSans18pt7bGlyphs
0081b5c8 g     O .bss	00000004 IFSTS
0081b51c g     O .rwdata	00000004 pPDMDATA
00803318 g     F .text	00000028 vTaskMissedYield
0081b530 g     O .rwdata	00000008 alt_fs_list
00806f64 g     F .text	000001c8 AsciiHex2char
0080600c g     F .text	000000b0 glcd_drawRectangleFill
00801884 g     F .text	00000040 uxQueueMessagesWaiting
008014f0 g     F .text	00000234 xQueueGenericReceive
0080ae98 g     F .text	0000000c nan
00802c90 g     F .text	000001e0 xTaskIncrementTick
0080ab64 g     F .text	00000288 __ieee754_sqrt
0080f6b4 g     F .text	00000050 alt_ic_isr_register
00800ce0 g     F .text	0000012c xQueueGenericReset
00814e74 g     O .rodata	0000000c FreeSans18pt7b
0081b560 g       *ABS*	00000000 _edata
0082b858 g       *ABS*	00000000 _end
0080578c g     F .text	000000fc Box_9341
00810af0 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
00801dd0 g     F .text	000000e8 xTaskCreate
00808ed4 g     F .text	0000016c task_main
00800c54 g     F .text	00000020 vPortInitialiseBlocks
0080f78c g     F .text	0000008c alt_ic_irq_disable
0082b72e g     O .bss	0000000a RspBuf
0080851c g     F .text	00000068 getMicData
00811ee0 g     F .text	00000038 exit
008065c0 g     F .text	00000388 put_charPattern_Adafruit
0080c6dc g     F .text	000000f0 .hidden __floatunsisf
008077fc g     F .text	00000680 Execute
0080f304 g     F .text	00000074 .hidden __modsi3
00802368 g     F .text	0000005c vTaskDelay
00900000 g       *ABS*	00000000 __alt_data_end
00806ba4 g     F .text	00000114 conv_4bit_7segdata
00800000 g       *ABS*	00000000 __alt_mem_sdram
0080434c g     F .text	000000a8 start_LCD_DMA_BitBLT
008122c4 g     F .text	00000034 _exit
0080746c g     F .text	00000390 CommandChk
00811114 g     F .text	0000012c alt_alarm_start
00803900 g     F .text	00000060 vTaskExitCritical
00811f94 g     F .text	00000098 strlen
00800540 g     F .text	000000e0 pxPortInitialiseStack
00811958 g     F .text	0000015c open
0080dad0 g     F .text	000000dc .hidden __gedf2
0080882c g     F .text	000002d8 task_com
00080000 g       *ABS*	00000000 __alt_mem_onchip_flash
00803200 g     F .text	0000003c vTaskSetTimeOutState
0081b5d0 g     O .bss	00000004 SnsCtrlSTS
0081b52c g     O .rwdata	00000004 alt_priority_mask
0080f704 g     F .text	00000088 alt_ic_irq_enable
008063b8 g     F .text	00000208 glcd_put_string_fixed
00801918 g     F .text	00000030 uxQueueMessagesWaitingFromISR
00801cf0 g     F .text	00000040 xQueueIsQueueEmptyFromISR
00804b60 g     F .text	00000164 BitBlt_9341_GRAY8
00810060 g     F .text	00000138 alt_avalon_dma_prepare
0080e50c g     F .text	000008fc .hidden __subdf3
0081b544 g     O .rwdata	00000008 alt_dma_rxchan_list
008058cc g     F .text	00000068 startDMA
0081b558 g     O .rwdata	00000008 alt_alarm_list
00811580 g     F .text	00000060 _do_ctors
00803960 g     F .text	00000044 uxTaskResetEventItemValue
00805c08 g     F .text	00000110 FT245_Send_DMA_FIFO
00800f90 g     F .text	0000005c xQueueCreateMutex
0082b738 g     O .bss	00000010 LocQue
0081127c g     F .text	000000d8 close
0080b270 g     F .text	000004c8 .hidden __addsf3
00813836 g     O .rodata	000002f8 FreeMonoBold18pt7bGlyphs
00803f1c g     F .text	00000130 vTaskNotifyGiveFromISR
00805f94 g     F .text	00000078 glcd_drawRectangle
0081b5bc g     O .bss	00000004 ButtonQue
0080ffd0 g     F .text	00000048 alt_avalon_dma_tx_ioctl
00801414 g     F .text	000000dc xQueueGiveFromISR
0081b5c4 g     O .bss	00000004 debug_disp_raw



Disassembly of section .exceptions:

00800020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
  800020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
  800024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
  800028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
  80002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
  800030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
  800034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
  800038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
  80003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
  800040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
  800044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
  800048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
  80004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
  800050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
  800054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
  800058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
  80005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
  800060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
  800064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
  800068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
  80006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
  800070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
  800074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
  800078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
  80007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
  800080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
  800084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
  800088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
  80008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
  800090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
  800094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
  800098:	df001c15 	stw	fp,112(sp)

0080009c <save_sp_to_pxCurrentTCB>:
  80009c:	060020b4 	movhi	et,130

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
  8000a0:	c62d5d04 	addi	et,et,-19084
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
  8000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
  8000a8:	c6c00015 	stw	sp,0(et)

008000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
  8000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
  8000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
  8000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
  8000b8:	10002526 	beq	r2,zero,800150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
  8000bc:	20002426 	beq	r4,zero,800150 <soft_exceptions>

008000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
  8000c0:	080017c0 	call	80017c <alt_irq_handler>

008000c4 <restore_sp_from_pxCurrentTCB>:
  8000c4:	060020b4 	movhi	et,130

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
  8000c8:	c62d5d04 	addi	et,et,-19084
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
  8000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
  8000d0:	c6c00017 	ldw	sp,0(et)

008000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
  8000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
  8000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
  8000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
  8000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
  8000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
  8000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
  8000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
  8000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
  8000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
  8000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
  8000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
  800100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
  800104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
  800108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
  80010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
  800110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
  800114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
  800118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
  80011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
  800120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
  800124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
  800128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
  80012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
  800130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
  800134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
  800138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
  80013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
  800140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
  800144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
  800148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
  80014c:	ef80083a 	eret

00800150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
  800150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
  800154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
  800158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
  80015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
  800160:	c0000226 	beq	et,zero,80016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
  800164:	003da03a 	break	0
  	br		restore_context			# its something else
  800168:	003fda06 	br	8000d4 <__alt_data_end+0xfff000d4>

0080016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
  80016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
  800170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
  800174:	0802e700 	call	802e70 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
  800178:	003fd206 	br	8000c4 <__alt_data_end+0xfff000c4>

0080017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  80017c:	defff904 	addi	sp,sp,-28
  800180:	dfc00615 	stw	ra,24(sp)
  800184:	df000515 	stw	fp,20(sp)
  800188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  80018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800190:	0005313a 	rdctl	r2,ipending
  800194:	e0bffe15 	stw	r2,-8(fp)

  return active;
  800198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  80019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  8001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  8001a4:	00800044 	movi	r2,1
  8001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  8001ac:	e0fffb17 	ldw	r3,-20(fp)
  8001b0:	e0bffc17 	ldw	r2,-16(fp)
  8001b4:	1884703a 	and	r2,r3,r2
  8001b8:	10001426 	beq	r2,zero,80020c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  8001bc:	008020f4 	movhi	r2,131
  8001c0:	10add604 	addi	r2,r2,-18600
  8001c4:	e0fffd17 	ldw	r3,-12(fp)
  8001c8:	180690fa 	slli	r3,r3,3
  8001cc:	10c5883a 	add	r2,r2,r3
  8001d0:	10c00017 	ldw	r3,0(r2)
  8001d4:	008020f4 	movhi	r2,131
  8001d8:	10add604 	addi	r2,r2,-18600
  8001dc:	e13ffd17 	ldw	r4,-12(fp)
  8001e0:	200890fa 	slli	r4,r4,3
  8001e4:	1105883a 	add	r2,r2,r4
  8001e8:	10800104 	addi	r2,r2,4
  8001ec:	10800017 	ldw	r2,0(r2)
  8001f0:	1009883a 	mov	r4,r2
  8001f4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  8001f8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  8001fc:	0005313a 	rdctl	r2,ipending
  800200:	e0bfff15 	stw	r2,-4(fp)

  return active;
  800204:	e0bfff17 	ldw	r2,-4(fp)
  800208:	00000706 	br	800228 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  80020c:	e0bffc17 	ldw	r2,-16(fp)
  800210:	1085883a 	add	r2,r2,r2
  800214:	e0bffc15 	stw	r2,-16(fp)
      i++;
  800218:	e0bffd17 	ldw	r2,-12(fp)
  80021c:	10800044 	addi	r2,r2,1
  800220:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  800224:	003fe106 	br	8001ac <__alt_data_end+0xfff001ac>

    active = alt_irq_pending ();
  800228:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  80022c:	e0bffb17 	ldw	r2,-20(fp)
  800230:	103fdb1e 	bne	r2,zero,8001a0 <__alt_data_end+0xfff001a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  800234:	0001883a 	nop
}
  800238:	0001883a 	nop
  80023c:	e037883a 	mov	sp,fp
  800240:	dfc00117 	ldw	ra,4(sp)
  800244:	df000017 	ldw	fp,0(sp)
  800248:	dec00204 	addi	sp,sp,8
  80024c:	f800283a 	ret

Disassembly of section .text:

00800250 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  800250:	06c02434 	movhi	sp,144
    ori sp, sp, %lo(__alt_stack_pointer)
  800254:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  800258:	068020b4 	movhi	gp,130
    ori gp, gp, %lo(_gp)
  80025c:	d68d3814 	ori	gp,gp,13536
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  800260:	00802074 	movhi	r2,129
    ori r2, r2, %lo(__bss_start)
  800264:	10ad5814 	ori	r2,r2,46432

    movhi r3, %hi(__bss_end)
  800268:	00c020b4 	movhi	r3,130
    ori r3, r3, %lo(__bss_end)
  80026c:	18ee1614 	ori	r3,r3,47192

    beq r2, r3, 1f
  800270:	10c00326 	beq	r2,r3,800280 <_start+0x30>

0:
    stw zero, (r2)
  800274:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  800278:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  80027c:	10fffd36 	bltu	r2,r3,800274 <__alt_data_end+0xfff00274>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  800280:	080f8640 	call	80f864 <alt_main>

00800284 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  800284:	003fff06 	br	800284 <__alt_data_end+0xfff00284>

00800288 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  800288:	defffe04 	addi	sp,sp,-8
  80028c:	df000115 	stw	fp,4(sp)
  800290:	df000104 	addi	fp,sp,4
  800294:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  800298:	e0bfff17 	ldw	r2,-4(fp)
  80029c:	10c00204 	addi	r3,r2,8
  8002a0:	e0bfff17 	ldw	r2,-4(fp)
  8002a4:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  8002a8:	e0bfff17 	ldw	r2,-4(fp)
  8002ac:	00ffffc4 	movi	r3,-1
  8002b0:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8002b4:	e0bfff17 	ldw	r2,-4(fp)
  8002b8:	10c00204 	addi	r3,r2,8
  8002bc:	e0bfff17 	ldw	r2,-4(fp)
  8002c0:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8002c4:	e0bfff17 	ldw	r2,-4(fp)
  8002c8:	10c00204 	addi	r3,r2,8
  8002cc:	e0bfff17 	ldw	r2,-4(fp)
  8002d0:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  8002d4:	e0bfff17 	ldw	r2,-4(fp)
  8002d8:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  8002dc:	0001883a 	nop
  8002e0:	e037883a 	mov	sp,fp
  8002e4:	df000017 	ldw	fp,0(sp)
  8002e8:	dec00104 	addi	sp,sp,4
  8002ec:	f800283a 	ret

008002f0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  8002f0:	defffe04 	addi	sp,sp,-8
  8002f4:	df000115 	stw	fp,4(sp)
  8002f8:	df000104 	addi	fp,sp,4
  8002fc:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  800300:	e0bfff17 	ldw	r2,-4(fp)
  800304:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  800308:	0001883a 	nop
  80030c:	e037883a 	mov	sp,fp
  800310:	df000017 	ldw	fp,0(sp)
  800314:	dec00104 	addi	sp,sp,4
  800318:	f800283a 	ret

0080031c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  80031c:	defffc04 	addi	sp,sp,-16
  800320:	df000315 	stw	fp,12(sp)
  800324:	df000304 	addi	fp,sp,12
  800328:	e13ffe15 	stw	r4,-8(fp)
  80032c:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
  800330:	e0bffe17 	ldw	r2,-8(fp)
  800334:	10800117 	ldw	r2,4(r2)
  800338:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  80033c:	e0bfff17 	ldw	r2,-4(fp)
  800340:	e0fffd17 	ldw	r3,-12(fp)
  800344:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  800348:	e0bffd17 	ldw	r2,-12(fp)
  80034c:	10c00217 	ldw	r3,8(r2)
  800350:	e0bfff17 	ldw	r2,-4(fp)
  800354:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  800358:	e0bffd17 	ldw	r2,-12(fp)
  80035c:	10800217 	ldw	r2,8(r2)
  800360:	e0ffff17 	ldw	r3,-4(fp)
  800364:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
  800368:	e0bffd17 	ldw	r2,-12(fp)
  80036c:	e0ffff17 	ldw	r3,-4(fp)
  800370:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  800374:	e0bfff17 	ldw	r2,-4(fp)
  800378:	e0fffe17 	ldw	r3,-8(fp)
  80037c:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800380:	e0bffe17 	ldw	r2,-8(fp)
  800384:	10800017 	ldw	r2,0(r2)
  800388:	10c00044 	addi	r3,r2,1
  80038c:	e0bffe17 	ldw	r2,-8(fp)
  800390:	10c00015 	stw	r3,0(r2)
}
  800394:	0001883a 	nop
  800398:	e037883a 	mov	sp,fp
  80039c:	df000017 	ldw	fp,0(sp)
  8003a0:	dec00104 	addi	sp,sp,4
  8003a4:	f800283a 	ret

008003a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  8003a8:	defffb04 	addi	sp,sp,-20
  8003ac:	df000415 	stw	fp,16(sp)
  8003b0:	df000404 	addi	fp,sp,16
  8003b4:	e13ffe15 	stw	r4,-8(fp)
  8003b8:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  8003bc:	e0bfff17 	ldw	r2,-4(fp)
  8003c0:	10800017 	ldw	r2,0(r2)
  8003c4:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  8003c8:	e0bffd17 	ldw	r2,-12(fp)
  8003cc:	10bfffd8 	cmpnei	r2,r2,-1
  8003d0:	1000041e 	bne	r2,zero,8003e4 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  8003d4:	e0bffe17 	ldw	r2,-8(fp)
  8003d8:	10800417 	ldw	r2,16(r2)
  8003dc:	e0bffc15 	stw	r2,-16(fp)
  8003e0:	00000c06 	br	800414 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8003e4:	e0bffe17 	ldw	r2,-8(fp)
  8003e8:	10800204 	addi	r2,r2,8
  8003ec:	e0bffc15 	stw	r2,-16(fp)
  8003f0:	00000306 	br	800400 <vListInsert+0x58>
  8003f4:	e0bffc17 	ldw	r2,-16(fp)
  8003f8:	10800117 	ldw	r2,4(r2)
  8003fc:	e0bffc15 	stw	r2,-16(fp)
  800400:	e0bffc17 	ldw	r2,-16(fp)
  800404:	10800117 	ldw	r2,4(r2)
  800408:	10800017 	ldw	r2,0(r2)
  80040c:	e0fffd17 	ldw	r3,-12(fp)
  800410:	18bff82e 	bgeu	r3,r2,8003f4 <__alt_data_end+0xfff003f4>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  800414:	e0bffc17 	ldw	r2,-16(fp)
  800418:	10c00117 	ldw	r3,4(r2)
  80041c:	e0bfff17 	ldw	r2,-4(fp)
  800420:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  800424:	e0bfff17 	ldw	r2,-4(fp)
  800428:	10800117 	ldw	r2,4(r2)
  80042c:	e0ffff17 	ldw	r3,-4(fp)
  800430:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
  800434:	e0bfff17 	ldw	r2,-4(fp)
  800438:	e0fffc17 	ldw	r3,-16(fp)
  80043c:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
  800440:	e0bffc17 	ldw	r2,-16(fp)
  800444:	e0ffff17 	ldw	r3,-4(fp)
  800448:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  80044c:	e0bfff17 	ldw	r2,-4(fp)
  800450:	e0fffe17 	ldw	r3,-8(fp)
  800454:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800458:	e0bffe17 	ldw	r2,-8(fp)
  80045c:	10800017 	ldw	r2,0(r2)
  800460:	10c00044 	addi	r3,r2,1
  800464:	e0bffe17 	ldw	r2,-8(fp)
  800468:	10c00015 	stw	r3,0(r2)
}
  80046c:	0001883a 	nop
  800470:	e037883a 	mov	sp,fp
  800474:	df000017 	ldw	fp,0(sp)
  800478:	dec00104 	addi	sp,sp,4
  80047c:	f800283a 	ret

00800480 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  800480:	defffd04 	addi	sp,sp,-12
  800484:	df000215 	stw	fp,8(sp)
  800488:	df000204 	addi	fp,sp,8
  80048c:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
  800490:	e0bfff17 	ldw	r2,-4(fp)
  800494:	10800417 	ldw	r2,16(r2)
  800498:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  80049c:	e0bfff17 	ldw	r2,-4(fp)
  8004a0:	10800117 	ldw	r2,4(r2)
  8004a4:	e0ffff17 	ldw	r3,-4(fp)
  8004a8:	18c00217 	ldw	r3,8(r3)
  8004ac:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  8004b0:	e0bfff17 	ldw	r2,-4(fp)
  8004b4:	10800217 	ldw	r2,8(r2)
  8004b8:	e0ffff17 	ldw	r3,-4(fp)
  8004bc:	18c00117 	ldw	r3,4(r3)
  8004c0:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  8004c4:	e0bffe17 	ldw	r2,-8(fp)
  8004c8:	10c00117 	ldw	r3,4(r2)
  8004cc:	e0bfff17 	ldw	r2,-4(fp)
  8004d0:	1880041e 	bne	r3,r2,8004e4 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  8004d4:	e0bfff17 	ldw	r2,-4(fp)
  8004d8:	10c00217 	ldw	r3,8(r2)
  8004dc:	e0bffe17 	ldw	r2,-8(fp)
  8004e0:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  8004e4:	e0bfff17 	ldw	r2,-4(fp)
  8004e8:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
  8004ec:	e0bffe17 	ldw	r2,-8(fp)
  8004f0:	10800017 	ldw	r2,0(r2)
  8004f4:	10ffffc4 	addi	r3,r2,-1
  8004f8:	e0bffe17 	ldw	r2,-8(fp)
  8004fc:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
  800500:	e0bffe17 	ldw	r2,-8(fp)
  800504:	10800017 	ldw	r2,0(r2)
}
  800508:	e037883a 	mov	sp,fp
  80050c:	df000017 	ldw	fp,0(sp)
  800510:	dec00104 	addi	sp,sp,4
  800514:	f800283a 	ret

00800518 <prvReadGp>:
  void vPortSysTickHandler( void * context, alt_u32 id );
#endif
/*-----------------------------------------------------------*/

void prvReadGp( unsigned long *ulValue )
{
  800518:	defffe04 	addi	sp,sp,-8
  80051c:	df000115 	stw	fp,4(sp)
  800520:	df000104 	addi	fp,sp,4
  800524:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (r4) " );
  800528:	26800015 	stw	gp,0(r4)
};
  80052c:	0001883a 	nop
  800530:	e037883a 	mov	sp,fp
  800534:	df000017 	ldw	fp,0(sp)
  800538:	dec00104 	addi	sp,sp,4
  80053c:	f800283a 	ret

00800540 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
  800540:	defff904 	addi	sp,sp,-28
  800544:	dfc00615 	stw	ra,24(sp)
  800548:	df000515 	stw	fp,20(sp)
  80054c:	df000504 	addi	fp,sp,20
  800550:	e13ffd15 	stw	r4,-12(fp)
  800554:	e17ffe15 	stw	r5,-8(fp)
  800558:	e1bfff15 	stw	r6,-4(fp)
portSTACK_TYPE *pxFramePointer = pxTopOfStack - 1;
  80055c:	e0bffd17 	ldw	r2,-12(fp)
  800560:	10bfff04 	addi	r2,r2,-4
  800564:	e0bffb15 	stw	r2,-20(fp)
portSTACK_TYPE xGlobalPointer;

    prvReadGp( &xGlobalPointer );
  800568:	e0bffc04 	addi	r2,fp,-16
  80056c:	1009883a 	mov	r4,r2
  800570:	08005180 	call	800518 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
  800574:	e0fffd17 	ldw	r3,-12(fp)
  800578:	00b7abb4 	movhi	r2,57006
  80057c:	10afbbc4 	addi	r2,r2,-16657
  800580:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
  800584:	e0bffd17 	ldw	r2,-12(fp)
  800588:	10bfff04 	addi	r2,r2,-4
  80058c:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxFramePointer;
  800590:	e0fffb17 	ldw	r3,-20(fp)
  800594:	e0bffd17 	ldw	r2,-12(fp)
  800598:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  80059c:	e0bffd17 	ldw	r2,-12(fp)
  8005a0:	10bfff04 	addi	r2,r2,-4
  8005a4:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = xGlobalPointer;
  8005a8:	e0fffc17 	ldw	r3,-16(fp)
  8005ac:	e0bffd17 	ldw	r2,-12(fp)
  8005b0:	10c00015 	stw	r3,0(r2)

    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
  8005b4:	e0bffd17 	ldw	r2,-12(fp)
  8005b8:	10bff704 	addi	r2,r2,-36
  8005bc:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxCode;
  8005c0:	e0fffe17 	ldw	r3,-8(fp)
  8005c4:	e0bffd17 	ldw	r2,-12(fp)
  8005c8:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  8005cc:	e0bffd17 	ldw	r2,-12(fp)
  8005d0:	10bfff04 	addi	r2,r2,-4
  8005d4:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS;
  8005d8:	e0bffd17 	ldw	r2,-12(fp)
  8005dc:	00c00044 	movi	r3,1
  8005e0:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */
    pxTopOfStack -= 12;
  8005e4:	e0bffd17 	ldw	r2,-12(fp)
  8005e8:	10bff404 	addi	r2,r2,-48
  8005ec:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
  8005f0:	e0ffff17 	ldw	r3,-4(fp)
  8005f4:	e0bffd17 	ldw	r2,-12(fp)
  8005f8:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
  8005fc:	e0bffd17 	ldw	r2,-12(fp)
  800600:	10bffb04 	addi	r2,r2,-20
  800604:	e0bffd15 	stw	r2,-12(fp)

    return pxTopOfStack;
  800608:	e0bffd17 	ldw	r2,-12(fp)
}
  80060c:	e037883a 	mov	sp,fp
  800610:	dfc00117 	ldw	ra,4(sp)
  800614:	df000017 	ldw	fp,0(sp)
  800618:	dec00204 	addi	sp,sp,8
  80061c:	f800283a 	ret

00800620 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  800620:	defffe04 	addi	sp,sp,-8
  800624:	dfc00115 	stw	ra,4(sp)
  800628:	df000015 	stw	fp,0(sp)
  80062c:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
  800630:	08006780 	call	800678 <prvSetupTimerInterrupt>
  800634:	00802034 	movhi	r2,128

	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
  800638:	10803104 	addi	r2,r2,196
  80063c:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
  800640:	0005883a 	mov	r2,zero
}
  800644:	e037883a 	mov	sp,fp
  800648:	dfc00117 	ldw	ra,4(sp)
  80064c:	df000017 	ldw	fp,0(sp)
  800650:	dec00204 	addi	sp,sp,8
  800654:	f800283a 	ret

00800658 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
  800658:	deffff04 	addi	sp,sp,-4
  80065c:	df000015 	stw	fp,0(sp)
  800660:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
  800664:	0001883a 	nop
  800668:	e037883a 	mov	sp,fp
  80066c:	df000017 	ldw	fp,0(sp)
  800670:	dec00104 	addi	sp,sp,4
  800674:	f800283a 	ret

00800678 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
  800678:	defffd04 	addi	sp,sp,-12
  80067c:	dfc00215 	stw	ra,8(sp)
  800680:	df000115 	stw	fp,4(sp)
  800684:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
	if ( -EINVAL ==     alt_ic_isr_register(SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ,
  800688:	d8000015 	stw	zero,0(sp)
  80068c:	000f883a 	mov	r7,zero
  800690:	01802034 	movhi	r6,128
  800694:	3181c204 	addi	r6,r6,1800
  800698:	01400044 	movi	r5,1
  80069c:	0009883a 	mov	r4,zero
  8006a0:	080f6b40 	call	80f6b4 <alt_ic_isr_register>
  8006a4:	10bffa98 	cmpnei	r2,r2,-22
  8006a8:	1000021e 	bne	r2,zero,8006b4 <prvSetupTimerInterrupt+0x3c>
#else
	if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
#endif
	{
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
  8006ac:	003da03a 	break	0
  8006b0:	00000c06 	br	8006e4 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
  8006b4:	00c00204 	movi	r3,8
  8006b8:	00840904 	movi	r2,4132
  8006bc:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
  8006c0:	00f0d414 	movui	r3,50000
  8006c4:	00840a04 	movi	r2,4136
  8006c8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
  8006cc:	0007883a 	mov	r3,zero
  8006d0:	00840b04 	movi	r2,4140
  8006d4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
  8006d8:	00c001c4 	movi	r3,7
  8006dc:	00840904 	movi	r2,4132
  8006e0:	10c00035 	stwio	r3,0(r2)
	}

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  8006e4:	00ffff84 	movi	r3,-2
  8006e8:	00840804 	movi	r2,4128
  8006ec:	10c00035 	stwio	r3,0(r2)
}
  8006f0:	0001883a 	nop
  8006f4:	e037883a 	mov	sp,fp
  8006f8:	dfc00117 	ldw	ra,4(sp)
  8006fc:	df000017 	ldw	fp,0(sp)
  800700:	dec00204 	addi	sp,sp,8
  800704:	f800283a 	ret

00800708 <vPortSysTickHandler>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
void vPortSysTickHandler( void * context )
#else
void vPortSysTickHandler( void * context, alt_u32 id )
#endif
{
  800708:	defffd04 	addi	sp,sp,-12
  80070c:	dfc00215 	stw	ra,8(sp)
  800710:	df000115 	stw	fp,4(sp)
  800714:	df000104 	addi	fp,sp,4
  800718:	e13fff15 	stw	r4,-4(fp)
	/* Increment the Kernel Tick. */
	//vTaskIncrementTick();
	(void)xTaskIncrementTick();
  80071c:	0802c900 	call	802c90 <xTaskIncrementTick>

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
        vTaskSwitchContext();
  800720:	0802e700 	call	802e70 <vTaskSwitchContext>
	#endif

	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  800724:	00ffff84 	movi	r3,-2
  800728:	00840804 	movi	r2,4128
  80072c:	10c00035 	stwio	r3,0(r2)
}
  800730:	0001883a 	nop
  800734:	e037883a 	mov	sp,fp
  800738:	dfc00117 	ldw	ra,4(sp)
  80073c:	df000017 	ldw	fp,0(sp)
  800740:	dec00204 	addi	sp,sp,8
  800744:	f800283a 	ret

00800748 <alt_irq_register>:
#ifndef ALT_ENHANCED_INTERRUPT_API_PRESENT
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
#else
int alt_irq_register( alt_u32 id, void* context, alt_isr_func handler )
#endif
{
  800748:	defff104 	addi	sp,sp,-60
  80074c:	df000e15 	stw	fp,56(sp)
  800750:	df000e04 	addi	fp,sp,56
  800754:	e13ffd15 	stw	r4,-12(fp)
  800758:	e17ffe15 	stw	r5,-8(fp)
  80075c:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;
  800760:	00bffa84 	movi	r2,-22
  800764:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
  800768:	e0bffd17 	ldw	r2,-12(fp)
  80076c:	10800828 	cmpgeui	r2,r2,32
  800770:	10004c1e 	bne	r2,zero,8008a4 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800774:	0005303a 	rdctl	r2,status
  800778:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80077c:	e0fff617 	ldw	r3,-40(fp)
  800780:	00bfff84 	movi	r2,-2
  800784:	1884703a 	and	r2,r3,r2
  800788:	1001703a 	wrctl	status,r2
  
  return context;
  80078c:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */

		status = alt_irq_disable_all ();
  800790:	e0bff415 	stw	r2,-48(fp)

		alt_irq[id].handler = handler;
  800794:	008020f4 	movhi	r2,131
  800798:	10add604 	addi	r2,r2,-18600
  80079c:	e0fffd17 	ldw	r3,-12(fp)
  8007a0:	180690fa 	slli	r3,r3,3
  8007a4:	10c5883a 	add	r2,r2,r3
  8007a8:	e0ffff17 	ldw	r3,-4(fp)
  8007ac:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
  8007b0:	008020f4 	movhi	r2,131
  8007b4:	10add604 	addi	r2,r2,-18600
  8007b8:	e0fffd17 	ldw	r3,-12(fp)
  8007bc:	180690fa 	slli	r3,r3,3
  8007c0:	10c5883a 	add	r2,r2,r3
  8007c4:	10800104 	addi	r2,r2,4
  8007c8:	e0fffe17 	ldw	r3,-8(fp)
  8007cc:	10c00015 	stw	r3,0(r2)

		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
  8007d0:	e0bfff17 	ldw	r2,-4(fp)
  8007d4:	10001926 	beq	r2,zero,80083c <alt_irq_register+0xf4>
  8007d8:	e0bffd17 	ldw	r2,-12(fp)
  8007dc:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8007e0:	0005303a 	rdctl	r2,status
  8007e4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8007e8:	e0fff717 	ldw	r3,-36(fp)
  8007ec:	00bfff84 	movi	r2,-2
  8007f0:	1884703a 	and	r2,r3,r2
  8007f4:	1001703a 	wrctl	status,r2
  
  return context;
  8007f8:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  8007fc:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
  800800:	00c00044 	movi	r3,1
  800804:	e0bff317 	ldw	r2,-52(fp)
  800808:	1884983a 	sll	r2,r3,r2
  80080c:	1007883a 	mov	r3,r2
  800810:	d0a03d17 	ldw	r2,-32524(gp)
  800814:	1884b03a 	or	r2,r3,r2
  800818:	d0a03d15 	stw	r2,-32524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  80081c:	d0a03d17 	ldw	r2,-32524(gp)
  800820:	100170fa 	wrctl	ienable,r2
  800824:	e0bff817 	ldw	r2,-32(fp)
  800828:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80082c:	e0bff917 	ldw	r2,-28(fp)
  800830:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  800834:	0005883a 	mov	r2,zero
  800838:	00001906 	br	8008a0 <alt_irq_register+0x158>
  80083c:	e0bffd17 	ldw	r2,-12(fp)
  800840:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800844:	0005303a 	rdctl	r2,status
  800848:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80084c:	e0fffa17 	ldw	r3,-24(fp)
  800850:	00bfff84 	movi	r2,-2
  800854:	1884703a 	and	r2,r3,r2
  800858:	1001703a 	wrctl	status,r2
  
  return context;
  80085c:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  800860:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
  800864:	00c00044 	movi	r3,1
  800868:	e0bff517 	ldw	r2,-44(fp)
  80086c:	1884983a 	sll	r2,r3,r2
  800870:	0084303a 	nor	r2,zero,r2
  800874:	1007883a 	mov	r3,r2
  800878:	d0a03d17 	ldw	r2,-32524(gp)
  80087c:	1884703a 	and	r2,r3,r2
  800880:	d0a03d15 	stw	r2,-32524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  800884:	d0a03d17 	ldw	r2,-32524(gp)
  800888:	100170fa 	wrctl	ienable,r2
  80088c:	e0bffb17 	ldw	r2,-20(fp)
  800890:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  800894:	e0bffc17 	ldw	r2,-16(fp)
  800898:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  80089c:	0005883a 	mov	r2,zero
  8008a0:	e0bff215 	stw	r2,-56(fp)

		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}

	return rc;
  8008a4:	e0bff217 	ldw	r2,-56(fp)
}
  8008a8:	e037883a 	mov	sp,fp
  8008ac:	df000017 	ldw	fp,0(sp)
  8008b0:	dec00104 	addi	sp,sp,4
  8008b4:	f800283a 	ret

008008b8 <alt_iic_isr_register>:
  * @param flags
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
  8008b8:	defff604 	addi	sp,sp,-40
  8008bc:	dfc00915 	stw	ra,36(sp)
  8008c0:	df000815 	stw	fp,32(sp)
  8008c4:	df000804 	addi	fp,sp,32
  8008c8:	e13ffc15 	stw	r4,-16(fp)
  8008cc:	e17ffd15 	stw	r5,-12(fp)
  8008d0:	e1bffe15 	stw	r6,-8(fp)
  8008d4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;
  8008d8:	00bffa84 	movi	r2,-22
  8008dc:	e0bff815 	stw	r2,-32(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  8008e0:	e0bffd17 	ldw	r2,-12(fp)
  8008e4:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  8008e8:	e0bff917 	ldw	r2,-28(fp)
  8008ec:	10800808 	cmpgei	r2,r2,32
  8008f0:	1000231e 	bne	r2,zero,800980 <alt_iic_isr_register+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8008f4:	0005303a 	rdctl	r2,status
  8008f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8008fc:	e0fffb17 	ldw	r3,-20(fp)
  800900:	00bfff84 	movi	r2,-2
  800904:	1884703a 	and	r2,r3,r2
  800908:	1001703a 	wrctl	status,r2
  
  return context;
  80090c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  800910:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
  800914:	008020f4 	movhi	r2,131
  800918:	10add604 	addi	r2,r2,-18600
  80091c:	e0fff917 	ldw	r3,-28(fp)
  800920:	180690fa 	slli	r3,r3,3
  800924:	10c5883a 	add	r2,r2,r3
  800928:	e0fffe17 	ldw	r3,-8(fp)
  80092c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  800930:	008020f4 	movhi	r2,131
  800934:	10add604 	addi	r2,r2,-18600
  800938:	e0fff917 	ldw	r3,-28(fp)
  80093c:	180690fa 	slli	r3,r3,3
  800940:	10c5883a 	add	r2,r2,r3
  800944:	10800104 	addi	r2,r2,4
  800948:	e0ffff17 	ldw	r3,-4(fp)
  80094c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  800950:	e0bffe17 	ldw	r2,-8(fp)
  800954:	10000526 	beq	r2,zero,80096c <alt_iic_isr_register+0xb4>
  800958:	e0bff917 	ldw	r2,-28(fp)
  80095c:	100b883a 	mov	r5,r2
  800960:	e13ffc17 	ldw	r4,-16(fp)
  800964:	080f7040 	call	80f704 <alt_ic_irq_enable>
  800968:	00000406 	br	80097c <alt_iic_isr_register+0xc4>
  80096c:	e0bff917 	ldw	r2,-28(fp)
  800970:	100b883a 	mov	r5,r2
  800974:	e13ffc17 	ldw	r4,-16(fp)
  800978:	080f78c0 	call	80f78c <alt_ic_irq_disable>
  80097c:	e0bff815 	stw	r2,-32(fp)

  //  alt_irq_enable_all(status);
  }

  return rc;
  800980:	e0bff817 	ldw	r2,-32(fp)
}
  800984:	e037883a 	mov	sp,fp
  800988:	dfc00117 	ldw	ra,4(sp)
  80098c:	df000017 	ldw	fp,0(sp)
  800990:	dec00204 	addi	sp,sp,8
  800994:	f800283a 	ret

00800998 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  800998:	defff704 	addi	sp,sp,-36
  80099c:	dfc00815 	stw	ra,32(sp)
  8009a0:	df000715 	stw	fp,28(sp)
  8009a4:	df000704 	addi	fp,sp,28
  8009a8:	e13fff15 	stw	r4,-4(fp)
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
  8009ac:	e03ffb15 	stw	zero,-20(fp)

	vTaskSuspendAll();
  8009b0:	0802a4c0 	call	802a4c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
  8009b4:	d0a02417 	ldw	r2,-32624(gp)
  8009b8:	1000031e 	bne	r2,zero,8009c8 <pvPortMalloc+0x30>
		{
			prvHeapInit();
  8009bc:	0800c740 	call	800c74 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
  8009c0:	00800044 	movi	r2,1
  8009c4:	d0a02415 	stw	r2,-32624(gp)
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  8009c8:	e0bfff17 	ldw	r2,-4(fp)
  8009cc:	10000d26 	beq	r2,zero,800a04 <pvPortMalloc+0x6c>
		{
			xWantedSize += heapSTRUCT_SIZE;
  8009d0:	00800204 	movi	r2,8
  8009d4:	10bfffcc 	andi	r2,r2,65535
  8009d8:	e0ffff17 	ldw	r3,-4(fp)
  8009dc:	1885883a 	add	r2,r3,r2
  8009e0:	e0bfff15 	stw	r2,-4(fp)

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
  8009e4:	e0bfff17 	ldw	r2,-4(fp)
  8009e8:	108000cc 	andi	r2,r2,3
  8009ec:	10000526 	beq	r2,zero,800a04 <pvPortMalloc+0x6c>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  8009f0:	e0ffff17 	ldw	r3,-4(fp)
  8009f4:	00bfff04 	movi	r2,-4
  8009f8:	1884703a 	and	r2,r3,r2
  8009fc:	10800104 	addi	r2,r2,4
  800a00:	e0bfff15 	stw	r2,-4(fp)
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
  800a04:	e0bfff17 	ldw	r2,-4(fp)
  800a08:	10005026 	beq	r2,zero,800b4c <pvPortMalloc+0x1b4>
  800a0c:	e0bfff17 	ldw	r2,-4(fp)
  800a10:	10bfff28 	cmpgeui	r2,r2,65532
  800a14:	10004d1e 	bne	r2,zero,800b4c <pvPortMalloc+0x1b4>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
  800a18:	d0a02004 	addi	r2,gp,-32640
  800a1c:	e0bffa15 	stw	r2,-24(fp)
			pxBlock = xStart.pxNextFreeBlock;
  800a20:	d0a02017 	ldw	r2,-32640(gp)
  800a24:	e0bff915 	stw	r2,-28(fp)
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  800a28:	00000506 	br	800a40 <pvPortMalloc+0xa8>
			{
				pxPreviousBlock = pxBlock;
  800a2c:	e0bff917 	ldw	r2,-28(fp)
  800a30:	e0bffa15 	stw	r2,-24(fp)
				pxBlock = pxBlock->pxNextFreeBlock;
  800a34:	e0bff917 	ldw	r2,-28(fp)
  800a38:	10800017 	ldw	r2,0(r2)
  800a3c:	e0bff915 	stw	r2,-28(fp)
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  800a40:	e0bff917 	ldw	r2,-28(fp)
  800a44:	10c00117 	ldw	r3,4(r2)
  800a48:	e0bfff17 	ldw	r2,-4(fp)
  800a4c:	1880032e 	bgeu	r3,r2,800a5c <pvPortMalloc+0xc4>
  800a50:	e0bff917 	ldw	r2,-28(fp)
  800a54:	10800017 	ldw	r2,0(r2)
  800a58:	103ff41e 	bne	r2,zero,800a2c <__alt_data_end+0xfff00a2c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
  800a5c:	e0fff917 	ldw	r3,-28(fp)
  800a60:	d0a02204 	addi	r2,gp,-32632
  800a64:	18803926 	beq	r3,r2,800b4c <pvPortMalloc+0x1b4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  800a68:	e0bffa17 	ldw	r2,-24(fp)
  800a6c:	10c00017 	ldw	r3,0(r2)
  800a70:	00800204 	movi	r2,8
  800a74:	10bfffcc 	andi	r2,r2,65535
  800a78:	1885883a 	add	r2,r3,r2
  800a7c:	e0bffb15 	stw	r2,-20(fp)

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  800a80:	e0bff917 	ldw	r2,-28(fp)
  800a84:	10c00017 	ldw	r3,0(r2)
  800a88:	e0bffa17 	ldw	r2,-24(fp)
  800a8c:	10c00015 	stw	r3,0(r2)

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  800a90:	e0bff917 	ldw	r2,-28(fp)
  800a94:	10c00117 	ldw	r3,4(r2)
  800a98:	e0bfff17 	ldw	r2,-4(fp)
  800a9c:	1887c83a 	sub	r3,r3,r2
  800aa0:	00800204 	movi	r2,8
  800aa4:	10bfffcc 	andi	r2,r2,65535
  800aa8:	1085883a 	add	r2,r2,r2
  800aac:	10c0222e 	bgeu	r2,r3,800b38 <pvPortMalloc+0x1a0>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  800ab0:	e0fff917 	ldw	r3,-28(fp)
  800ab4:	e0bfff17 	ldw	r2,-4(fp)
  800ab8:	1885883a 	add	r2,r3,r2
  800abc:	e0bffd15 	stw	r2,-12(fp)

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  800ac0:	e0bff917 	ldw	r2,-28(fp)
  800ac4:	10c00117 	ldw	r3,4(r2)
  800ac8:	e0bfff17 	ldw	r2,-4(fp)
  800acc:	1887c83a 	sub	r3,r3,r2
  800ad0:	e0bffd17 	ldw	r2,-12(fp)
  800ad4:	10c00115 	stw	r3,4(r2)
					pxBlock->xBlockSize = xWantedSize;
  800ad8:	e0bff917 	ldw	r2,-28(fp)
  800adc:	e0ffff17 	ldw	r3,-4(fp)
  800ae0:	10c00115 	stw	r3,4(r2)

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  800ae4:	e0bffd17 	ldw	r2,-12(fp)
  800ae8:	10800117 	ldw	r2,4(r2)
  800aec:	e0bffe15 	stw	r2,-8(fp)
  800af0:	d0a02004 	addi	r2,gp,-32640
  800af4:	e0bffc15 	stw	r2,-16(fp)
  800af8:	00000306 	br	800b08 <pvPortMalloc+0x170>
  800afc:	e0bffc17 	ldw	r2,-16(fp)
  800b00:	10800017 	ldw	r2,0(r2)
  800b04:	e0bffc15 	stw	r2,-16(fp)
  800b08:	e0bffc17 	ldw	r2,-16(fp)
  800b0c:	10800017 	ldw	r2,0(r2)
  800b10:	10c00117 	ldw	r3,4(r2)
  800b14:	e0bffe17 	ldw	r2,-8(fp)
  800b18:	18bff836 	bltu	r3,r2,800afc <__alt_data_end+0xfff00afc>
  800b1c:	e0bffc17 	ldw	r2,-16(fp)
  800b20:	10c00017 	ldw	r3,0(r2)
  800b24:	e0bffd17 	ldw	r2,-12(fp)
  800b28:	10c00015 	stw	r3,0(r2)
  800b2c:	e0bffc17 	ldw	r2,-16(fp)
  800b30:	e0fffd17 	ldw	r3,-12(fp)
  800b34:	10c00015 	stw	r3,0(r2)
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  800b38:	d0e00117 	ldw	r3,-32764(gp)
  800b3c:	e0bff917 	ldw	r2,-28(fp)
  800b40:	10800117 	ldw	r2,4(r2)
  800b44:	1885c83a 	sub	r2,r3,r2
  800b48:	d0a00115 	stw	r2,-32764(gp)
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  800b4c:	0802a780 	call	802a78 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
  800b50:	e0bffb17 	ldw	r2,-20(fp)
}
  800b54:	e037883a 	mov	sp,fp
  800b58:	dfc00117 	ldw	ra,4(sp)
  800b5c:	df000017 	ldw	fp,0(sp)
  800b60:	dec00204 	addi	sp,sp,8
  800b64:	f800283a 	ret

00800b68 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  800b68:	defff904 	addi	sp,sp,-28
  800b6c:	dfc00615 	stw	ra,24(sp)
  800b70:	df000515 	stw	fp,20(sp)
  800b74:	df000504 	addi	fp,sp,20
  800b78:	e13fff15 	stw	r4,-4(fp)
uint8_t *puc = ( uint8_t * ) pv;
  800b7c:	e0bfff17 	ldw	r2,-4(fp)
  800b80:	e0bffc15 	stw	r2,-16(fp)
BlockLink_t *pxLink;

	if( pv != NULL )
  800b84:	e0bfff17 	ldw	r2,-4(fp)
  800b88:	10002426 	beq	r2,zero,800c1c <vPortFree+0xb4>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  800b8c:	00800204 	movi	r2,8
  800b90:	10bfffcc 	andi	r2,r2,65535
  800b94:	0085c83a 	sub	r2,zero,r2
  800b98:	e0fffc17 	ldw	r3,-16(fp)
  800b9c:	1885883a 	add	r2,r3,r2
  800ba0:	e0bffc15 	stw	r2,-16(fp)

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
  800ba4:	e0bffc17 	ldw	r2,-16(fp)
  800ba8:	e0bffd15 	stw	r2,-12(fp)

		vTaskSuspendAll();
  800bac:	0802a4c0 	call	802a4c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  800bb0:	e0bffd17 	ldw	r2,-12(fp)
  800bb4:	10800117 	ldw	r2,4(r2)
  800bb8:	e0bffe15 	stw	r2,-8(fp)
  800bbc:	d0a02004 	addi	r2,gp,-32640
  800bc0:	e0bffb15 	stw	r2,-20(fp)
  800bc4:	00000306 	br	800bd4 <vPortFree+0x6c>
  800bc8:	e0bffb17 	ldw	r2,-20(fp)
  800bcc:	10800017 	ldw	r2,0(r2)
  800bd0:	e0bffb15 	stw	r2,-20(fp)
  800bd4:	e0bffb17 	ldw	r2,-20(fp)
  800bd8:	10800017 	ldw	r2,0(r2)
  800bdc:	10c00117 	ldw	r3,4(r2)
  800be0:	e0bffe17 	ldw	r2,-8(fp)
  800be4:	18bff836 	bltu	r3,r2,800bc8 <__alt_data_end+0xfff00bc8>
  800be8:	e0bffb17 	ldw	r2,-20(fp)
  800bec:	10c00017 	ldw	r3,0(r2)
  800bf0:	e0bffd17 	ldw	r2,-12(fp)
  800bf4:	10c00015 	stw	r3,0(r2)
  800bf8:	e0bffb17 	ldw	r2,-20(fp)
  800bfc:	e0fffd17 	ldw	r3,-12(fp)
  800c00:	10c00015 	stw	r3,0(r2)
			xFreeBytesRemaining += pxLink->xBlockSize;
  800c04:	e0bffd17 	ldw	r2,-12(fp)
  800c08:	10c00117 	ldw	r3,4(r2)
  800c0c:	d0a00117 	ldw	r2,-32764(gp)
  800c10:	1885883a 	add	r2,r3,r2
  800c14:	d0a00115 	stw	r2,-32764(gp)
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
  800c18:	0802a780 	call	802a78 <xTaskResumeAll>
	}
}
  800c1c:	0001883a 	nop
  800c20:	e037883a 	mov	sp,fp
  800c24:	dfc00117 	ldw	ra,4(sp)
  800c28:	df000017 	ldw	fp,0(sp)
  800c2c:	dec00204 	addi	sp,sp,8
  800c30:	f800283a 	ret

00800c34 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
  800c34:	deffff04 	addi	sp,sp,-4
  800c38:	df000015 	stw	fp,0(sp)
  800c3c:	d839883a 	mov	fp,sp
	return xFreeBytesRemaining;
  800c40:	d0a00117 	ldw	r2,-32764(gp)
}
  800c44:	e037883a 	mov	sp,fp
  800c48:	df000017 	ldw	fp,0(sp)
  800c4c:	dec00104 	addi	sp,sp,4
  800c50:	f800283a 	ret

00800c54 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
  800c54:	deffff04 	addi	sp,sp,-4
  800c58:	df000015 	stw	fp,0(sp)
  800c5c:	d839883a 	mov	fp,sp
	/* This just exists to keep the linker quiet. */
}
  800c60:	0001883a 	nop
  800c64:	e037883a 	mov	sp,fp
  800c68:	df000017 	ldw	fp,0(sp)
  800c6c:	dec00104 	addi	sp,sp,4
  800c70:	f800283a 	ret

00800c74 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  800c74:	defffd04 	addi	sp,sp,-12
  800c78:	df000215 	stw	fp,8(sp)
  800c7c:	df000204 	addi	fp,sp,8
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  800c80:	008020b4 	movhi	r2,130
  800c84:	10ad7d04 	addi	r2,r2,-18956
  800c88:	00ffff04 	movi	r3,-4
  800c8c:	10c4703a 	and	r2,r2,r3
  800c90:	e0bffe15 	stw	r2,-8(fp)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  800c94:	e0bffe17 	ldw	r2,-8(fp)
  800c98:	d0a02015 	stw	r2,-32640(gp)
	xStart.xBlockSize = ( size_t ) 0;
  800c9c:	d0202115 	stw	zero,-32636(gp)

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
  800ca0:	00bfff14 	movui	r2,65532
  800ca4:	d0a02315 	stw	r2,-32628(gp)
	xEnd.pxNextFreeBlock = NULL;
  800ca8:	d0202215 	stw	zero,-32632(gp)

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  800cac:	e0bffe17 	ldw	r2,-8(fp)
  800cb0:	e0bfff15 	stw	r2,-4(fp)
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
  800cb4:	e0bfff17 	ldw	r2,-4(fp)
  800cb8:	00ffff14 	movui	r3,65532
  800cbc:	10c00115 	stw	r3,4(r2)
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
  800cc0:	e0bfff17 	ldw	r2,-4(fp)
  800cc4:	d0e02204 	addi	r3,gp,-32632
  800cc8:	10c00015 	stw	r3,0(r2)
}
  800ccc:	0001883a 	nop
  800cd0:	e037883a 	mov	sp,fp
  800cd4:	df000017 	ldw	fp,0(sp)
  800cd8:	dec00104 	addi	sp,sp,4
  800cdc:	f800283a 	ret

00800ce0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  800ce0:	defffa04 	addi	sp,sp,-24
  800ce4:	dfc00515 	stw	ra,20(sp)
  800ce8:	df000415 	stw	fp,16(sp)
  800cec:	dc000315 	stw	r16,12(sp)
  800cf0:	df000404 	addi	fp,sp,16
  800cf4:	e13ffd15 	stw	r4,-12(fp)
  800cf8:	e17ffe15 	stw	r5,-8(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  800cfc:	e0bffd17 	ldw	r2,-12(fp)
  800d00:	e0bffc15 	stw	r2,-16(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  800d04:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  800d08:	e0bffc17 	ldw	r2,-16(fp)
  800d0c:	14000017 	ldw	r16,0(r2)
  800d10:	e0bffc17 	ldw	r2,-16(fp)
  800d14:	10c00f17 	ldw	r3,60(r2)
  800d18:	e0bffc17 	ldw	r2,-16(fp)
  800d1c:	10801017 	ldw	r2,64(r2)
  800d20:	100b883a 	mov	r5,r2
  800d24:	1809883a 	mov	r4,r3
  800d28:	080b2480 	call	80b248 <__mulsi3>
  800d2c:	8087883a 	add	r3,r16,r2
  800d30:	e0bffc17 	ldw	r2,-16(fp)
  800d34:	10c00115 	stw	r3,4(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  800d38:	e0bffc17 	ldw	r2,-16(fp)
  800d3c:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
  800d40:	e0bffc17 	ldw	r2,-16(fp)
  800d44:	10c00017 	ldw	r3,0(r2)
  800d48:	e0bffc17 	ldw	r2,-16(fp)
  800d4c:	10c00215 	stw	r3,8(r2)
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
  800d50:	e0bffc17 	ldw	r2,-16(fp)
  800d54:	14000017 	ldw	r16,0(r2)
  800d58:	e0bffc17 	ldw	r2,-16(fp)
  800d5c:	10800f17 	ldw	r2,60(r2)
  800d60:	10ffffc4 	addi	r3,r2,-1
  800d64:	e0bffc17 	ldw	r2,-16(fp)
  800d68:	10801017 	ldw	r2,64(r2)
  800d6c:	100b883a 	mov	r5,r2
  800d70:	1809883a 	mov	r4,r3
  800d74:	080b2480 	call	80b248 <__mulsi3>
  800d78:	8087883a 	add	r3,r16,r2
  800d7c:	e0bffc17 	ldw	r2,-16(fp)
  800d80:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
  800d84:	e0bffc17 	ldw	r2,-16(fp)
  800d88:	00ffffc4 	movi	r3,-1
  800d8c:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
  800d90:	e0bffc17 	ldw	r2,-16(fp)
  800d94:	00ffffc4 	movi	r3,-1
  800d98:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
  800d9c:	e0bffe17 	ldw	r2,-8(fp)
  800da0:	10000a1e 	bne	r2,zero,800dcc <xQueueGenericReset+0xec>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  800da4:	e0bffc17 	ldw	r2,-16(fp)
  800da8:	10800417 	ldw	r2,16(r2)
  800dac:	10000f26 	beq	r2,zero,800dec <xQueueGenericReset+0x10c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  800db0:	e0bffc17 	ldw	r2,-16(fp)
  800db4:	10800404 	addi	r2,r2,16
  800db8:	1009883a 	mov	r4,r2
  800dbc:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  800dc0:	10000a26 	beq	r2,zero,800dec <xQueueGenericReset+0x10c>
				{
					queueYIELD_IF_USING_PREEMPTION();
  800dc4:	003b683a 	trap	0
  800dc8:	00000806 	br	800dec <xQueueGenericReset+0x10c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  800dcc:	e0bffc17 	ldw	r2,-16(fp)
  800dd0:	10800404 	addi	r2,r2,16
  800dd4:	1009883a 	mov	r4,r2
  800dd8:	08002880 	call	800288 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  800ddc:	e0bffc17 	ldw	r2,-16(fp)
  800de0:	10800904 	addi	r2,r2,36
  800de4:	1009883a 	mov	r4,r2
  800de8:	08002880 	call	800288 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
  800dec:	08039000 	call	803900 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  800df0:	00800044 	movi	r2,1
}
  800df4:	e6ffff04 	addi	sp,fp,-4
  800df8:	dfc00217 	ldw	ra,8(sp)
  800dfc:	df000117 	ldw	fp,4(sp)
  800e00:	dc000017 	ldw	r16,0(sp)
  800e04:	dec00304 	addi	sp,sp,12
  800e08:	f800283a 	ret

00800e0c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  800e0c:	defff704 	addi	sp,sp,-36
  800e10:	dfc00815 	stw	ra,32(sp)
  800e14:	df000715 	stw	fp,28(sp)
  800e18:	df000704 	addi	fp,sp,28
  800e1c:	e13ffd15 	stw	r4,-12(fp)
  800e20:	e17ffe15 	stw	r5,-8(fp)
  800e24:	3005883a 	mov	r2,r6
  800e28:	e0bfff05 	stb	r2,-4(fp)
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
  800e2c:	e0bffe17 	ldw	r2,-8(fp)
  800e30:	1000021e 	bne	r2,zero,800e3c <xQueueGenericCreate+0x30>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
  800e34:	e03ffa15 	stw	zero,-24(fp)
  800e38:	00000406 	br	800e4c <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  800e3c:	e17ffe17 	ldw	r5,-8(fp)
  800e40:	e13ffd17 	ldw	r4,-12(fp)
  800e44:	080b2480 	call	80b248 <__mulsi3>
  800e48:	e0bffa15 	stw	r2,-24(fp)
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
  800e4c:	e0bffa17 	ldw	r2,-24(fp)
  800e50:	10801204 	addi	r2,r2,72
  800e54:	1009883a 	mov	r4,r2
  800e58:	08009980 	call	800998 <pvPortMalloc>
  800e5c:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
  800e60:	e0bffb17 	ldw	r2,-20(fp)
  800e64:	10000b26 	beq	r2,zero,800e94 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
  800e68:	e0bffb17 	ldw	r2,-20(fp)
  800e6c:	10801204 	addi	r2,r2,72
  800e70:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  800e74:	e0ffff03 	ldbu	r3,-4(fp)
  800e78:	e0bffb17 	ldw	r2,-20(fp)
  800e7c:	d8800015 	stw	r2,0(sp)
  800e80:	180f883a 	mov	r7,r3
  800e84:	e1bffc17 	ldw	r6,-16(fp)
  800e88:	e17ffe17 	ldw	r5,-8(fp)
  800e8c:	e13ffd17 	ldw	r4,-12(fp)
  800e90:	0800eac0 	call	800eac <prvInitialiseNewQueue>
		}

		return pxNewQueue;
  800e94:	e0bffb17 	ldw	r2,-20(fp)
	}
  800e98:	e037883a 	mov	sp,fp
  800e9c:	dfc00117 	ldw	ra,4(sp)
  800ea0:	df000017 	ldw	fp,0(sp)
  800ea4:	dec00204 	addi	sp,sp,8
  800ea8:	f800283a 	ret

00800eac <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  800eac:	defffa04 	addi	sp,sp,-24
  800eb0:	dfc00515 	stw	ra,20(sp)
  800eb4:	df000415 	stw	fp,16(sp)
  800eb8:	df000404 	addi	fp,sp,16
  800ebc:	e13ffc15 	stw	r4,-16(fp)
  800ec0:	e17ffd15 	stw	r5,-12(fp)
  800ec4:	e1bffe15 	stw	r6,-8(fp)
  800ec8:	3805883a 	mov	r2,r7
  800ecc:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  800ed0:	e0bffd17 	ldw	r2,-12(fp)
  800ed4:	1000041e 	bne	r2,zero,800ee8 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  800ed8:	e0800217 	ldw	r2,8(fp)
  800edc:	e0c00217 	ldw	r3,8(fp)
  800ee0:	10c00015 	stw	r3,0(r2)
  800ee4:	00000306 	br	800ef4 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  800ee8:	e0800217 	ldw	r2,8(fp)
  800eec:	e0fffe17 	ldw	r3,-8(fp)
  800ef0:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  800ef4:	e0800217 	ldw	r2,8(fp)
  800ef8:	e0fffc17 	ldw	r3,-16(fp)
  800efc:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
  800f00:	e0800217 	ldw	r2,8(fp)
  800f04:	e0fffd17 	ldw	r3,-12(fp)
  800f08:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  800f0c:	01400044 	movi	r5,1
  800f10:	e1000217 	ldw	r4,8(fp)
  800f14:	0800ce00 	call	800ce0 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  800f18:	0001883a 	nop
  800f1c:	e037883a 	mov	sp,fp
  800f20:	dfc00117 	ldw	ra,4(sp)
  800f24:	df000017 	ldw	fp,0(sp)
  800f28:	dec00204 	addi	sp,sp,8
  800f2c:	f800283a 	ret

00800f30 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
  800f30:	defffd04 	addi	sp,sp,-12
  800f34:	dfc00215 	stw	ra,8(sp)
  800f38:	df000115 	stw	fp,4(sp)
  800f3c:	df000104 	addi	fp,sp,4
  800f40:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
  800f44:	e0bfff17 	ldw	r2,-4(fp)
  800f48:	10000b26 	beq	r2,zero,800f78 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  800f4c:	e0bfff17 	ldw	r2,-4(fp)
  800f50:	10000115 	stw	zero,4(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  800f54:	e0bfff17 	ldw	r2,-4(fp)
  800f58:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
  800f5c:	e0bfff17 	ldw	r2,-4(fp)
  800f60:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  800f64:	000f883a 	mov	r7,zero
  800f68:	000d883a 	mov	r6,zero
  800f6c:	000b883a 	mov	r5,zero
  800f70:	e13fff17 	ldw	r4,-4(fp)
  800f74:	08011780 	call	801178 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
  800f78:	0001883a 	nop
  800f7c:	e037883a 	mov	sp,fp
  800f80:	dfc00117 	ldw	ra,4(sp)
  800f84:	df000017 	ldw	fp,0(sp)
  800f88:	dec00204 	addi	sp,sp,8
  800f8c:	f800283a 	ret

00800f90 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
  800f90:	defffa04 	addi	sp,sp,-24
  800f94:	dfc00515 	stw	ra,20(sp)
  800f98:	df000415 	stw	fp,16(sp)
  800f9c:	df000404 	addi	fp,sp,16
  800fa0:	2005883a 	mov	r2,r4
  800fa4:	e0bfff05 	stb	r2,-4(fp)
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
  800fa8:	00800044 	movi	r2,1
  800fac:	e0bffc15 	stw	r2,-16(fp)
  800fb0:	e03ffd15 	stw	zero,-12(fp)

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
  800fb4:	e0bfff03 	ldbu	r2,-4(fp)
  800fb8:	100d883a 	mov	r6,r2
  800fbc:	e17ffd17 	ldw	r5,-12(fp)
  800fc0:	e13ffc17 	ldw	r4,-16(fp)
  800fc4:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  800fc8:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( pxNewQueue );
  800fcc:	e13ffe17 	ldw	r4,-8(fp)
  800fd0:	0800f300 	call	800f30 <prvInitialiseMutex>

		return pxNewQueue;
  800fd4:	e0bffe17 	ldw	r2,-8(fp)
	}
  800fd8:	e037883a 	mov	sp,fp
  800fdc:	dfc00117 	ldw	ra,4(sp)
  800fe0:	df000017 	ldw	fp,0(sp)
  800fe4:	dec00204 	addi	sp,sp,8
  800fe8:	f800283a 	ret

00800fec <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
  800fec:	defffa04 	addi	sp,sp,-24
  800ff0:	dfc00515 	stw	ra,20(sp)
  800ff4:	df000415 	stw	fp,16(sp)
  800ff8:	dc000315 	stw	r16,12(sp)
  800ffc:	df000404 	addi	fp,sp,16
  801000:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  801004:	e0bffe17 	ldw	r2,-8(fp)
  801008:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
  80100c:	e0bffd17 	ldw	r2,-12(fp)
  801010:	14000117 	ldw	r16,4(r2)
  801014:	08036340 	call	803634 <xTaskGetCurrentTaskHandle>
  801018:	8080101e 	bne	r16,r2,80105c <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
  80101c:	e0bffd17 	ldw	r2,-12(fp)
  801020:	10800317 	ldw	r2,12(r2)
  801024:	10ffffc4 	addi	r3,r2,-1
  801028:	e0bffd17 	ldw	r2,-12(fp)
  80102c:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
  801030:	e0bffd17 	ldw	r2,-12(fp)
  801034:	10800317 	ldw	r2,12(r2)
  801038:	1000051e 	bne	r2,zero,801050 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
  80103c:	000f883a 	mov	r7,zero
  801040:	000d883a 	mov	r6,zero
  801044:	000b883a 	mov	r5,zero
  801048:	e13ffd17 	ldw	r4,-12(fp)
  80104c:	08011780 	call	801178 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
  801050:	00800044 	movi	r2,1
  801054:	e0bffc15 	stw	r2,-16(fp)
  801058:	00000106 	br	801060 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
  80105c:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
  801060:	e0bffc17 	ldw	r2,-16(fp)
	}
  801064:	e6ffff04 	addi	sp,fp,-4
  801068:	dfc00217 	ldw	ra,8(sp)
  80106c:	df000117 	ldw	fp,4(sp)
  801070:	dc000017 	ldw	r16,0(sp)
  801074:	dec00304 	addi	sp,sp,12
  801078:	f800283a 	ret

0080107c <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
  80107c:	defff904 	addi	sp,sp,-28
  801080:	dfc00615 	stw	ra,24(sp)
  801084:	df000515 	stw	fp,20(sp)
  801088:	dc000415 	stw	r16,16(sp)
  80108c:	df000504 	addi	fp,sp,20
  801090:	e13ffd15 	stw	r4,-12(fp)
  801094:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  801098:	e0bffd17 	ldw	r2,-12(fp)
  80109c:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
  8010a0:	e0bffc17 	ldw	r2,-16(fp)
  8010a4:	14000117 	ldw	r16,4(r2)
  8010a8:	08036340 	call	803634 <xTaskGetCurrentTaskHandle>
  8010ac:	8080081e 	bne	r16,r2,8010d0 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.uxRecursiveCallCount )++;
  8010b0:	e0bffc17 	ldw	r2,-16(fp)
  8010b4:	10800317 	ldw	r2,12(r2)
  8010b8:	10c00044 	addi	r3,r2,1
  8010bc:	e0bffc17 	ldw	r2,-16(fp)
  8010c0:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
  8010c4:	00800044 	movi	r2,1
  8010c8:	e0bffb15 	stw	r2,-20(fp)
  8010cc:	00000d06 	br	801104 <xQueueTakeMutexRecursive+0x88>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
  8010d0:	000f883a 	mov	r7,zero
  8010d4:	e1bffe17 	ldw	r6,-8(fp)
  8010d8:	000b883a 	mov	r5,zero
  8010dc:	e13ffc17 	ldw	r4,-16(fp)
  8010e0:	08014f00 	call	8014f0 <xQueueGenericReceive>
  8010e4:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
  8010e8:	e0bffb17 	ldw	r2,-20(fp)
  8010ec:	10000526 	beq	r2,zero,801104 <xQueueTakeMutexRecursive+0x88>
			{
				( pxMutex->u.uxRecursiveCallCount )++;
  8010f0:	e0bffc17 	ldw	r2,-16(fp)
  8010f4:	10800317 	ldw	r2,12(r2)
  8010f8:	10c00044 	addi	r3,r2,1
  8010fc:	e0bffc17 	ldw	r2,-16(fp)
  801100:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
  801104:	e0bffb17 	ldw	r2,-20(fp)
	}
  801108:	e6ffff04 	addi	sp,fp,-4
  80110c:	dfc00217 	ldw	ra,8(sp)
  801110:	df000117 	ldw	fp,4(sp)
  801114:	dc000017 	ldw	r16,0(sp)
  801118:	dec00304 	addi	sp,sp,12
  80111c:	f800283a 	ret

00801120 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
  801120:	defffb04 	addi	sp,sp,-20
  801124:	dfc00415 	stw	ra,16(sp)
  801128:	df000315 	stw	fp,12(sp)
  80112c:	df000304 	addi	fp,sp,12
  801130:	e13ffe15 	stw	r4,-8(fp)
  801134:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  801138:	01800084 	movi	r6,2
  80113c:	000b883a 	mov	r5,zero
  801140:	e13ffe17 	ldw	r4,-8(fp)
  801144:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  801148:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
  80114c:	e0bffd17 	ldw	r2,-12(fp)
  801150:	10000326 	beq	r2,zero,801160 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
  801154:	e0bffd17 	ldw	r2,-12(fp)
  801158:	e0ffff17 	ldw	r3,-4(fp)
  80115c:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
  801160:	e0bffd17 	ldw	r2,-12(fp)
	}
  801164:	e037883a 	mov	sp,fp
  801168:	dfc00117 	ldw	ra,4(sp)
  80116c:	df000017 	ldw	fp,0(sp)
  801170:	dec00204 	addi	sp,sp,8
  801174:	f800283a 	ret

00801178 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  801178:	defff504 	addi	sp,sp,-44
  80117c:	dfc00a15 	stw	ra,40(sp)
  801180:	df000915 	stw	fp,36(sp)
  801184:	df000904 	addi	fp,sp,36
  801188:	e13ffc15 	stw	r4,-16(fp)
  80118c:	e17ffd15 	stw	r5,-12(fp)
  801190:	e1bffe15 	stw	r6,-8(fp)
  801194:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  801198:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  80119c:	e0bffc17 	ldw	r2,-16(fp)
  8011a0:	e0bff815 	stw	r2,-32(fp)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  8011a4:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  8011a8:	e0bff817 	ldw	r2,-32(fp)
  8011ac:	10c00e17 	ldw	r3,56(r2)
  8011b0:	e0bff817 	ldw	r2,-32(fp)
  8011b4:	10800f17 	ldw	r2,60(r2)
  8011b8:	18800336 	bltu	r3,r2,8011c8 <xQueueGenericSend+0x50>
  8011bc:	e0bfff17 	ldw	r2,-4(fp)
  8011c0:	10800098 	cmpnei	r2,r2,2
  8011c4:	1000151e 	bne	r2,zero,80121c <xQueueGenericSend+0xa4>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  8011c8:	e1bfff17 	ldw	r6,-4(fp)
  8011cc:	e17ffd17 	ldw	r5,-12(fp)
  8011d0:	e13ff817 	ldw	r4,-32(fp)
  8011d4:	08019840 	call	801984 <prvCopyDataToQueue>
  8011d8:	e0bff915 	stw	r2,-28(fp)
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8011dc:	e0bff817 	ldw	r2,-32(fp)
  8011e0:	10800917 	ldw	r2,36(r2)
  8011e4:	10000726 	beq	r2,zero,801204 <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8011e8:	e0bff817 	ldw	r2,-32(fp)
  8011ec:	10800904 	addi	r2,r2,36
  8011f0:	1009883a 	mov	r4,r2
  8011f4:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  8011f8:	10000526 	beq	r2,zero,801210 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
  8011fc:	003b683a 	trap	0
  801200:	00000306 	br	801210 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
  801204:	e0bff917 	ldw	r2,-28(fp)
  801208:	10000126 	beq	r2,zero,801210 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
  80120c:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  801210:	08039000 	call	803900 <vTaskExitCritical>
				return pdPASS;
  801214:	00800044 	movi	r2,1
  801218:	00003f06 	br	801318 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  80121c:	e0bffe17 	ldw	r2,-8(fp)
  801220:	1000031e 	bne	r2,zero,801230 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  801224:	08039000 	call	803900 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  801228:	0005883a 	mov	r2,zero
  80122c:	00003a06 	br	801318 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
  801230:	e0bff717 	ldw	r2,-36(fp)
  801234:	1000051e 	bne	r2,zero,80124c <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  801238:	e0bffa04 	addi	r2,fp,-24
  80123c:	1009883a 	mov	r4,r2
  801240:	08032000 	call	803200 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  801244:	00800044 	movi	r2,1
  801248:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  80124c:	08039000 	call	803900 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801250:	0802a4c0 	call	802a4c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801254:	08038ac0 	call	8038ac <vTaskEnterCritical>
  801258:	e0bff817 	ldw	r2,-32(fp)
  80125c:	10801103 	ldbu	r2,68(r2)
  801260:	10803fcc 	andi	r2,r2,255
  801264:	1080201c 	xori	r2,r2,128
  801268:	10bfe004 	addi	r2,r2,-128
  80126c:	10bfffd8 	cmpnei	r2,r2,-1
  801270:	1000021e 	bne	r2,zero,80127c <xQueueGenericSend+0x104>
  801274:	e0bff817 	ldw	r2,-32(fp)
  801278:	10001105 	stb	zero,68(r2)
  80127c:	e0bff817 	ldw	r2,-32(fp)
  801280:	10801143 	ldbu	r2,69(r2)
  801284:	10803fcc 	andi	r2,r2,255
  801288:	1080201c 	xori	r2,r2,128
  80128c:	10bfe004 	addi	r2,r2,-128
  801290:	10bfffd8 	cmpnei	r2,r2,-1
  801294:	1000021e 	bne	r2,zero,8012a0 <xQueueGenericSend+0x128>
  801298:	e0bff817 	ldw	r2,-32(fp)
  80129c:	10001145 	stb	zero,69(r2)
  8012a0:	08039000 	call	803900 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  8012a4:	e0fffe04 	addi	r3,fp,-8
  8012a8:	e0bffa04 	addi	r2,fp,-24
  8012ac:	180b883a 	mov	r5,r3
  8012b0:	1009883a 	mov	r4,r2
  8012b4:	080323c0 	call	80323c <xTaskCheckForTimeOut>
  8012b8:	1000131e 	bne	r2,zero,801308 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  8012bc:	e13ff817 	ldw	r4,-32(fp)
  8012c0:	0801d300 	call	801d30 <prvIsQueueFull>
  8012c4:	10000c26 	beq	r2,zero,8012f8 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  8012c8:	e0bff817 	ldw	r2,-32(fp)
  8012cc:	10800404 	addi	r2,r2,16
  8012d0:	e0fffe17 	ldw	r3,-8(fp)
  8012d4:	180b883a 	mov	r5,r3
  8012d8:	1009883a 	mov	r4,r2
  8012dc:	0802f680 	call	802f68 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  8012e0:	e13ff817 	ldw	r4,-32(fp)
  8012e4:	0801bac0 	call	801bac <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  8012e8:	0802a780 	call	802a78 <xTaskResumeAll>
  8012ec:	103fad1e 	bne	r2,zero,8011a4 <__alt_data_end+0xfff011a4>
				{
					portYIELD_WITHIN_API();
  8012f0:	003b683a 	trap	0
  8012f4:	003fab06 	br	8011a4 <__alt_data_end+0xfff011a4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  8012f8:	e13ff817 	ldw	r4,-32(fp)
  8012fc:	0801bac0 	call	801bac <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801300:	0802a780 	call	802a78 <xTaskResumeAll>
  801304:	003fa706 	br	8011a4 <__alt_data_end+0xfff011a4>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  801308:	e13ff817 	ldw	r4,-32(fp)
  80130c:	0801bac0 	call	801bac <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801310:	0802a780 	call	802a78 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  801314:	0005883a 	mov	r2,zero
		}
	}
}
  801318:	e037883a 	mov	sp,fp
  80131c:	dfc00117 	ldw	ra,4(sp)
  801320:	df000017 	ldw	fp,0(sp)
  801324:	dec00204 	addi	sp,sp,8
  801328:	f800283a 	ret

0080132c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  80132c:	defff604 	addi	sp,sp,-40
  801330:	dfc00915 	stw	ra,36(sp)
  801334:	df000815 	stw	fp,32(sp)
  801338:	df000804 	addi	fp,sp,32
  80133c:	e13ffc15 	stw	r4,-16(fp)
  801340:	e17ffd15 	stw	r5,-12(fp)
  801344:	e1bffe15 	stw	r6,-8(fp)
  801348:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  80134c:	e0bffc17 	ldw	r2,-16(fp)
  801350:	e0bff915 	stw	r2,-28(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801354:	e03ffa15 	stw	zero,-24(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  801358:	e0bff917 	ldw	r2,-28(fp)
  80135c:	10c00e17 	ldw	r3,56(r2)
  801360:	e0bff917 	ldw	r2,-28(fp)
  801364:	10800f17 	ldw	r2,60(r2)
  801368:	18800336 	bltu	r3,r2,801378 <xQueueGenericSendFromISR+0x4c>
  80136c:	e0bfff17 	ldw	r2,-4(fp)
  801370:	10800098 	cmpnei	r2,r2,2
  801374:	1000201e 	bne	r2,zero,8013f8 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  801378:	e0bff917 	ldw	r2,-28(fp)
  80137c:	10801143 	ldbu	r2,69(r2)
  801380:	e0bffb05 	stb	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  801384:	e1bfff17 	ldw	r6,-4(fp)
  801388:	e17ffd17 	ldw	r5,-12(fp)
  80138c:	e13ff917 	ldw	r4,-28(fp)
  801390:	08019840 	call	801984 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  801394:	e0bffb07 	ldb	r2,-20(fp)
  801398:	10bfffd8 	cmpnei	r2,r2,-1
  80139c:	10000e1e 	bne	r2,zero,8013d8 <xQueueGenericSendFromISR+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8013a0:	e0bff917 	ldw	r2,-28(fp)
  8013a4:	10800917 	ldw	r2,36(r2)
  8013a8:	10001026 	beq	r2,zero,8013ec <xQueueGenericSendFromISR+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8013ac:	e0bff917 	ldw	r2,-28(fp)
  8013b0:	10800904 	addi	r2,r2,36
  8013b4:	1009883a 	mov	r4,r2
  8013b8:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  8013bc:	10000b26 	beq	r2,zero,8013ec <xQueueGenericSendFromISR+0xc0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  8013c0:	e0bffe17 	ldw	r2,-8(fp)
  8013c4:	10000926 	beq	r2,zero,8013ec <xQueueGenericSendFromISR+0xc0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  8013c8:	e0bffe17 	ldw	r2,-8(fp)
  8013cc:	00c00044 	movi	r3,1
  8013d0:	10c00015 	stw	r3,0(r2)
  8013d4:	00000506 	br	8013ec <xQueueGenericSendFromISR+0xc0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  8013d8:	e0bffb03 	ldbu	r2,-20(fp)
  8013dc:	10800044 	addi	r2,r2,1
  8013e0:	1007883a 	mov	r3,r2
  8013e4:	e0bff917 	ldw	r2,-28(fp)
  8013e8:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  8013ec:	00800044 	movi	r2,1
  8013f0:	e0bff815 	stw	r2,-32(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
  8013f4:	00000106 	br	8013fc <xQueueGenericSendFromISR+0xd0>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  8013f8:	e03ff815 	stw	zero,-32(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  8013fc:	e0bff817 	ldw	r2,-32(fp)
}
  801400:	e037883a 	mov	sp,fp
  801404:	dfc00117 	ldw	ra,4(sp)
  801408:	df000017 	ldw	fp,0(sp)
  80140c:	dec00204 	addi	sp,sp,8
  801410:	f800283a 	ret

00801414 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801414:	defff704 	addi	sp,sp,-36
  801418:	dfc00815 	stw	ra,32(sp)
  80141c:	df000715 	stw	fp,28(sp)
  801420:	df000704 	addi	fp,sp,28
  801424:	e13ffe15 	stw	r4,-8(fp)
  801428:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  80142c:	e0bffe17 	ldw	r2,-8(fp)
  801430:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801434:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801438:	e0bffa17 	ldw	r2,-24(fp)
  80143c:	10800e17 	ldw	r2,56(r2)
  801440:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
  801444:	e0bffa17 	ldw	r2,-24(fp)
  801448:	10800f17 	ldw	r2,60(r2)
  80144c:	e0fffc17 	ldw	r3,-16(fp)
  801450:	1880202e 	bgeu	r3,r2,8014d4 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  801454:	e0bffa17 	ldw	r2,-24(fp)
  801458:	10801143 	ldbu	r2,69(r2)
  80145c:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  801460:	e0bffc17 	ldw	r2,-16(fp)
  801464:	10c00044 	addi	r3,r2,1
  801468:	e0bffa17 	ldw	r2,-24(fp)
  80146c:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  801470:	e0bffd07 	ldb	r2,-12(fp)
  801474:	10bfffd8 	cmpnei	r2,r2,-1
  801478:	10000e1e 	bne	r2,zero,8014b4 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  80147c:	e0bffa17 	ldw	r2,-24(fp)
  801480:	10800917 	ldw	r2,36(r2)
  801484:	10001026 	beq	r2,zero,8014c8 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801488:	e0bffa17 	ldw	r2,-24(fp)
  80148c:	10800904 	addi	r2,r2,36
  801490:	1009883a 	mov	r4,r2
  801494:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  801498:	10000b26 	beq	r2,zero,8014c8 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  80149c:	e0bfff17 	ldw	r2,-4(fp)
  8014a0:	10000926 	beq	r2,zero,8014c8 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  8014a4:	e0bfff17 	ldw	r2,-4(fp)
  8014a8:	00c00044 	movi	r3,1
  8014ac:	10c00015 	stw	r3,0(r2)
  8014b0:	00000506 	br	8014c8 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  8014b4:	e0bffd03 	ldbu	r2,-12(fp)
  8014b8:	10800044 	addi	r2,r2,1
  8014bc:	1007883a 	mov	r3,r2
  8014c0:	e0bffa17 	ldw	r2,-24(fp)
  8014c4:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  8014c8:	00800044 	movi	r2,1
  8014cc:	e0bff915 	stw	r2,-28(fp)
  8014d0:	00000106 	br	8014d8 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  8014d4:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  8014d8:	e0bff917 	ldw	r2,-28(fp)
}
  8014dc:	e037883a 	mov	sp,fp
  8014e0:	dfc00117 	ldw	ra,4(sp)
  8014e4:	df000017 	ldw	fp,0(sp)
  8014e8:	dec00204 	addi	sp,sp,8
  8014ec:	f800283a 	ret

008014f0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
  8014f0:	defff404 	addi	sp,sp,-48
  8014f4:	dfc00b15 	stw	ra,44(sp)
  8014f8:	df000a15 	stw	fp,40(sp)
  8014fc:	df000a04 	addi	fp,sp,40
  801500:	e13ffc15 	stw	r4,-16(fp)
  801504:	e17ffd15 	stw	r5,-12(fp)
  801508:	e1bffe15 	stw	r6,-8(fp)
  80150c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801510:	e03ff615 	stw	zero,-40(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  801514:	e0bffc17 	ldw	r2,-16(fp)
  801518:	e0bff715 	stw	r2,-36(fp)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  80151c:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801520:	e0bff717 	ldw	r2,-36(fp)
  801524:	10800e17 	ldw	r2,56(r2)
  801528:	e0bff815 	stw	r2,-32(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  80152c:	e0bff817 	ldw	r2,-32(fp)
  801530:	10002c26 	beq	r2,zero,8015e4 <xQueueGenericReceive+0xf4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  801534:	e0bff717 	ldw	r2,-36(fp)
  801538:	10800317 	ldw	r2,12(r2)
  80153c:	e0bff915 	stw	r2,-28(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  801540:	e17ffd17 	ldw	r5,-12(fp)
  801544:	e13ff717 	ldw	r4,-36(fp)
  801548:	0801b100 	call	801b10 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
  80154c:	e0bfff17 	ldw	r2,-4(fp)
  801550:	1000151e 	bne	r2,zero,8015a8 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  801554:	e0bff817 	ldw	r2,-32(fp)
  801558:	10ffffc4 	addi	r3,r2,-1
  80155c:	e0bff717 	ldw	r2,-36(fp)
  801560:	10c00e15 	stw	r3,56(r2)

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801564:	e0bff717 	ldw	r2,-36(fp)
  801568:	10800017 	ldw	r2,0(r2)
  80156c:	1000041e 	bne	r2,zero,801580 <xQueueGenericReceive+0x90>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
  801570:	08039a40 	call	8039a4 <pvTaskIncrementMutexHeldCount>
  801574:	1007883a 	mov	r3,r2
  801578:	e0bff717 	ldw	r2,-36(fp)
  80157c:	10c00115 	stw	r3,4(r2)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801580:	e0bff717 	ldw	r2,-36(fp)
  801584:	10800417 	ldw	r2,16(r2)
  801588:	10001326 	beq	r2,zero,8015d8 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  80158c:	e0bff717 	ldw	r2,-36(fp)
  801590:	10800404 	addi	r2,r2,16
  801594:	1009883a 	mov	r4,r2
  801598:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  80159c:	10000e26 	beq	r2,zero,8015d8 <xQueueGenericReceive+0xe8>
						{
							queueYIELD_IF_USING_PREEMPTION();
  8015a0:	003b683a 	trap	0
  8015a4:	00000c06 	br	8015d8 <xQueueGenericReceive+0xe8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  8015a8:	e0bff717 	ldw	r2,-36(fp)
  8015ac:	e0fff917 	ldw	r3,-28(fp)
  8015b0:	10c00315 	stw	r3,12(r2)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8015b4:	e0bff717 	ldw	r2,-36(fp)
  8015b8:	10800917 	ldw	r2,36(r2)
  8015bc:	10000626 	beq	r2,zero,8015d8 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8015c0:	e0bff717 	ldw	r2,-36(fp)
  8015c4:	10800904 	addi	r2,r2,36
  8015c8:	1009883a 	mov	r4,r2
  8015cc:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  8015d0:	10000126 	beq	r2,zero,8015d8 <xQueueGenericReceive+0xe8>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
  8015d4:	003b683a 	trap	0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
  8015d8:	08039000 	call	803900 <vTaskExitCritical>
				return pdPASS;
  8015dc:	00800044 	movi	r2,1
  8015e0:	00004b06 	br	801710 <xQueueGenericReceive+0x220>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  8015e4:	e0bffe17 	ldw	r2,-8(fp)
  8015e8:	1000031e 	bne	r2,zero,8015f8 <xQueueGenericReceive+0x108>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  8015ec:	08039000 	call	803900 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  8015f0:	0005883a 	mov	r2,zero
  8015f4:	00004606 	br	801710 <xQueueGenericReceive+0x220>
				}
				else if( xEntryTimeSet == pdFALSE )
  8015f8:	e0bff617 	ldw	r2,-40(fp)
  8015fc:	1000051e 	bne	r2,zero,801614 <xQueueGenericReceive+0x124>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  801600:	e0bffa04 	addi	r2,fp,-24
  801604:	1009883a 	mov	r4,r2
  801608:	08032000 	call	803200 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  80160c:	00800044 	movi	r2,1
  801610:	e0bff615 	stw	r2,-40(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801614:	08039000 	call	803900 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801618:	0802a4c0 	call	802a4c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  80161c:	08038ac0 	call	8038ac <vTaskEnterCritical>
  801620:	e0bff717 	ldw	r2,-36(fp)
  801624:	10801103 	ldbu	r2,68(r2)
  801628:	10803fcc 	andi	r2,r2,255
  80162c:	1080201c 	xori	r2,r2,128
  801630:	10bfe004 	addi	r2,r2,-128
  801634:	10bfffd8 	cmpnei	r2,r2,-1
  801638:	1000021e 	bne	r2,zero,801644 <xQueueGenericReceive+0x154>
  80163c:	e0bff717 	ldw	r2,-36(fp)
  801640:	10001105 	stb	zero,68(r2)
  801644:	e0bff717 	ldw	r2,-36(fp)
  801648:	10801143 	ldbu	r2,69(r2)
  80164c:	10803fcc 	andi	r2,r2,255
  801650:	1080201c 	xori	r2,r2,128
  801654:	10bfe004 	addi	r2,r2,-128
  801658:	10bfffd8 	cmpnei	r2,r2,-1
  80165c:	1000021e 	bne	r2,zero,801668 <xQueueGenericReceive+0x178>
  801660:	e0bff717 	ldw	r2,-36(fp)
  801664:	10001145 	stb	zero,69(r2)
  801668:	08039000 	call	803900 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  80166c:	e0fffe04 	addi	r3,fp,-8
  801670:	e0bffa04 	addi	r2,fp,-24
  801674:	180b883a 	mov	r5,r3
  801678:	1009883a 	mov	r4,r2
  80167c:	080323c0 	call	80323c <xTaskCheckForTimeOut>
  801680:	10001c1e 	bne	r2,zero,8016f4 <xQueueGenericReceive+0x204>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801684:	e13ff717 	ldw	r4,-36(fp)
  801688:	0801ca00 	call	801ca0 <prvIsQueueEmpty>
  80168c:	10001526 	beq	r2,zero,8016e4 <xQueueGenericReceive+0x1f4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801690:	e0bff717 	ldw	r2,-36(fp)
  801694:	10800017 	ldw	r2,0(r2)
  801698:	1000061e 	bne	r2,zero,8016b4 <xQueueGenericReceive+0x1c4>
					{
						taskENTER_CRITICAL();
  80169c:	08038ac0 	call	8038ac <vTaskEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  8016a0:	e0bff717 	ldw	r2,-36(fp)
  8016a4:	10800117 	ldw	r2,4(r2)
  8016a8:	1009883a 	mov	r4,r2
  8016ac:	080365c0 	call	80365c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
  8016b0:	08039000 	call	803900 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  8016b4:	e0bff717 	ldw	r2,-36(fp)
  8016b8:	10800904 	addi	r2,r2,36
  8016bc:	e0fffe17 	ldw	r3,-8(fp)
  8016c0:	180b883a 	mov	r5,r3
  8016c4:	1009883a 	mov	r4,r2
  8016c8:	0802f680 	call	802f68 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  8016cc:	e13ff717 	ldw	r4,-36(fp)
  8016d0:	0801bac0 	call	801bac <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  8016d4:	0802a780 	call	802a78 <xTaskResumeAll>
  8016d8:	103f901e 	bne	r2,zero,80151c <__alt_data_end+0xfff0151c>
				{
					portYIELD_WITHIN_API();
  8016dc:	003b683a 	trap	0
  8016e0:	003f8e06 	br	80151c <__alt_data_end+0xfff0151c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  8016e4:	e13ff717 	ldw	r4,-36(fp)
  8016e8:	0801bac0 	call	801bac <prvUnlockQueue>
				( void ) xTaskResumeAll();
  8016ec:	0802a780 	call	802a78 <xTaskResumeAll>
  8016f0:	003f8a06 	br	80151c <__alt_data_end+0xfff0151c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  8016f4:	e13ff717 	ldw	r4,-36(fp)
  8016f8:	0801bac0 	call	801bac <prvUnlockQueue>
			( void ) xTaskResumeAll();
  8016fc:	0802a780 	call	802a78 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801700:	e13ff717 	ldw	r4,-36(fp)
  801704:	0801ca00 	call	801ca0 <prvIsQueueEmpty>
  801708:	103f8426 	beq	r2,zero,80151c <__alt_data_end+0xfff0151c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  80170c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
  801710:	e037883a 	mov	sp,fp
  801714:	dfc00117 	ldw	ra,4(sp)
  801718:	df000017 	ldw	fp,0(sp)
  80171c:	dec00204 	addi	sp,sp,8
  801720:	f800283a 	ret

00801724 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801724:	defff604 	addi	sp,sp,-40
  801728:	dfc00915 	stw	ra,36(sp)
  80172c:	df000815 	stw	fp,32(sp)
  801730:	df000804 	addi	fp,sp,32
  801734:	e13ffd15 	stw	r4,-12(fp)
  801738:	e17ffe15 	stw	r5,-8(fp)
  80173c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  801740:	e0bffd17 	ldw	r2,-12(fp)
  801744:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801748:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  80174c:	e0bff917 	ldw	r2,-28(fp)
  801750:	10800e17 	ldw	r2,56(r2)
  801754:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801758:	e0bffb17 	ldw	r2,-20(fp)
  80175c:	10002326 	beq	r2,zero,8017ec <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
  801760:	e0bff917 	ldw	r2,-28(fp)
  801764:	10801103 	ldbu	r2,68(r2)
  801768:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  80176c:	e17ffe17 	ldw	r5,-8(fp)
  801770:	e13ff917 	ldw	r4,-28(fp)
  801774:	0801b100 	call	801b10 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
  801778:	e0bffb17 	ldw	r2,-20(fp)
  80177c:	10ffffc4 	addi	r3,r2,-1
  801780:	e0bff917 	ldw	r2,-28(fp)
  801784:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
  801788:	e0bffc07 	ldb	r2,-16(fp)
  80178c:	10bfffd8 	cmpnei	r2,r2,-1
  801790:	10000e1e 	bne	r2,zero,8017cc <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801794:	e0bff917 	ldw	r2,-28(fp)
  801798:	10800417 	ldw	r2,16(r2)
  80179c:	10001026 	beq	r2,zero,8017e0 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  8017a0:	e0bff917 	ldw	r2,-28(fp)
  8017a4:	10800404 	addi	r2,r2,16
  8017a8:	1009883a 	mov	r4,r2
  8017ac:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  8017b0:	10000b26 	beq	r2,zero,8017e0 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  8017b4:	e0bfff17 	ldw	r2,-4(fp)
  8017b8:	10000926 	beq	r2,zero,8017e0 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  8017bc:	e0bfff17 	ldw	r2,-4(fp)
  8017c0:	00c00044 	movi	r3,1
  8017c4:	10c00015 	stw	r3,0(r2)
  8017c8:	00000506 	br	8017e0 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
  8017cc:	e0bffc03 	ldbu	r2,-16(fp)
  8017d0:	10800044 	addi	r2,r2,1
  8017d4:	1007883a 	mov	r3,r2
  8017d8:	e0bff917 	ldw	r2,-28(fp)
  8017dc:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
  8017e0:	00800044 	movi	r2,1
  8017e4:	e0bff815 	stw	r2,-32(fp)
  8017e8:	00000106 	br	8017f0 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
  8017ec:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  8017f0:	e0bff817 	ldw	r2,-32(fp)
}
  8017f4:	e037883a 	mov	sp,fp
  8017f8:	dfc00117 	ldw	ra,4(sp)
  8017fc:	df000017 	ldw	fp,0(sp)
  801800:	dec00204 	addi	sp,sp,8
  801804:	f800283a 	ret

00801808 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
  801808:	defff804 	addi	sp,sp,-32
  80180c:	dfc00715 	stw	ra,28(sp)
  801810:	df000615 	stw	fp,24(sp)
  801814:	df000604 	addi	fp,sp,24
  801818:	e13ffe15 	stw	r4,-8(fp)
  80181c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  801820:	e0bffe17 	ldw	r2,-8(fp)
  801824:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801828:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
  80182c:	e0bffb17 	ldw	r2,-20(fp)
  801830:	10800e17 	ldw	r2,56(r2)
  801834:	10000c26 	beq	r2,zero,801868 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
  801838:	e0bffb17 	ldw	r2,-20(fp)
  80183c:	10800317 	ldw	r2,12(r2)
  801840:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
  801844:	e17fff17 	ldw	r5,-4(fp)
  801848:	e13ffb17 	ldw	r4,-20(fp)
  80184c:	0801b100 	call	801b10 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
  801850:	e0bffb17 	ldw	r2,-20(fp)
  801854:	e0fffd17 	ldw	r3,-12(fp)
  801858:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
  80185c:	00800044 	movi	r2,1
  801860:	e0bffa15 	stw	r2,-24(fp)
  801864:	00000106 	br	80186c <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
  801868:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  80186c:	e0bffa17 	ldw	r2,-24(fp)
}
  801870:	e037883a 	mov	sp,fp
  801874:	dfc00117 	ldw	ra,4(sp)
  801878:	df000017 	ldw	fp,0(sp)
  80187c:	dec00204 	addi	sp,sp,8
  801880:	f800283a 	ret

00801884 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
  801884:	defffc04 	addi	sp,sp,-16
  801888:	dfc00315 	stw	ra,12(sp)
  80188c:	df000215 	stw	fp,8(sp)
  801890:	df000204 	addi	fp,sp,8
  801894:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
  801898:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
  80189c:	e0bfff17 	ldw	r2,-4(fp)
  8018a0:	10800e17 	ldw	r2,56(r2)
  8018a4:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  8018a8:	08039000 	call	803900 <vTaskExitCritical>

	return uxReturn;
  8018ac:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  8018b0:	e037883a 	mov	sp,fp
  8018b4:	dfc00117 	ldw	ra,4(sp)
  8018b8:	df000017 	ldw	fp,0(sp)
  8018bc:	dec00204 	addi	sp,sp,8
  8018c0:	f800283a 	ret

008018c4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
  8018c4:	defffb04 	addi	sp,sp,-20
  8018c8:	dfc00415 	stw	ra,16(sp)
  8018cc:	df000315 	stw	fp,12(sp)
  8018d0:	df000304 	addi	fp,sp,12
  8018d4:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
  8018d8:	e0bfff17 	ldw	r2,-4(fp)
  8018dc:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  8018e0:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
  8018e4:	e0bffd17 	ldw	r2,-12(fp)
  8018e8:	10c00f17 	ldw	r3,60(r2)
  8018ec:	e0bffd17 	ldw	r2,-12(fp)
  8018f0:	10800e17 	ldw	r2,56(r2)
  8018f4:	1885c83a 	sub	r2,r3,r2
  8018f8:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  8018fc:	08039000 	call	803900 <vTaskExitCritical>

	return uxReturn;
  801900:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  801904:	e037883a 	mov	sp,fp
  801908:	dfc00117 	ldw	ra,4(sp)
  80190c:	df000017 	ldw	fp,0(sp)
  801910:	dec00204 	addi	sp,sp,8
  801914:	f800283a 	ret

00801918 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
  801918:	defffd04 	addi	sp,sp,-12
  80191c:	df000215 	stw	fp,8(sp)
  801920:	df000204 	addi	fp,sp,8
  801924:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
  801928:	e0bfff17 	ldw	r2,-4(fp)
  80192c:	10800e17 	ldw	r2,56(r2)
  801930:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
  801934:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  801938:	e037883a 	mov	sp,fp
  80193c:	df000017 	ldw	fp,0(sp)
  801940:	dec00104 	addi	sp,sp,4
  801944:	f800283a 	ret

00801948 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
  801948:	defffc04 	addi	sp,sp,-16
  80194c:	dfc00315 	stw	ra,12(sp)
  801950:	df000215 	stw	fp,8(sp)
  801954:	df000204 	addi	fp,sp,8
  801958:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  80195c:	e0bfff17 	ldw	r2,-4(fp)
  801960:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
  801964:	e13ffe17 	ldw	r4,-8(fp)
  801968:	0800b680 	call	800b68 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
  80196c:	0001883a 	nop
  801970:	e037883a 	mov	sp,fp
  801974:	dfc00117 	ldw	ra,4(sp)
  801978:	df000017 	ldw	fp,0(sp)
  80197c:	dec00204 	addi	sp,sp,8
  801980:	f800283a 	ret

00801984 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  801984:	defff904 	addi	sp,sp,-28
  801988:	dfc00615 	stw	ra,24(sp)
  80198c:	df000515 	stw	fp,20(sp)
  801990:	df000504 	addi	fp,sp,20
  801994:	e13ffd15 	stw	r4,-12(fp)
  801998:	e17ffe15 	stw	r5,-8(fp)
  80199c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
  8019a0:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  8019a4:	e0bffd17 	ldw	r2,-12(fp)
  8019a8:	10800e17 	ldw	r2,56(r2)
  8019ac:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  8019b0:	e0bffd17 	ldw	r2,-12(fp)
  8019b4:	10801017 	ldw	r2,64(r2)
  8019b8:	10000b1e 	bne	r2,zero,8019e8 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  8019bc:	e0bffd17 	ldw	r2,-12(fp)
  8019c0:	10800017 	ldw	r2,0(r2)
  8019c4:	1000481e 	bne	r2,zero,801ae8 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  8019c8:	e0bffd17 	ldw	r2,-12(fp)
  8019cc:	10800117 	ldw	r2,4(r2)
  8019d0:	1009883a 	mov	r4,r2
  8019d4:	08037a40 	call	8037a4 <xTaskPriorityDisinherit>
  8019d8:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->pxMutexHolder = NULL;
  8019dc:	e0bffd17 	ldw	r2,-12(fp)
  8019e0:	10000115 	stw	zero,4(r2)
  8019e4:	00004006 	br	801ae8 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  8019e8:	e0bfff17 	ldw	r2,-4(fp)
  8019ec:	1000191e 	bne	r2,zero,801a54 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
  8019f0:	e0bffd17 	ldw	r2,-12(fp)
  8019f4:	10c00217 	ldw	r3,8(r2)
  8019f8:	e0bffd17 	ldw	r2,-12(fp)
  8019fc:	10801017 	ldw	r2,64(r2)
  801a00:	100d883a 	mov	r6,r2
  801a04:	e17ffe17 	ldw	r5,-8(fp)
  801a08:	1809883a 	mov	r4,r3
  801a0c:	080f4440 	call	80f444 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  801a10:	e0bffd17 	ldw	r2,-12(fp)
  801a14:	10c00217 	ldw	r3,8(r2)
  801a18:	e0bffd17 	ldw	r2,-12(fp)
  801a1c:	10801017 	ldw	r2,64(r2)
  801a20:	1887883a 	add	r3,r3,r2
  801a24:	e0bffd17 	ldw	r2,-12(fp)
  801a28:	10c00215 	stw	r3,8(r2)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  801a2c:	e0bffd17 	ldw	r2,-12(fp)
  801a30:	10c00217 	ldw	r3,8(r2)
  801a34:	e0bffd17 	ldw	r2,-12(fp)
  801a38:	10800117 	ldw	r2,4(r2)
  801a3c:	18802a36 	bltu	r3,r2,801ae8 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  801a40:	e0bffd17 	ldw	r2,-12(fp)
  801a44:	10c00017 	ldw	r3,0(r2)
  801a48:	e0bffd17 	ldw	r2,-12(fp)
  801a4c:	10c00215 	stw	r3,8(r2)
  801a50:	00002506 	br	801ae8 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  801a54:	e0bffd17 	ldw	r2,-12(fp)
  801a58:	10c00317 	ldw	r3,12(r2)
  801a5c:	e0bffd17 	ldw	r2,-12(fp)
  801a60:	10801017 	ldw	r2,64(r2)
  801a64:	100d883a 	mov	r6,r2
  801a68:	e17ffe17 	ldw	r5,-8(fp)
  801a6c:	1809883a 	mov	r4,r3
  801a70:	080f4440 	call	80f444 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  801a74:	e0bffd17 	ldw	r2,-12(fp)
  801a78:	10c00317 	ldw	r3,12(r2)
  801a7c:	e0bffd17 	ldw	r2,-12(fp)
  801a80:	10801017 	ldw	r2,64(r2)
  801a84:	0085c83a 	sub	r2,zero,r2
  801a88:	1887883a 	add	r3,r3,r2
  801a8c:	e0bffd17 	ldw	r2,-12(fp)
  801a90:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  801a94:	e0bffd17 	ldw	r2,-12(fp)
  801a98:	10c00317 	ldw	r3,12(r2)
  801a9c:	e0bffd17 	ldw	r2,-12(fp)
  801aa0:	10800017 	ldw	r2,0(r2)
  801aa4:	1880082e 	bgeu	r3,r2,801ac8 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  801aa8:	e0bffd17 	ldw	r2,-12(fp)
  801aac:	10c00117 	ldw	r3,4(r2)
  801ab0:	e0bffd17 	ldw	r2,-12(fp)
  801ab4:	10801017 	ldw	r2,64(r2)
  801ab8:	0085c83a 	sub	r2,zero,r2
  801abc:	1887883a 	add	r3,r3,r2
  801ac0:	e0bffd17 	ldw	r2,-12(fp)
  801ac4:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  801ac8:	e0bfff17 	ldw	r2,-4(fp)
  801acc:	10800098 	cmpnei	r2,r2,2
  801ad0:	1000051e 	bne	r2,zero,801ae8 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801ad4:	e0bffc17 	ldw	r2,-16(fp)
  801ad8:	10000326 	beq	r2,zero,801ae8 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  801adc:	e0bffc17 	ldw	r2,-16(fp)
  801ae0:	10bfffc4 	addi	r2,r2,-1
  801ae4:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
  801ae8:	e0bffc17 	ldw	r2,-16(fp)
  801aec:	10c00044 	addi	r3,r2,1
  801af0:	e0bffd17 	ldw	r2,-12(fp)
  801af4:	10c00e15 	stw	r3,56(r2)

	return xReturn;
  801af8:	e0bffb17 	ldw	r2,-20(fp)
}
  801afc:	e037883a 	mov	sp,fp
  801b00:	dfc00117 	ldw	ra,4(sp)
  801b04:	df000017 	ldw	fp,0(sp)
  801b08:	dec00204 	addi	sp,sp,8
  801b0c:	f800283a 	ret

00801b10 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  801b10:	defffc04 	addi	sp,sp,-16
  801b14:	dfc00315 	stw	ra,12(sp)
  801b18:	df000215 	stw	fp,8(sp)
  801b1c:	df000204 	addi	fp,sp,8
  801b20:	e13ffe15 	stw	r4,-8(fp)
  801b24:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  801b28:	e0bffe17 	ldw	r2,-8(fp)
  801b2c:	10801017 	ldw	r2,64(r2)
  801b30:	10001826 	beq	r2,zero,801b94 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  801b34:	e0bffe17 	ldw	r2,-8(fp)
  801b38:	10c00317 	ldw	r3,12(r2)
  801b3c:	e0bffe17 	ldw	r2,-8(fp)
  801b40:	10801017 	ldw	r2,64(r2)
  801b44:	1887883a 	add	r3,r3,r2
  801b48:	e0bffe17 	ldw	r2,-8(fp)
  801b4c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  801b50:	e0bffe17 	ldw	r2,-8(fp)
  801b54:	10c00317 	ldw	r3,12(r2)
  801b58:	e0bffe17 	ldw	r2,-8(fp)
  801b5c:	10800117 	ldw	r2,4(r2)
  801b60:	18800436 	bltu	r3,r2,801b74 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  801b64:	e0bffe17 	ldw	r2,-8(fp)
  801b68:	10c00017 	ldw	r3,0(r2)
  801b6c:	e0bffe17 	ldw	r2,-8(fp)
  801b70:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
  801b74:	e0bffe17 	ldw	r2,-8(fp)
  801b78:	10c00317 	ldw	r3,12(r2)
  801b7c:	e0bffe17 	ldw	r2,-8(fp)
  801b80:	10801017 	ldw	r2,64(r2)
  801b84:	100d883a 	mov	r6,r2
  801b88:	180b883a 	mov	r5,r3
  801b8c:	e13fff17 	ldw	r4,-4(fp)
  801b90:	080f4440 	call	80f444 <memcpy>
	}
}
  801b94:	0001883a 	nop
  801b98:	e037883a 	mov	sp,fp
  801b9c:	dfc00117 	ldw	ra,4(sp)
  801ba0:	df000017 	ldw	fp,0(sp)
  801ba4:	dec00204 	addi	sp,sp,8
  801ba8:	f800283a 	ret

00801bac <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  801bac:	defffc04 	addi	sp,sp,-16
  801bb0:	dfc00315 	stw	ra,12(sp)
  801bb4:	df000215 	stw	fp,8(sp)
  801bb8:	df000204 	addi	fp,sp,8
  801bbc:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  801bc0:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
  801bc4:	e0bfff17 	ldw	r2,-4(fp)
  801bc8:	10801143 	ldbu	r2,69(r2)
  801bcc:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  801bd0:	00000c06 	br	801c04 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  801bd4:	e0bfff17 	ldw	r2,-4(fp)
  801bd8:	10800917 	ldw	r2,36(r2)
  801bdc:	10000c26 	beq	r2,zero,801c10 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801be0:	e0bfff17 	ldw	r2,-4(fp)
  801be4:	10800904 	addi	r2,r2,36
  801be8:	1009883a 	mov	r4,r2
  801bec:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  801bf0:	10000126 	beq	r2,zero,801bf8 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
  801bf4:	08033180 	call	803318 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  801bf8:	e0bffe03 	ldbu	r2,-8(fp)
  801bfc:	10bfffc4 	addi	r2,r2,-1
  801c00:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  801c04:	e0bffe07 	ldb	r2,-8(fp)
  801c08:	00bff216 	blt	zero,r2,801bd4 <__alt_data_end+0xfff01bd4>
  801c0c:	00000106 	br	801c14 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
  801c10:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
  801c14:	e0bfff17 	ldw	r2,-4(fp)
  801c18:	00ffffc4 	movi	r3,-1
  801c1c:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
  801c20:	08039000 	call	803900 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  801c24:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
  801c28:	e0bfff17 	ldw	r2,-4(fp)
  801c2c:	10801103 	ldbu	r2,68(r2)
  801c30:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
  801c34:	00000c06 	br	801c68 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801c38:	e0bfff17 	ldw	r2,-4(fp)
  801c3c:	10800417 	ldw	r2,16(r2)
  801c40:	10000c26 	beq	r2,zero,801c74 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  801c44:	e0bfff17 	ldw	r2,-4(fp)
  801c48:	10800404 	addi	r2,r2,16
  801c4c:	1009883a 	mov	r4,r2
  801c50:	080301c0 	call	80301c <xTaskRemoveFromEventList>
  801c54:	10000126 	beq	r2,zero,801c5c <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
  801c58:	08033180 	call	803318 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  801c5c:	e0bffe43 	ldbu	r2,-7(fp)
  801c60:	10bfffc4 	addi	r2,r2,-1
  801c64:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
  801c68:	e0bffe47 	ldb	r2,-7(fp)
  801c6c:	00bff216 	blt	zero,r2,801c38 <__alt_data_end+0xfff01c38>
  801c70:	00000106 	br	801c78 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
  801c74:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  801c78:	e0bfff17 	ldw	r2,-4(fp)
  801c7c:	00ffffc4 	movi	r3,-1
  801c80:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
  801c84:	08039000 	call	803900 <vTaskExitCritical>
}
  801c88:	0001883a 	nop
  801c8c:	e037883a 	mov	sp,fp
  801c90:	dfc00117 	ldw	ra,4(sp)
  801c94:	df000017 	ldw	fp,0(sp)
  801c98:	dec00204 	addi	sp,sp,8
  801c9c:	f800283a 	ret

00801ca0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  801ca0:	defffc04 	addi	sp,sp,-16
  801ca4:	dfc00315 	stw	ra,12(sp)
  801ca8:	df000215 	stw	fp,8(sp)
  801cac:	df000204 	addi	fp,sp,8
  801cb0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  801cb4:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  801cb8:	e0bfff17 	ldw	r2,-4(fp)
  801cbc:	10800e17 	ldw	r2,56(r2)
  801cc0:	1000031e 	bne	r2,zero,801cd0 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
  801cc4:	00800044 	movi	r2,1
  801cc8:	e0bffe15 	stw	r2,-8(fp)
  801ccc:	00000106 	br	801cd4 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
  801cd0:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  801cd4:	08039000 	call	803900 <vTaskExitCritical>

	return xReturn;
  801cd8:	e0bffe17 	ldw	r2,-8(fp)
}
  801cdc:	e037883a 	mov	sp,fp
  801ce0:	dfc00117 	ldw	ra,4(sp)
  801ce4:	df000017 	ldw	fp,0(sp)
  801ce8:	dec00204 	addi	sp,sp,8
  801cec:	f800283a 	ret

00801cf0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
  801cf0:	defffd04 	addi	sp,sp,-12
  801cf4:	df000215 	stw	fp,8(sp)
  801cf8:	df000204 	addi	fp,sp,8
  801cfc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
  801d00:	e0bfff17 	ldw	r2,-4(fp)
  801d04:	10800e17 	ldw	r2,56(r2)
  801d08:	1000031e 	bne	r2,zero,801d18 <xQueueIsQueueEmptyFromISR+0x28>
	{
		xReturn = pdTRUE;
  801d0c:	00800044 	movi	r2,1
  801d10:	e0bffe15 	stw	r2,-8(fp)
  801d14:	00000106 	br	801d1c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
  801d18:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
  801d1c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  801d20:	e037883a 	mov	sp,fp
  801d24:	df000017 	ldw	fp,0(sp)
  801d28:	dec00104 	addi	sp,sp,4
  801d2c:	f800283a 	ret

00801d30 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  801d30:	defffc04 	addi	sp,sp,-16
  801d34:	dfc00315 	stw	ra,12(sp)
  801d38:	df000215 	stw	fp,8(sp)
  801d3c:	df000204 	addi	fp,sp,8
  801d40:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  801d44:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  801d48:	e0bfff17 	ldw	r2,-4(fp)
  801d4c:	10c00e17 	ldw	r3,56(r2)
  801d50:	e0bfff17 	ldw	r2,-4(fp)
  801d54:	10800f17 	ldw	r2,60(r2)
  801d58:	1880031e 	bne	r3,r2,801d68 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
  801d5c:	00800044 	movi	r2,1
  801d60:	e0bffe15 	stw	r2,-8(fp)
  801d64:	00000106 	br	801d6c <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
  801d68:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  801d6c:	08039000 	call	803900 <vTaskExitCritical>

	return xReturn;
  801d70:	e0bffe17 	ldw	r2,-8(fp)
}
  801d74:	e037883a 	mov	sp,fp
  801d78:	dfc00117 	ldw	ra,4(sp)
  801d7c:	df000017 	ldw	fp,0(sp)
  801d80:	dec00204 	addi	sp,sp,8
  801d84:	f800283a 	ret

00801d88 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
  801d88:	defffd04 	addi	sp,sp,-12
  801d8c:	df000215 	stw	fp,8(sp)
  801d90:	df000204 	addi	fp,sp,8
  801d94:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
  801d98:	e0bfff17 	ldw	r2,-4(fp)
  801d9c:	10c00e17 	ldw	r3,56(r2)
  801da0:	e0bfff17 	ldw	r2,-4(fp)
  801da4:	10800f17 	ldw	r2,60(r2)
  801da8:	1880031e 	bne	r3,r2,801db8 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
  801dac:	00800044 	movi	r2,1
  801db0:	e0bffe15 	stw	r2,-8(fp)
  801db4:	00000106 	br	801dbc <xQueueIsQueueFullFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
  801db8:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
  801dbc:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  801dc0:	e037883a 	mov	sp,fp
  801dc4:	df000017 	ldw	fp,0(sp)
  801dc8:	dec00104 	addi	sp,sp,4
  801dcc:	f800283a 	ret

00801dd0 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
  801dd0:	defff304 	addi	sp,sp,-52
  801dd4:	dfc00c15 	stw	ra,48(sp)
  801dd8:	df000b15 	stw	fp,44(sp)
  801ddc:	df000b04 	addi	fp,sp,44
  801de0:	e13ffc15 	stw	r4,-16(fp)
  801de4:	e17ffd15 	stw	r5,-12(fp)
  801de8:	3005883a 	mov	r2,r6
  801dec:	e1ffff15 	stw	r7,-4(fp)
  801df0:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  801df4:	e0bffe0b 	ldhu	r2,-8(fp)
  801df8:	1085883a 	add	r2,r2,r2
  801dfc:	1085883a 	add	r2,r2,r2
  801e00:	1009883a 	mov	r4,r2
  801e04:	08009980 	call	800998 <pvPortMalloc>
  801e08:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
  801e0c:	e0bffb17 	ldw	r2,-20(fp)
  801e10:	10000c26 	beq	r2,zero,801e44 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
  801e14:	01001404 	movi	r4,80
  801e18:	08009980 	call	800998 <pvPortMalloc>
  801e1c:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
  801e20:	e0bff917 	ldw	r2,-28(fp)
  801e24:	10000426 	beq	r2,zero,801e38 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  801e28:	e0bff917 	ldw	r2,-28(fp)
  801e2c:	e0fffb17 	ldw	r3,-20(fp)
  801e30:	10c00c15 	stw	r3,48(r2)
  801e34:	00000406 	br	801e48 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  801e38:	e13ffb17 	ldw	r4,-20(fp)
  801e3c:	0800b680 	call	800b68 <vPortFree>
  801e40:	00000106 	br	801e48 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
  801e44:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  801e48:	e0bff917 	ldw	r2,-28(fp)
  801e4c:	10001226 	beq	r2,zero,801e98 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  801e50:	e0fffe0b 	ldhu	r3,-8(fp)
  801e54:	d8000315 	stw	zero,12(sp)
  801e58:	e0bff917 	ldw	r2,-28(fp)
  801e5c:	d8800215 	stw	r2,8(sp)
  801e60:	e0800317 	ldw	r2,12(fp)
  801e64:	d8800115 	stw	r2,4(sp)
  801e68:	e0800217 	ldw	r2,8(fp)
  801e6c:	d8800015 	stw	r2,0(sp)
  801e70:	e1ffff17 	ldw	r7,-4(fp)
  801e74:	180d883a 	mov	r6,r3
  801e78:	e17ffd17 	ldw	r5,-12(fp)
  801e7c:	e13ffc17 	ldw	r4,-16(fp)
  801e80:	0801eb80 	call	801eb8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
  801e84:	e13ff917 	ldw	r4,-28(fp)
  801e88:	08020880 	call	802088 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  801e8c:	00800044 	movi	r2,1
  801e90:	e0bffa15 	stw	r2,-24(fp)
  801e94:	00000206 	br	801ea0 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  801e98:	00bfffc4 	movi	r2,-1
  801e9c:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
  801ea0:	e0bffa17 	ldw	r2,-24(fp)
	}
  801ea4:	e037883a 	mov	sp,fp
  801ea8:	dfc00117 	ldw	ra,4(sp)
  801eac:	df000017 	ldw	fp,0(sp)
  801eb0:	dec00204 	addi	sp,sp,8
  801eb4:	f800283a 	ret

00801eb8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  801eb8:	defff804 	addi	sp,sp,-32
  801ebc:	dfc00715 	stw	ra,28(sp)
  801ec0:	df000615 	stw	fp,24(sp)
  801ec4:	df000604 	addi	fp,sp,24
  801ec8:	e13ffc15 	stw	r4,-16(fp)
  801ecc:	e17ffd15 	stw	r5,-12(fp)
  801ed0:	e1bffe15 	stw	r6,-8(fp)
  801ed4:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  801ed8:	e0800417 	ldw	r2,16(fp)
  801edc:	10c00c17 	ldw	r3,48(r2)
  801ee0:	e0bffe17 	ldw	r2,-8(fp)
  801ee4:	1085883a 	add	r2,r2,r2
  801ee8:	1085883a 	add	r2,r2,r2
  801eec:	100d883a 	mov	r6,r2
  801ef0:	01402944 	movi	r5,165
  801ef4:	1809883a 	mov	r4,r3
  801ef8:	080f58c0 	call	80f58c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
  801efc:	e0800417 	ldw	r2,16(fp)
  801f00:	10c00c17 	ldw	r3,48(r2)
  801f04:	e13ffe17 	ldw	r4,-8(fp)
  801f08:	00900034 	movhi	r2,16384
  801f0c:	10bfffc4 	addi	r2,r2,-1
  801f10:	2085883a 	add	r2,r4,r2
  801f14:	1085883a 	add	r2,r2,r2
  801f18:	1085883a 	add	r2,r2,r2
  801f1c:	1885883a 	add	r2,r3,r2
  801f20:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
  801f24:	e0fffb17 	ldw	r3,-20(fp)
  801f28:	00bfff04 	movi	r2,-4
  801f2c:	1884703a 	and	r2,r3,r2
  801f30:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  801f34:	e03ffa15 	stw	zero,-24(fp)
  801f38:	00001406 	br	801f8c <prvInitialiseNewTask+0xd4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  801f3c:	e0fffd17 	ldw	r3,-12(fp)
  801f40:	e0bffa17 	ldw	r2,-24(fp)
  801f44:	1885883a 	add	r2,r3,r2
  801f48:	10c00003 	ldbu	r3,0(r2)
  801f4c:	e1000417 	ldw	r4,16(fp)
  801f50:	e0bffa17 	ldw	r2,-24(fp)
  801f54:	2085883a 	add	r2,r4,r2
  801f58:	10800d04 	addi	r2,r2,52
  801f5c:	10c00005 	stb	r3,0(r2)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
  801f60:	e0fffd17 	ldw	r3,-12(fp)
  801f64:	e0bffa17 	ldw	r2,-24(fp)
  801f68:	1885883a 	add	r2,r3,r2
  801f6c:	10800003 	ldbu	r2,0(r2)
  801f70:	10803fcc 	andi	r2,r2,255
  801f74:	1080201c 	xori	r2,r2,128
  801f78:	10bfe004 	addi	r2,r2,-128
  801f7c:	10000726 	beq	r2,zero,801f9c <prvInitialiseNewTask+0xe4>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  801f80:	e0bffa17 	ldw	r2,-24(fp)
  801f84:	10800044 	addi	r2,r2,1
  801f88:	e0bffa15 	stw	r2,-24(fp)
  801f8c:	e0bffa17 	ldw	r2,-24(fp)
  801f90:	10800230 	cmpltui	r2,r2,8
  801f94:	103fe91e 	bne	r2,zero,801f3c <__alt_data_end+0xfff01f3c>
  801f98:	00000106 	br	801fa0 <prvInitialiseNewTask+0xe8>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
  801f9c:	0001883a 	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  801fa0:	e0800417 	ldw	r2,16(fp)
  801fa4:	10000ec5 	stb	zero,59(r2)

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  801fa8:	e0800217 	ldw	r2,8(fp)
  801fac:	10800170 	cmpltui	r2,r2,5
  801fb0:	1000021e 	bne	r2,zero,801fbc <prvInitialiseNewTask+0x104>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  801fb4:	00800104 	movi	r2,4
  801fb8:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  801fbc:	e0800417 	ldw	r2,16(fp)
  801fc0:	e0c00217 	ldw	r3,8(fp)
  801fc4:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  801fc8:	e0800417 	ldw	r2,16(fp)
  801fcc:	e0c00217 	ldw	r3,8(fp)
  801fd0:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
  801fd4:	e0800417 	ldw	r2,16(fp)
  801fd8:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  801fdc:	e0800417 	ldw	r2,16(fp)
  801fe0:	10800104 	addi	r2,r2,4
  801fe4:	1009883a 	mov	r4,r2
  801fe8:	08002f00 	call	8002f0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  801fec:	e0800417 	ldw	r2,16(fp)
  801ff0:	10800604 	addi	r2,r2,24
  801ff4:	1009883a 	mov	r4,r2
  801ff8:	08002f00 	call	8002f0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  801ffc:	e0800417 	ldw	r2,16(fp)
  802000:	e0c00417 	ldw	r3,16(fp)
  802004:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  802008:	00c00144 	movi	r3,5
  80200c:	e0800217 	ldw	r2,8(fp)
  802010:	1887c83a 	sub	r3,r3,r2
  802014:	e0800417 	ldw	r2,16(fp)
  802018:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  80201c:	e0800417 	ldw	r2,16(fp)
  802020:	e0c00417 	ldw	r3,16(fp)
  802024:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
  802028:	e0800417 	ldw	r2,16(fp)
  80202c:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  802030:	e0800417 	ldw	r2,16(fp)
  802034:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  802038:	e0800417 	ldw	r2,16(fp)
  80203c:	10001305 	stb	zero,76(r2)
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  802040:	e1bfff17 	ldw	r6,-4(fp)
  802044:	e17ffc17 	ldw	r5,-16(fp)
  802048:	e13ffb17 	ldw	r4,-20(fp)
  80204c:	08005400 	call	800540 <pxPortInitialiseStack>
  802050:	1007883a 	mov	r3,r2
  802054:	e0800417 	ldw	r2,16(fp)
  802058:	10c00015 	stw	r3,0(r2)
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
  80205c:	e0800317 	ldw	r2,12(fp)
  802060:	10000326 	beq	r2,zero,802070 <prvInitialiseNewTask+0x1b8>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  802064:	e0800317 	ldw	r2,12(fp)
  802068:	e0c00417 	ldw	r3,16(fp)
  80206c:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  802070:	0001883a 	nop
  802074:	e037883a 	mov	sp,fp
  802078:	dfc00117 	ldw	ra,4(sp)
  80207c:	df000017 	ldw	fp,0(sp)
  802080:	dec00204 	addi	sp,sp,8
  802084:	f800283a 	ret

00802088 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  802088:	defffd04 	addi	sp,sp,-12
  80208c:	dfc00215 	stw	ra,8(sp)
  802090:	df000115 	stw	fp,4(sp)
  802094:	df000104 	addi	fp,sp,4
  802098:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  80209c:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  8020a0:	d0a02917 	ldw	r2,-32604(gp)
  8020a4:	10800044 	addi	r2,r2,1
  8020a8:	d0a02915 	stw	r2,-32604(gp)
		if( pxCurrentTCB == NULL )
  8020ac:	d0a02517 	ldw	r2,-32620(gp)
  8020b0:	1000071e 	bne	r2,zero,8020d0 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  8020b4:	e0bfff17 	ldw	r2,-4(fp)
  8020b8:	d0a02515 	stw	r2,-32620(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  8020bc:	d0a02917 	ldw	r2,-32604(gp)
  8020c0:	10800058 	cmpnei	r2,r2,1
  8020c4:	10000b1e 	bne	r2,zero,8020f4 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  8020c8:	080335c0 	call	80335c <prvInitialiseTaskLists>
  8020cc:	00000906 	br	8020f4 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  8020d0:	d0a02c17 	ldw	r2,-32592(gp)
  8020d4:	1000071e 	bne	r2,zero,8020f4 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  8020d8:	d0a02517 	ldw	r2,-32620(gp)
  8020dc:	10800b17 	ldw	r2,44(r2)
  8020e0:	e0ffff17 	ldw	r3,-4(fp)
  8020e4:	18c00b17 	ldw	r3,44(r3)
  8020e8:	18800236 	bltu	r3,r2,8020f4 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
  8020ec:	e0bfff17 	ldw	r2,-4(fp)
  8020f0:	d0a02515 	stw	r2,-32620(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  8020f4:	d0a03017 	ldw	r2,-32576(gp)
  8020f8:	10800044 	addi	r2,r2,1
  8020fc:	d0a03015 	stw	r2,-32576(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  802100:	e0bfff17 	ldw	r2,-4(fp)
  802104:	10800b17 	ldw	r2,44(r2)
  802108:	d0e02b17 	ldw	r3,-32596(gp)
  80210c:	1880032e 	bgeu	r3,r2,80211c <prvAddNewTaskToReadyList+0x94>
  802110:	e0bfff17 	ldw	r2,-4(fp)
  802114:	10800b17 	ldw	r2,44(r2)
  802118:	d0a02b15 	stw	r2,-32596(gp)
  80211c:	e0bfff17 	ldw	r2,-4(fp)
  802120:	10800b17 	ldw	r2,44(r2)
  802124:	01400504 	movi	r5,20
  802128:	1009883a 	mov	r4,r2
  80212c:	080b2480 	call	80b248 <__mulsi3>
  802130:	1007883a 	mov	r3,r2
  802134:	008020f4 	movhi	r2,131
  802138:	10ad7c04 	addi	r2,r2,-18960
  80213c:	1887883a 	add	r3,r3,r2
  802140:	e0bfff17 	ldw	r2,-4(fp)
  802144:	10800104 	addi	r2,r2,4
  802148:	100b883a 	mov	r5,r2
  80214c:	1809883a 	mov	r4,r3
  802150:	080031c0 	call	80031c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  802154:	08039000 	call	803900 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
  802158:	d0a02c17 	ldw	r2,-32592(gp)
  80215c:	10000626 	beq	r2,zero,802178 <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  802160:	d0a02517 	ldw	r2,-32620(gp)
  802164:	10c00b17 	ldw	r3,44(r2)
  802168:	e0bfff17 	ldw	r2,-4(fp)
  80216c:	10800b17 	ldw	r2,44(r2)
  802170:	1880012e 	bgeu	r3,r2,802178 <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
  802174:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  802178:	0001883a 	nop
  80217c:	e037883a 	mov	sp,fp
  802180:	dfc00117 	ldw	ra,4(sp)
  802184:	df000017 	ldw	fp,0(sp)
  802188:	dec00204 	addi	sp,sp,8
  80218c:	f800283a 	ret

00802190 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
  802190:	defffc04 	addi	sp,sp,-16
  802194:	dfc00315 	stw	ra,12(sp)
  802198:	df000215 	stw	fp,8(sp)
  80219c:	df000204 	addi	fp,sp,8
  8021a0:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  8021a4:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  8021a8:	e0bfff17 	ldw	r2,-4(fp)
  8021ac:	1000021e 	bne	r2,zero,8021b8 <vTaskDelete+0x28>
  8021b0:	d0a02517 	ldw	r2,-32620(gp)
  8021b4:	00000106 	br	8021bc <vTaskDelete+0x2c>
  8021b8:	e0bfff17 	ldw	r2,-4(fp)
  8021bc:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  8021c0:	e0bffe17 	ldw	r2,-8(fp)
  8021c4:	10800104 	addi	r2,r2,4
  8021c8:	1009883a 	mov	r4,r2
  8021cc:	08004800 	call	800480 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  8021d0:	e0bffe17 	ldw	r2,-8(fp)
  8021d4:	10800a17 	ldw	r2,40(r2)
  8021d8:	10000426 	beq	r2,zero,8021ec <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  8021dc:	e0bffe17 	ldw	r2,-8(fp)
  8021e0:	10800604 	addi	r2,r2,24
  8021e4:	1009883a 	mov	r4,r2
  8021e8:	08004800 	call	800480 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
  8021ec:	d0a03017 	ldw	r2,-32576(gp)
  8021f0:	10800044 	addi	r2,r2,1
  8021f4:	d0a03015 	stw	r2,-32576(gp)

			if( pxTCB == pxCurrentTCB )
  8021f8:	d0a02517 	ldw	r2,-32620(gp)
  8021fc:	e0fffe17 	ldw	r3,-8(fp)
  802200:	18800a1e 	bne	r3,r2,80222c <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
  802204:	e0bffe17 	ldw	r2,-8(fp)
  802208:	10800104 	addi	r2,r2,4
  80220c:	100b883a 	mov	r5,r2
  802210:	010020f4 	movhi	r4,131
  802214:	212da404 	addi	r4,r4,-18800
  802218:	080031c0 	call	80031c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
  80221c:	d0a02817 	ldw	r2,-32608(gp)
  802220:	10800044 	addi	r2,r2,1
  802224:	d0a02815 	stw	r2,-32608(gp)
  802228:	00000606 	br	802244 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
  80222c:	d0a02917 	ldw	r2,-32604(gp)
  802230:	10bfffc4 	addi	r2,r2,-1
  802234:	d0a02915 	stw	r2,-32604(gp)
				prvDeleteTCB( pxTCB );
  802238:	e13ffe17 	ldw	r4,-8(fp)
  80223c:	08035880 	call	803588 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
  802240:	08035cc0 	call	8035cc <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  802244:	08039000 	call	803900 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
  802248:	d0a02c17 	ldw	r2,-32592(gp)
  80224c:	10000426 	beq	r2,zero,802260 <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
  802250:	d0a02517 	ldw	r2,-32620(gp)
  802254:	e0fffe17 	ldw	r3,-8(fp)
  802258:	1880011e 	bne	r3,r2,802260 <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  80225c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
  802260:	0001883a 	nop
  802264:	e037883a 	mov	sp,fp
  802268:	dfc00117 	ldw	ra,4(sp)
  80226c:	df000017 	ldw	fp,0(sp)
  802270:	dec00204 	addi	sp,sp,8
  802274:	f800283a 	ret

00802278 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
  802278:	defff804 	addi	sp,sp,-32
  80227c:	dfc00715 	stw	ra,28(sp)
  802280:	df000615 	stw	fp,24(sp)
  802284:	df000604 	addi	fp,sp,24
  802288:	e13ffe15 	stw	r4,-8(fp)
  80228c:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
  802290:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
  802294:	0802a4c0 	call	802a4c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  802298:	d0a02a17 	ldw	r2,-32600(gp)
  80229c:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  8022a0:	e0bffe17 	ldw	r2,-8(fp)
  8022a4:	10c00017 	ldw	r3,0(r2)
  8022a8:	e0bfff17 	ldw	r2,-4(fp)
  8022ac:	1885883a 	add	r2,r3,r2
  8022b0:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
  8022b4:	e0bffe17 	ldw	r2,-8(fp)
  8022b8:	10800017 	ldw	r2,0(r2)
  8022bc:	e0fffb17 	ldw	r3,-20(fp)
  8022c0:	18800a2e 	bgeu	r3,r2,8022ec <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  8022c4:	e0bffe17 	ldw	r2,-8(fp)
  8022c8:	10800017 	ldw	r2,0(r2)
  8022cc:	e0fffc17 	ldw	r3,-16(fp)
  8022d0:	18800f2e 	bgeu	r3,r2,802310 <vTaskDelayUntil+0x98>
  8022d4:	e0bffc17 	ldw	r2,-16(fp)
  8022d8:	e0fffb17 	ldw	r3,-20(fp)
  8022dc:	18800c2e 	bgeu	r3,r2,802310 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  8022e0:	00800044 	movi	r2,1
  8022e4:	e0bffa15 	stw	r2,-24(fp)
  8022e8:	00000906 	br	802310 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  8022ec:	e0bffe17 	ldw	r2,-8(fp)
  8022f0:	10800017 	ldw	r2,0(r2)
  8022f4:	e0fffc17 	ldw	r3,-16(fp)
  8022f8:	18800336 	bltu	r3,r2,802308 <vTaskDelayUntil+0x90>
  8022fc:	e0bffc17 	ldw	r2,-16(fp)
  802300:	e0fffb17 	ldw	r3,-20(fp)
  802304:	1880022e 	bgeu	r3,r2,802310 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  802308:	00800044 	movi	r2,1
  80230c:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  802310:	e0bffe17 	ldw	r2,-8(fp)
  802314:	e0fffc17 	ldw	r3,-16(fp)
  802318:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
  80231c:	e0bffa17 	ldw	r2,-24(fp)
  802320:	10000626 	beq	r2,zero,80233c <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
  802324:	e0fffc17 	ldw	r3,-16(fp)
  802328:	e0bffb17 	ldw	r2,-20(fp)
  80232c:	1885c83a 	sub	r2,r3,r2
  802330:	000b883a 	mov	r5,zero
  802334:	1009883a 	mov	r4,r2
  802338:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  80233c:	0802a780 	call	802a78 <xTaskResumeAll>
  802340:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  802344:	e0bffd17 	ldw	r2,-12(fp)
  802348:	1000011e 	bne	r2,zero,802350 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
  80234c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  802350:	0001883a 	nop
  802354:	e037883a 	mov	sp,fp
  802358:	dfc00117 	ldw	ra,4(sp)
  80235c:	df000017 	ldw	fp,0(sp)
  802360:	dec00204 	addi	sp,sp,8
  802364:	f800283a 	ret

00802368 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
  802368:	defffc04 	addi	sp,sp,-16
  80236c:	dfc00315 	stw	ra,12(sp)
  802370:	df000215 	stw	fp,8(sp)
  802374:	df000204 	addi	fp,sp,8
  802378:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
  80237c:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
  802380:	e0bfff17 	ldw	r2,-4(fp)
  802384:	10000626 	beq	r2,zero,8023a0 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
  802388:	0802a4c0 	call	802a4c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  80238c:	000b883a 	mov	r5,zero
  802390:	e13fff17 	ldw	r4,-4(fp)
  802394:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
  802398:	0802a780 	call	802a78 <xTaskResumeAll>
  80239c:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  8023a0:	e0bffe17 	ldw	r2,-8(fp)
  8023a4:	1000011e 	bne	r2,zero,8023ac <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
  8023a8:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8023ac:	0001883a 	nop
  8023b0:	e037883a 	mov	sp,fp
  8023b4:	dfc00117 	ldw	ra,4(sp)
  8023b8:	df000017 	ldw	fp,0(sp)
  8023bc:	dec00204 	addi	sp,sp,8
  8023c0:	f800283a 	ret

008023c4 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
  8023c4:	defffb04 	addi	sp,sp,-20
  8023c8:	dfc00415 	stw	ra,16(sp)
  8023cc:	df000315 	stw	fp,12(sp)
  8023d0:	df000304 	addi	fp,sp,12
  8023d4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
  8023d8:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  8023dc:	e0bfff17 	ldw	r2,-4(fp)
  8023e0:	1000021e 	bne	r2,zero,8023ec <uxTaskPriorityGet+0x28>
  8023e4:	d0a02517 	ldw	r2,-32620(gp)
  8023e8:	00000106 	br	8023f0 <uxTaskPriorityGet+0x2c>
  8023ec:	e0bfff17 	ldw	r2,-4(fp)
  8023f0:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  8023f4:	e0bffd17 	ldw	r2,-12(fp)
  8023f8:	10800b17 	ldw	r2,44(r2)
  8023fc:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
  802400:	08039000 	call	803900 <vTaskExitCritical>

		return uxReturn;
  802404:	e0bffe17 	ldw	r2,-8(fp)
	}
  802408:	e037883a 	mov	sp,fp
  80240c:	dfc00117 	ldw	ra,4(sp)
  802410:	df000017 	ldw	fp,0(sp)
  802414:	dec00204 	addi	sp,sp,8
  802418:	f800283a 	ret

0080241c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
  80241c:	defffb04 	addi	sp,sp,-20
  802420:	df000415 	stw	fp,16(sp)
  802424:	df000404 	addi	fp,sp,16
  802428:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
  80242c:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  802430:	e0bfff17 	ldw	r2,-4(fp)
  802434:	1000021e 	bne	r2,zero,802440 <uxTaskPriorityGetFromISR+0x24>
  802438:	d0a02517 	ldw	r2,-32620(gp)
  80243c:	00000106 	br	802444 <uxTaskPriorityGetFromISR+0x28>
  802440:	e0bfff17 	ldw	r2,-4(fp)
  802444:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  802448:	e0bffd17 	ldw	r2,-12(fp)
  80244c:	10800b17 	ldw	r2,44(r2)
  802450:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
  802454:	e0bffe17 	ldw	r2,-8(fp)
	}
  802458:	e037883a 	mov	sp,fp
  80245c:	df000017 	ldw	fp,0(sp)
  802460:	dec00104 	addi	sp,sp,4
  802464:	f800283a 	ret

00802468 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
  802468:	defff704 	addi	sp,sp,-36
  80246c:	dfc00815 	stw	ra,32(sp)
  802470:	df000715 	stw	fp,28(sp)
  802474:	dc000615 	stw	r16,24(sp)
  802478:	df000704 	addi	fp,sp,28
  80247c:	e13ffd15 	stw	r4,-12(fp)
  802480:	e17ffe15 	stw	r5,-8(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
  802484:	e03ff915 	stw	zero,-28(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  802488:	e0bffe17 	ldw	r2,-8(fp)
  80248c:	10800170 	cmpltui	r2,r2,5
  802490:	1000021e 	bne	r2,zero,80249c <vTaskPrioritySet+0x34>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  802494:	00800104 	movi	r2,4
  802498:	e0bffe15 	stw	r2,-8(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
  80249c:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
  8024a0:	e0bffd17 	ldw	r2,-12(fp)
  8024a4:	1000021e 	bne	r2,zero,8024b0 <vTaskPrioritySet+0x48>
  8024a8:	d0a02517 	ldw	r2,-32620(gp)
  8024ac:	00000106 	br	8024b4 <vTaskPrioritySet+0x4c>
  8024b0:	e0bffd17 	ldw	r2,-12(fp)
  8024b4:	e0bffa15 	stw	r2,-24(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  8024b8:	e0bffa17 	ldw	r2,-24(fp)
  8024bc:	10801017 	ldw	r2,64(r2)
  8024c0:	e0bffb15 	stw	r2,-20(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
  8024c4:	e0fffb17 	ldw	r3,-20(fp)
  8024c8:	e0bffe17 	ldw	r2,-8(fp)
  8024cc:	18805326 	beq	r3,r2,80261c <vTaskPrioritySet+0x1b4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
  8024d0:	e0bffe17 	ldw	r2,-8(fp)
  8024d4:	e0fffb17 	ldw	r3,-20(fp)
  8024d8:	18800a2e 	bgeu	r3,r2,802504 <vTaskPrioritySet+0x9c>
				{
					if( pxTCB != pxCurrentTCB )
  8024dc:	d0a02517 	ldw	r2,-32620(gp)
  8024e0:	e0fffa17 	ldw	r3,-24(fp)
  8024e4:	18800c26 	beq	r3,r2,802518 <vTaskPrioritySet+0xb0>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  8024e8:	d0a02517 	ldw	r2,-32620(gp)
  8024ec:	10800b17 	ldw	r2,44(r2)
  8024f0:	e0fffe17 	ldw	r3,-8(fp)
  8024f4:	18800836 	bltu	r3,r2,802518 <vTaskPrioritySet+0xb0>
						{
							xYieldRequired = pdTRUE;
  8024f8:	00800044 	movi	r2,1
  8024fc:	e0bff915 	stw	r2,-28(fp)
  802500:	00000506 	br	802518 <vTaskPrioritySet+0xb0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
  802504:	d0a02517 	ldw	r2,-32620(gp)
  802508:	e0fffa17 	ldw	r3,-24(fp)
  80250c:	1880021e 	bne	r3,r2,802518 <vTaskPrioritySet+0xb0>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
  802510:	00800044 	movi	r2,1
  802514:	e0bff915 	stw	r2,-28(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  802518:	e0bffa17 	ldw	r2,-24(fp)
  80251c:	10800b17 	ldw	r2,44(r2)
  802520:	e0bffc15 	stw	r2,-16(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  802524:	e0bffa17 	ldw	r2,-24(fp)
  802528:	10c01017 	ldw	r3,64(r2)
  80252c:	e0bffa17 	ldw	r2,-24(fp)
  802530:	10800b17 	ldw	r2,44(r2)
  802534:	1880031e 	bne	r3,r2,802544 <vTaskPrioritySet+0xdc>
					{
						pxTCB->uxPriority = uxNewPriority;
  802538:	e0bffa17 	ldw	r2,-24(fp)
  80253c:	e0fffe17 	ldw	r3,-8(fp)
  802540:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
  802544:	e0bffa17 	ldw	r2,-24(fp)
  802548:	e0fffe17 	ldw	r3,-8(fp)
  80254c:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  802550:	e0bffa17 	ldw	r2,-24(fp)
  802554:	10800617 	ldw	r2,24(r2)
  802558:	10000516 	blt	r2,zero,802570 <vTaskPrioritySet+0x108>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  80255c:	00c00144 	movi	r3,5
  802560:	e0bffe17 	ldw	r2,-8(fp)
  802564:	1887c83a 	sub	r3,r3,r2
  802568:	e0bffa17 	ldw	r2,-24(fp)
  80256c:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  802570:	e0bffa17 	ldw	r2,-24(fp)
  802574:	14000517 	ldw	r16,20(r2)
  802578:	01400504 	movi	r5,20
  80257c:	e13ffc17 	ldw	r4,-16(fp)
  802580:	080b2480 	call	80b248 <__mulsi3>
  802584:	1007883a 	mov	r3,r2
  802588:	008020f4 	movhi	r2,131
  80258c:	10ad7c04 	addi	r2,r2,-18960
  802590:	1885883a 	add	r2,r3,r2
  802594:	8080021e 	bne	r16,r2,8025a0 <vTaskPrioritySet+0x138>
  802598:	00800044 	movi	r2,1
  80259c:	00000106 	br	8025a4 <vTaskPrioritySet+0x13c>
  8025a0:	0005883a 	mov	r2,zero
  8025a4:	10803fcc 	andi	r2,r2,255
  8025a8:	10001926 	beq	r2,zero,802610 <vTaskPrioritySet+0x1a8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  8025ac:	e0bffa17 	ldw	r2,-24(fp)
  8025b0:	10800104 	addi	r2,r2,4
  8025b4:	1009883a 	mov	r4,r2
  8025b8:	08004800 	call	800480 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
  8025bc:	e0bffa17 	ldw	r2,-24(fp)
  8025c0:	10800b17 	ldw	r2,44(r2)
  8025c4:	d0e02b17 	ldw	r3,-32596(gp)
  8025c8:	1880032e 	bgeu	r3,r2,8025d8 <vTaskPrioritySet+0x170>
  8025cc:	e0bffa17 	ldw	r2,-24(fp)
  8025d0:	10800b17 	ldw	r2,44(r2)
  8025d4:	d0a02b15 	stw	r2,-32596(gp)
  8025d8:	e0bffa17 	ldw	r2,-24(fp)
  8025dc:	10800b17 	ldw	r2,44(r2)
  8025e0:	01400504 	movi	r5,20
  8025e4:	1009883a 	mov	r4,r2
  8025e8:	080b2480 	call	80b248 <__mulsi3>
  8025ec:	1007883a 	mov	r3,r2
  8025f0:	008020f4 	movhi	r2,131
  8025f4:	10ad7c04 	addi	r2,r2,-18960
  8025f8:	1887883a 	add	r3,r3,r2
  8025fc:	e0bffa17 	ldw	r2,-24(fp)
  802600:	10800104 	addi	r2,r2,4
  802604:	100b883a 	mov	r5,r2
  802608:	1809883a 	mov	r4,r3
  80260c:	080031c0 	call	80031c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
  802610:	e0bff917 	ldw	r2,-28(fp)
  802614:	10000126 	beq	r2,zero,80261c <vTaskPrioritySet+0x1b4>
				{
					taskYIELD_IF_USING_PREEMPTION();
  802618:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
  80261c:	08039000 	call	803900 <vTaskExitCritical>
	}
  802620:	0001883a 	nop
  802624:	e6ffff04 	addi	sp,fp,-4
  802628:	dfc00217 	ldw	ra,8(sp)
  80262c:	df000117 	ldw	fp,4(sp)
  802630:	dc000017 	ldw	r16,0(sp)
  802634:	dec00304 	addi	sp,sp,12
  802638:	f800283a 	ret

0080263c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
  80263c:	defffc04 	addi	sp,sp,-16
  802640:	dfc00315 	stw	ra,12(sp)
  802644:	df000215 	stw	fp,8(sp)
  802648:	df000204 	addi	fp,sp,8
  80264c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  802650:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  802654:	e0bfff17 	ldw	r2,-4(fp)
  802658:	1000021e 	bne	r2,zero,802664 <vTaskSuspend+0x28>
  80265c:	d0a02517 	ldw	r2,-32620(gp)
  802660:	00000106 	br	802668 <vTaskSuspend+0x2c>
  802664:	e0bfff17 	ldw	r2,-4(fp)
  802668:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  80266c:	e0bffe17 	ldw	r2,-8(fp)
  802670:	10800104 	addi	r2,r2,4
  802674:	1009883a 	mov	r4,r2
  802678:	08004800 	call	800480 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  80267c:	e0bffe17 	ldw	r2,-8(fp)
  802680:	10800a17 	ldw	r2,40(r2)
  802684:	10000426 	beq	r2,zero,802698 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  802688:	e0bffe17 	ldw	r2,-8(fp)
  80268c:	10800604 	addi	r2,r2,24
  802690:	1009883a 	mov	r4,r2
  802694:	08004800 	call	800480 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  802698:	e0bffe17 	ldw	r2,-8(fp)
  80269c:	10800104 	addi	r2,r2,4
  8026a0:	100b883a 	mov	r5,r2
  8026a4:	010020f4 	movhi	r4,131
  8026a8:	212da904 	addi	r4,r4,-18780
  8026ac:	080031c0 	call	80031c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
  8026b0:	08039000 	call	803900 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
  8026b4:	d0a02c17 	ldw	r2,-32592(gp)
  8026b8:	10000326 	beq	r2,zero,8026c8 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
  8026bc:	08038ac0 	call	8038ac <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
  8026c0:	08035cc0 	call	8035cc <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
  8026c4:	08039000 	call	803900 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
  8026c8:	d0a02517 	ldw	r2,-32620(gp)
  8026cc:	e0fffe17 	ldw	r3,-8(fp)
  8026d0:	18800c1e 	bne	r3,r2,802704 <vTaskSuspend+0xc8>
		{
			if( xSchedulerRunning != pdFALSE )
  8026d4:	d0a02c17 	ldw	r2,-32592(gp)
  8026d8:	10000226 	beq	r2,zero,8026e4 <vTaskSuspend+0xa8>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  8026dc:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8026e0:	00000806 	br	802704 <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
  8026e4:	008020f4 	movhi	r2,131
  8026e8:	10ada904 	addi	r2,r2,-18780
  8026ec:	10c00017 	ldw	r3,0(r2)
  8026f0:	d0a02917 	ldw	r2,-32604(gp)
  8026f4:	1880021e 	bne	r3,r2,802700 <vTaskSuspend+0xc4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
  8026f8:	d0202515 	stw	zero,-32620(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8026fc:	00000106 	br	802704 <vTaskSuspend+0xc8>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
  802700:	0802e700 	call	802e70 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  802704:	0001883a 	nop
  802708:	e037883a 	mov	sp,fp
  80270c:	dfc00117 	ldw	ra,4(sp)
  802710:	df000017 	ldw	fp,0(sp)
  802714:	dec00204 	addi	sp,sp,8
  802718:	f800283a 	ret

0080271c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
  80271c:	defffc04 	addi	sp,sp,-16
  802720:	df000315 	stw	fp,12(sp)
  802724:	df000304 	addi	fp,sp,12
  802728:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
  80272c:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
  802730:	e0bfff17 	ldw	r2,-4(fp)
  802734:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  802738:	e0bffe17 	ldw	r2,-8(fp)
  80273c:	10c00517 	ldw	r3,20(r2)
  802740:	008020f4 	movhi	r2,131
  802744:	10ada904 	addi	r2,r2,-18780
  802748:	1880021e 	bne	r3,r2,802754 <prvTaskIsTaskSuspended+0x38>
  80274c:	00800044 	movi	r2,1
  802750:	00000106 	br	802758 <prvTaskIsTaskSuspended+0x3c>
  802754:	0005883a 	mov	r2,zero
  802758:	10803fcc 	andi	r2,r2,255
  80275c:	10000f26 	beq	r2,zero,80279c <prvTaskIsTaskSuspended+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  802760:	e0bffe17 	ldw	r2,-8(fp)
  802764:	10c00a17 	ldw	r3,40(r2)
  802768:	008020f4 	movhi	r2,131
  80276c:	10ad9f04 	addi	r2,r2,-18820
  802770:	18800a26 	beq	r3,r2,80279c <prvTaskIsTaskSuspended+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
  802774:	e0bffe17 	ldw	r2,-8(fp)
  802778:	10800a17 	ldw	r2,40(r2)
  80277c:	1000021e 	bne	r2,zero,802788 <prvTaskIsTaskSuspended+0x6c>
  802780:	00800044 	movi	r2,1
  802784:	00000106 	br	80278c <prvTaskIsTaskSuspended+0x70>
  802788:	0005883a 	mov	r2,zero
  80278c:	10803fcc 	andi	r2,r2,255
  802790:	10000226 	beq	r2,zero,80279c <prvTaskIsTaskSuspended+0x80>
				{
					xReturn = pdTRUE;
  802794:	00800044 	movi	r2,1
  802798:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  80279c:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  8027a0:	e037883a 	mov	sp,fp
  8027a4:	df000017 	ldw	fp,0(sp)
  8027a8:	dec00104 	addi	sp,sp,4
  8027ac:	f800283a 	ret

008027b0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
  8027b0:	defffc04 	addi	sp,sp,-16
  8027b4:	dfc00315 	stw	ra,12(sp)
  8027b8:	df000215 	stw	fp,8(sp)
  8027bc:	df000204 	addi	fp,sp,8
  8027c0:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
  8027c4:	e0bfff17 	ldw	r2,-4(fp)
  8027c8:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
  8027cc:	e0bffe17 	ldw	r2,-8(fp)
  8027d0:	10002726 	beq	r2,zero,802870 <vTaskResume+0xc0>
  8027d4:	d0a02517 	ldw	r2,-32620(gp)
  8027d8:	e0fffe17 	ldw	r3,-8(fp)
  8027dc:	18802426 	beq	r3,r2,802870 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
  8027e0:	08038ac0 	call	8038ac <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  8027e4:	e13ffe17 	ldw	r4,-8(fp)
  8027e8:	080271c0 	call	80271c <prvTaskIsTaskSuspended>
  8027ec:	10001f26 	beq	r2,zero,80286c <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  8027f0:	e0bffe17 	ldw	r2,-8(fp)
  8027f4:	10800104 	addi	r2,r2,4
  8027f8:	1009883a 	mov	r4,r2
  8027fc:	08004800 	call	800480 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  802800:	e0bffe17 	ldw	r2,-8(fp)
  802804:	10800b17 	ldw	r2,44(r2)
  802808:	d0e02b17 	ldw	r3,-32596(gp)
  80280c:	1880032e 	bgeu	r3,r2,80281c <vTaskResume+0x6c>
  802810:	e0bffe17 	ldw	r2,-8(fp)
  802814:	10800b17 	ldw	r2,44(r2)
  802818:	d0a02b15 	stw	r2,-32596(gp)
  80281c:	e0bffe17 	ldw	r2,-8(fp)
  802820:	10800b17 	ldw	r2,44(r2)
  802824:	01400504 	movi	r5,20
  802828:	1009883a 	mov	r4,r2
  80282c:	080b2480 	call	80b248 <__mulsi3>
  802830:	1007883a 	mov	r3,r2
  802834:	008020f4 	movhi	r2,131
  802838:	10ad7c04 	addi	r2,r2,-18960
  80283c:	1887883a 	add	r3,r3,r2
  802840:	e0bffe17 	ldw	r2,-8(fp)
  802844:	10800104 	addi	r2,r2,4
  802848:	100b883a 	mov	r5,r2
  80284c:	1809883a 	mov	r4,r3
  802850:	080031c0 	call	80031c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  802854:	e0bffe17 	ldw	r2,-8(fp)
  802858:	10c00b17 	ldw	r3,44(r2)
  80285c:	d0a02517 	ldw	r2,-32620(gp)
  802860:	10800b17 	ldw	r2,44(r2)
  802864:	18800136 	bltu	r3,r2,80286c <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
  802868:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
  80286c:	08039000 	call	803900 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  802870:	0001883a 	nop
  802874:	e037883a 	mov	sp,fp
  802878:	dfc00117 	ldw	ra,4(sp)
  80287c:	df000017 	ldw	fp,0(sp)
  802880:	dec00204 	addi	sp,sp,8
  802884:	f800283a 	ret

00802888 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
  802888:	defffa04 	addi	sp,sp,-24
  80288c:	dfc00515 	stw	ra,20(sp)
  802890:	df000415 	stw	fp,16(sp)
  802894:	df000404 	addi	fp,sp,16
  802898:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
  80289c:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
  8028a0:	e0bfff17 	ldw	r2,-4(fp)
  8028a4:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  8028a8:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  8028ac:	e13ffd17 	ldw	r4,-12(fp)
  8028b0:	080271c0 	call	80271c <prvTaskIsTaskSuspended>
  8028b4:	10002926 	beq	r2,zero,80295c <xTaskResumeFromISR+0xd4>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  8028b8:	d0a03317 	ldw	r2,-32564(gp)
  8028bc:	1000211e 	bne	r2,zero,802944 <xTaskResumeFromISR+0xbc>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  8028c0:	e0bffd17 	ldw	r2,-12(fp)
  8028c4:	10c00b17 	ldw	r3,44(r2)
  8028c8:	d0a02517 	ldw	r2,-32620(gp)
  8028cc:	10800b17 	ldw	r2,44(r2)
  8028d0:	18800236 	bltu	r3,r2,8028dc <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
  8028d4:	00800044 	movi	r2,1
  8028d8:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8028dc:	e0bffd17 	ldw	r2,-12(fp)
  8028e0:	10800104 	addi	r2,r2,4
  8028e4:	1009883a 	mov	r4,r2
  8028e8:	08004800 	call	800480 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  8028ec:	e0bffd17 	ldw	r2,-12(fp)
  8028f0:	10800b17 	ldw	r2,44(r2)
  8028f4:	d0e02b17 	ldw	r3,-32596(gp)
  8028f8:	1880032e 	bgeu	r3,r2,802908 <xTaskResumeFromISR+0x80>
  8028fc:	e0bffd17 	ldw	r2,-12(fp)
  802900:	10800b17 	ldw	r2,44(r2)
  802904:	d0a02b15 	stw	r2,-32596(gp)
  802908:	e0bffd17 	ldw	r2,-12(fp)
  80290c:	10800b17 	ldw	r2,44(r2)
  802910:	01400504 	movi	r5,20
  802914:	1009883a 	mov	r4,r2
  802918:	080b2480 	call	80b248 <__mulsi3>
  80291c:	1007883a 	mov	r3,r2
  802920:	008020f4 	movhi	r2,131
  802924:	10ad7c04 	addi	r2,r2,-18960
  802928:	1887883a 	add	r3,r3,r2
  80292c:	e0bffd17 	ldw	r2,-12(fp)
  802930:	10800104 	addi	r2,r2,4
  802934:	100b883a 	mov	r5,r2
  802938:	1809883a 	mov	r4,r3
  80293c:	080031c0 	call	80031c <vListInsertEnd>
  802940:	00000606 	br	80295c <xTaskResumeFromISR+0xd4>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  802944:	e0bffd17 	ldw	r2,-12(fp)
  802948:	10800604 	addi	r2,r2,24
  80294c:	100b883a 	mov	r5,r2
  802950:	010020f4 	movhi	r4,131
  802954:	212d9f04 	addi	r4,r4,-18820
  802958:	080031c0 	call	80031c <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
  80295c:	e0bffc17 	ldw	r2,-16(fp)
	}
  802960:	e037883a 	mov	sp,fp
  802964:	dfc00117 	ldw	ra,4(sp)
  802968:	df000017 	ldw	fp,0(sp)
  80296c:	dec00204 	addi	sp,sp,8
  802970:	f800283a 	ret

00802974 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  802974:	defffa04 	addi	sp,sp,-24
  802978:	dfc00515 	stw	ra,20(sp)
  80297c:	df000415 	stw	fp,16(sp)
  802980:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
  802984:	d0a03204 	addi	r2,gp,-32568
  802988:	d8800115 	stw	r2,4(sp)
  80298c:	d8000015 	stw	zero,0(sp)
  802990:	000f883a 	mov	r7,zero
  802994:	01820004 	movi	r6,2048
  802998:	01402074 	movhi	r5,129
  80299c:	2948be04 	addi	r5,r5,8952
  8029a0:	01002034 	movhi	r4,128
  8029a4:	210cd004 	addi	r4,r4,13120
  8029a8:	0801dd00 	call	801dd0 <xTaskCreate>
  8029ac:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  8029b0:	e0bffe17 	ldw	r2,-8(fp)
  8029b4:	10800058 	cmpnei	r2,r2,1
  8029b8:	10000c1e 	bne	r2,zero,8029ec <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8029bc:	0005303a 	rdctl	r2,status
  8029c0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8029c4:	e0ffff17 	ldw	r3,-4(fp)
  8029c8:	00bfff84 	movi	r2,-2
  8029cc:	1884703a 	and	r2,r3,r2
  8029d0:	1001703a 	wrctl	status,r2
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  8029d4:	00bfffc4 	movi	r2,-1
  8029d8:	d0a03115 	stw	r2,-32572(gp)
		xSchedulerRunning = pdTRUE;
  8029dc:	00800044 	movi	r2,1
  8029e0:	d0a02c15 	stw	r2,-32592(gp)
		xTickCount = ( TickType_t ) 0U;
  8029e4:	d0202a15 	stw	zero,-32600(gp)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  8029e8:	08006200 	call	800620 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  8029ec:	0001883a 	nop
  8029f0:	e037883a 	mov	sp,fp
  8029f4:	dfc00117 	ldw	ra,4(sp)
  8029f8:	df000017 	ldw	fp,0(sp)
  8029fc:	dec00204 	addi	sp,sp,8
  802a00:	f800283a 	ret

00802a04 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
  802a04:	defffd04 	addi	sp,sp,-12
  802a08:	dfc00215 	stw	ra,8(sp)
  802a0c:	df000115 	stw	fp,4(sp)
  802a10:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  802a14:	0005303a 	rdctl	r2,status
  802a18:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  802a1c:	e0ffff17 	ldw	r3,-4(fp)
  802a20:	00bfff84 	movi	r2,-2
  802a24:	1884703a 	and	r2,r3,r2
  802a28:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
  802a2c:	d0202c15 	stw	zero,-32592(gp)
	vPortEndScheduler();
  802a30:	08006580 	call	800658 <vPortEndScheduler>
}
  802a34:	0001883a 	nop
  802a38:	e037883a 	mov	sp,fp
  802a3c:	dfc00117 	ldw	ra,4(sp)
  802a40:	df000017 	ldw	fp,0(sp)
  802a44:	dec00204 	addi	sp,sp,8
  802a48:	f800283a 	ret

00802a4c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  802a4c:	deffff04 	addi	sp,sp,-4
  802a50:	df000015 	stw	fp,0(sp)
  802a54:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
  802a58:	d0a03317 	ldw	r2,-32564(gp)
  802a5c:	10800044 	addi	r2,r2,1
  802a60:	d0a03315 	stw	r2,-32564(gp)
}
  802a64:	0001883a 	nop
  802a68:	e037883a 	mov	sp,fp
  802a6c:	df000017 	ldw	fp,0(sp)
  802a70:	dec00104 	addi	sp,sp,4
  802a74:	f800283a 	ret

00802a78 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  802a78:	defffb04 	addi	sp,sp,-20
  802a7c:	dfc00415 	stw	ra,16(sp)
  802a80:	df000315 	stw	fp,12(sp)
  802a84:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
  802a88:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
  802a8c:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  802a90:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
  802a94:	d0a03317 	ldw	r2,-32564(gp)
  802a98:	10bfffc4 	addi	r2,r2,-1
  802a9c:	d0a03315 	stw	r2,-32564(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  802aa0:	d0a03317 	ldw	r2,-32564(gp)
  802aa4:	1000461e 	bne	r2,zero,802bc0 <xTaskResumeAll+0x148>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  802aa8:	d0a02917 	ldw	r2,-32604(gp)
  802aac:	10004426 	beq	r2,zero,802bc0 <xTaskResumeAll+0x148>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  802ab0:	00002906 	br	802b58 <xTaskResumeAll+0xe0>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
  802ab4:	008020f4 	movhi	r2,131
  802ab8:	10ad9f04 	addi	r2,r2,-18820
  802abc:	10800317 	ldw	r2,12(r2)
  802ac0:	10800317 	ldw	r2,12(r2)
  802ac4:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  802ac8:	e0bffd17 	ldw	r2,-12(fp)
  802acc:	10800604 	addi	r2,r2,24
  802ad0:	1009883a 	mov	r4,r2
  802ad4:	08004800 	call	800480 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  802ad8:	e0bffd17 	ldw	r2,-12(fp)
  802adc:	10800104 	addi	r2,r2,4
  802ae0:	1009883a 	mov	r4,r2
  802ae4:	08004800 	call	800480 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  802ae8:	e0bffd17 	ldw	r2,-12(fp)
  802aec:	10800b17 	ldw	r2,44(r2)
  802af0:	d0e02b17 	ldw	r3,-32596(gp)
  802af4:	1880032e 	bgeu	r3,r2,802b04 <xTaskResumeAll+0x8c>
  802af8:	e0bffd17 	ldw	r2,-12(fp)
  802afc:	10800b17 	ldw	r2,44(r2)
  802b00:	d0a02b15 	stw	r2,-32596(gp)
  802b04:	e0bffd17 	ldw	r2,-12(fp)
  802b08:	10800b17 	ldw	r2,44(r2)
  802b0c:	01400504 	movi	r5,20
  802b10:	1009883a 	mov	r4,r2
  802b14:	080b2480 	call	80b248 <__mulsi3>
  802b18:	1007883a 	mov	r3,r2
  802b1c:	008020f4 	movhi	r2,131
  802b20:	10ad7c04 	addi	r2,r2,-18960
  802b24:	1887883a 	add	r3,r3,r2
  802b28:	e0bffd17 	ldw	r2,-12(fp)
  802b2c:	10800104 	addi	r2,r2,4
  802b30:	100b883a 	mov	r5,r2
  802b34:	1809883a 	mov	r4,r3
  802b38:	080031c0 	call	80031c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  802b3c:	e0bffd17 	ldw	r2,-12(fp)
  802b40:	10c00b17 	ldw	r3,44(r2)
  802b44:	d0a02517 	ldw	r2,-32620(gp)
  802b48:	10800b17 	ldw	r2,44(r2)
  802b4c:	18800236 	bltu	r3,r2,802b58 <xTaskResumeAll+0xe0>
					{
						xYieldPending = pdTRUE;
  802b50:	00800044 	movi	r2,1
  802b54:	d0a02e15 	stw	r2,-32584(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  802b58:	008020f4 	movhi	r2,131
  802b5c:	10ad9f04 	addi	r2,r2,-18820
  802b60:	10800017 	ldw	r2,0(r2)
  802b64:	103fd31e 	bne	r2,zero,802ab4 <__alt_data_end+0xfff02ab4>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  802b68:	e0bffd17 	ldw	r2,-12(fp)
  802b6c:	10000126 	beq	r2,zero,802b74 <xTaskResumeAll+0xfc>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  802b70:	08035cc0 	call	8035cc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  802b74:	d0a02d17 	ldw	r2,-32588(gp)
  802b78:	e0bfff15 	stw	r2,-4(fp)

					if( uxPendedCounts > ( UBaseType_t ) 0U )
  802b7c:	e0bfff17 	ldw	r2,-4(fp)
  802b80:	10000a26 	beq	r2,zero,802bac <xTaskResumeAll+0x134>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  802b84:	0802c900 	call	802c90 <xTaskIncrementTick>
  802b88:	10000226 	beq	r2,zero,802b94 <xTaskResumeAll+0x11c>
							{
								xYieldPending = pdTRUE;
  802b8c:	00800044 	movi	r2,1
  802b90:	d0a02e15 	stw	r2,-32584(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
  802b94:	e0bfff17 	ldw	r2,-4(fp)
  802b98:	10bfffc4 	addi	r2,r2,-1
  802b9c:	e0bfff15 	stw	r2,-4(fp)
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  802ba0:	e0bfff17 	ldw	r2,-4(fp)
  802ba4:	103ff71e 	bne	r2,zero,802b84 <__alt_data_end+0xfff02b84>

						uxPendedTicks = 0;
  802ba8:	d0202d15 	stw	zero,-32588(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  802bac:	d0a02e17 	ldw	r2,-32584(gp)
  802bb0:	10000326 	beq	r2,zero,802bc0 <xTaskResumeAll+0x148>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  802bb4:	00800044 	movi	r2,1
  802bb8:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  802bbc:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  802bc0:	08039000 	call	803900 <vTaskExitCritical>

	return xAlreadyYielded;
  802bc4:	e0bffe17 	ldw	r2,-8(fp)
}
  802bc8:	e037883a 	mov	sp,fp
  802bcc:	dfc00117 	ldw	ra,4(sp)
  802bd0:	df000017 	ldw	fp,0(sp)
  802bd4:	dec00204 	addi	sp,sp,8
  802bd8:	f800283a 	ret

00802bdc <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  802bdc:	defffe04 	addi	sp,sp,-8
  802be0:	df000115 	stw	fp,4(sp)
  802be4:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  802be8:	d0a02a17 	ldw	r2,-32600(gp)
  802bec:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  802bf0:	e0bfff17 	ldw	r2,-4(fp)
}
  802bf4:	e037883a 	mov	sp,fp
  802bf8:	df000017 	ldw	fp,0(sp)
  802bfc:	dec00104 	addi	sp,sp,4
  802c00:	f800283a 	ret

00802c04 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
  802c04:	defffd04 	addi	sp,sp,-12
  802c08:	df000215 	stw	fp,8(sp)
  802c0c:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
  802c10:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
  802c14:	d0a02a17 	ldw	r2,-32600(gp)
  802c18:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  802c1c:	e0bfff17 	ldw	r2,-4(fp)
}
  802c20:	e037883a 	mov	sp,fp
  802c24:	df000017 	ldw	fp,0(sp)
  802c28:	dec00104 	addi	sp,sp,4
  802c2c:	f800283a 	ret

00802c30 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
  802c30:	deffff04 	addi	sp,sp,-4
  802c34:	df000015 	stw	fp,0(sp)
  802c38:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
  802c3c:	d0a02917 	ldw	r2,-32604(gp)
}
  802c40:	e037883a 	mov	sp,fp
  802c44:	df000017 	ldw	fp,0(sp)
  802c48:	dec00104 	addi	sp,sp,4
  802c4c:	f800283a 	ret

00802c50 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  802c50:	defffd04 	addi	sp,sp,-12
  802c54:	df000215 	stw	fp,8(sp)
  802c58:	df000204 	addi	fp,sp,8
  802c5c:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
  802c60:	e0bfff17 	ldw	r2,-4(fp)
  802c64:	1000021e 	bne	r2,zero,802c70 <pcTaskGetName+0x20>
  802c68:	d0a02517 	ldw	r2,-32620(gp)
  802c6c:	00000106 	br	802c74 <pcTaskGetName+0x24>
  802c70:	e0bfff17 	ldw	r2,-4(fp)
  802c74:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
  802c78:	e0bffe17 	ldw	r2,-8(fp)
  802c7c:	10800d04 	addi	r2,r2,52
}
  802c80:	e037883a 	mov	sp,fp
  802c84:	df000017 	ldw	fp,0(sp)
  802c88:	dec00104 	addi	sp,sp,4
  802c8c:	f800283a 	ret

00802c90 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  802c90:	defff804 	addi	sp,sp,-32
  802c94:	dfc00715 	stw	ra,28(sp)
  802c98:	df000615 	stw	fp,24(sp)
  802c9c:	dc000515 	stw	r16,20(sp)
  802ca0:	df000604 	addi	fp,sp,24
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  802ca4:	e03ffa15 	stw	zero,-24(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  802ca8:	d0a03317 	ldw	r2,-32564(gp)
  802cac:	1000621e 	bne	r2,zero,802e38 <xTaskIncrementTick+0x1a8>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
  802cb0:	d0a02a17 	ldw	r2,-32600(gp)
  802cb4:	10800044 	addi	r2,r2,1
  802cb8:	e0bffb15 	stw	r2,-20(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  802cbc:	e0bffb17 	ldw	r2,-20(fp)
  802cc0:	d0a02a15 	stw	r2,-32600(gp)

		if( xConstTickCount == ( TickType_t ) 0U )
  802cc4:	e0bffb17 	ldw	r2,-20(fp)
  802cc8:	10000a1e 	bne	r2,zero,802cf4 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
  802ccc:	d0a02617 	ldw	r2,-32616(gp)
  802cd0:	e0bffc15 	stw	r2,-16(fp)
  802cd4:	d0a02717 	ldw	r2,-32612(gp)
  802cd8:	d0a02615 	stw	r2,-32616(gp)
  802cdc:	e0bffc17 	ldw	r2,-16(fp)
  802ce0:	d0a02715 	stw	r2,-32612(gp)
  802ce4:	d0a02f17 	ldw	r2,-32580(gp)
  802ce8:	10800044 	addi	r2,r2,1
  802cec:	d0a02f15 	stw	r2,-32580(gp)
  802cf0:	08035cc0 	call	8035cc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  802cf4:	d0a03117 	ldw	r2,-32572(gp)
  802cf8:	e0fffb17 	ldw	r3,-20(fp)
  802cfc:	18804036 	bltu	r3,r2,802e00 <xTaskIncrementTick+0x170>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  802d00:	d0a02617 	ldw	r2,-32616(gp)
  802d04:	10800017 	ldw	r2,0(r2)
  802d08:	1000021e 	bne	r2,zero,802d14 <xTaskIncrementTick+0x84>
  802d0c:	00800044 	movi	r2,1
  802d10:	00000106 	br	802d18 <xTaskIncrementTick+0x88>
  802d14:	0005883a 	mov	r2,zero
  802d18:	10803fcc 	andi	r2,r2,255
  802d1c:	10000326 	beq	r2,zero,802d2c <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  802d20:	00bfffc4 	movi	r2,-1
  802d24:	d0a03115 	stw	r2,-32572(gp)
					break;
  802d28:	00003506 	br	802e00 <xTaskIncrementTick+0x170>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  802d2c:	d0a02617 	ldw	r2,-32616(gp)
  802d30:	10800317 	ldw	r2,12(r2)
  802d34:	10800317 	ldw	r2,12(r2)
  802d38:	e0bffd15 	stw	r2,-12(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  802d3c:	e0bffd17 	ldw	r2,-12(fp)
  802d40:	10800117 	ldw	r2,4(r2)
  802d44:	e0bffe15 	stw	r2,-8(fp)

					if( xConstTickCount < xItemValue )
  802d48:	e0fffb17 	ldw	r3,-20(fp)
  802d4c:	e0bffe17 	ldw	r2,-8(fp)
  802d50:	1880032e 	bgeu	r3,r2,802d60 <xTaskIncrementTick+0xd0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  802d54:	e0bffe17 	ldw	r2,-8(fp)
  802d58:	d0a03115 	stw	r2,-32572(gp)
						break;
  802d5c:	00002806 	br	802e00 <xTaskIncrementTick+0x170>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  802d60:	e0bffd17 	ldw	r2,-12(fp)
  802d64:	10800104 	addi	r2,r2,4
  802d68:	1009883a 	mov	r4,r2
  802d6c:	08004800 	call	800480 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  802d70:	e0bffd17 	ldw	r2,-12(fp)
  802d74:	10800a17 	ldw	r2,40(r2)
  802d78:	10000426 	beq	r2,zero,802d8c <xTaskIncrementTick+0xfc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  802d7c:	e0bffd17 	ldw	r2,-12(fp)
  802d80:	10800604 	addi	r2,r2,24
  802d84:	1009883a 	mov	r4,r2
  802d88:	08004800 	call	800480 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  802d8c:	e0bffd17 	ldw	r2,-12(fp)
  802d90:	10800b17 	ldw	r2,44(r2)
  802d94:	d0e02b17 	ldw	r3,-32596(gp)
  802d98:	1880032e 	bgeu	r3,r2,802da8 <xTaskIncrementTick+0x118>
  802d9c:	e0bffd17 	ldw	r2,-12(fp)
  802da0:	10800b17 	ldw	r2,44(r2)
  802da4:	d0a02b15 	stw	r2,-32596(gp)
  802da8:	e0bffd17 	ldw	r2,-12(fp)
  802dac:	10800b17 	ldw	r2,44(r2)
  802db0:	01400504 	movi	r5,20
  802db4:	1009883a 	mov	r4,r2
  802db8:	080b2480 	call	80b248 <__mulsi3>
  802dbc:	1007883a 	mov	r3,r2
  802dc0:	008020f4 	movhi	r2,131
  802dc4:	10ad7c04 	addi	r2,r2,-18960
  802dc8:	1887883a 	add	r3,r3,r2
  802dcc:	e0bffd17 	ldw	r2,-12(fp)
  802dd0:	10800104 	addi	r2,r2,4
  802dd4:	100b883a 	mov	r5,r2
  802dd8:	1809883a 	mov	r4,r3
  802ddc:	080031c0 	call	80031c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  802de0:	e0bffd17 	ldw	r2,-12(fp)
  802de4:	10c00b17 	ldw	r3,44(r2)
  802de8:	d0a02517 	ldw	r2,-32620(gp)
  802dec:	10800b17 	ldw	r2,44(r2)
  802df0:	18bfc336 	bltu	r3,r2,802d00 <__alt_data_end+0xfff02d00>
						{
							xSwitchRequired = pdTRUE;
  802df4:	00800044 	movi	r2,1
  802df8:	e0bffa15 	stw	r2,-24(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
  802dfc:	003fc006 	br	802d00 <__alt_data_end+0xfff02d00>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  802e00:	d0a02517 	ldw	r2,-32620(gp)
  802e04:	10800b17 	ldw	r2,44(r2)
  802e08:	040020f4 	movhi	r16,131
  802e0c:	842d7c04 	addi	r16,r16,-18960
  802e10:	01400504 	movi	r5,20
  802e14:	1009883a 	mov	r4,r2
  802e18:	080b2480 	call	80b248 <__mulsi3>
  802e1c:	8085883a 	add	r2,r16,r2
  802e20:	10800017 	ldw	r2,0(r2)
  802e24:	108000b0 	cmpltui	r2,r2,2
  802e28:	1000061e 	bne	r2,zero,802e44 <xTaskIncrementTick+0x1b4>
			{
				xSwitchRequired = pdTRUE;
  802e2c:	00800044 	movi	r2,1
  802e30:	e0bffa15 	stw	r2,-24(fp)
  802e34:	00000306 	br	802e44 <xTaskIncrementTick+0x1b4>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  802e38:	d0a02d17 	ldw	r2,-32588(gp)
  802e3c:	10800044 	addi	r2,r2,1
  802e40:	d0a02d15 	stw	r2,-32588(gp)
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  802e44:	d0a02e17 	ldw	r2,-32584(gp)
  802e48:	10000226 	beq	r2,zero,802e54 <xTaskIncrementTick+0x1c4>
		{
			xSwitchRequired = pdTRUE;
  802e4c:	00800044 	movi	r2,1
  802e50:	e0bffa15 	stw	r2,-24(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  802e54:	e0bffa17 	ldw	r2,-24(fp)
}
  802e58:	e6ffff04 	addi	sp,fp,-4
  802e5c:	dfc00217 	ldw	ra,8(sp)
  802e60:	df000117 	ldw	fp,4(sp)
  802e64:	dc000017 	ldw	r16,0(sp)
  802e68:	dec00304 	addi	sp,sp,12
  802e6c:	f800283a 	ret

00802e70 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  802e70:	defffb04 	addi	sp,sp,-20
  802e74:	dfc00415 	stw	ra,16(sp)
  802e78:	df000315 	stw	fp,12(sp)
  802e7c:	dc000215 	stw	r16,8(sp)
  802e80:	df000304 	addi	fp,sp,12
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  802e84:	d0a03317 	ldw	r2,-32564(gp)
  802e88:	10000326 	beq	r2,zero,802e98 <vTaskSwitchContext+0x28>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  802e8c:	00800044 	movi	r2,1
  802e90:	d0a02e15 	stw	r2,-32584(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  802e94:	00002d06 	br	802f4c <vTaskSwitchContext+0xdc>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
  802e98:	d0202e15 	stw	zero,-32584(gp)
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
  802e9c:	d0a02b17 	ldw	r2,-32596(gp)
  802ea0:	e0bffd15 	stw	r2,-12(fp)
  802ea4:	00000306 	br	802eb4 <vTaskSwitchContext+0x44>
  802ea8:	e0bffd17 	ldw	r2,-12(fp)
  802eac:	10bfffc4 	addi	r2,r2,-1
  802eb0:	e0bffd15 	stw	r2,-12(fp)
  802eb4:	040020f4 	movhi	r16,131
  802eb8:	842d7c04 	addi	r16,r16,-18960
  802ebc:	e0bffd17 	ldw	r2,-12(fp)
  802ec0:	01400504 	movi	r5,20
  802ec4:	1009883a 	mov	r4,r2
  802ec8:	080b2480 	call	80b248 <__mulsi3>
  802ecc:	8085883a 	add	r2,r16,r2
  802ed0:	10800017 	ldw	r2,0(r2)
  802ed4:	103ff426 	beq	r2,zero,802ea8 <__alt_data_end+0xfff02ea8>
  802ed8:	01400504 	movi	r5,20
  802edc:	e13ffd17 	ldw	r4,-12(fp)
  802ee0:	080b2480 	call	80b248 <__mulsi3>
  802ee4:	1007883a 	mov	r3,r2
  802ee8:	008020f4 	movhi	r2,131
  802eec:	10ad7c04 	addi	r2,r2,-18960
  802ef0:	1885883a 	add	r2,r3,r2
  802ef4:	e0bffe15 	stw	r2,-8(fp)
  802ef8:	e0bffe17 	ldw	r2,-8(fp)
  802efc:	10800117 	ldw	r2,4(r2)
  802f00:	10c00117 	ldw	r3,4(r2)
  802f04:	e0bffe17 	ldw	r2,-8(fp)
  802f08:	10c00115 	stw	r3,4(r2)
  802f0c:	e0bffe17 	ldw	r2,-8(fp)
  802f10:	10c00117 	ldw	r3,4(r2)
  802f14:	e0bffe17 	ldw	r2,-8(fp)
  802f18:	10800204 	addi	r2,r2,8
  802f1c:	1880051e 	bne	r3,r2,802f34 <vTaskSwitchContext+0xc4>
  802f20:	e0bffe17 	ldw	r2,-8(fp)
  802f24:	10800117 	ldw	r2,4(r2)
  802f28:	10c00117 	ldw	r3,4(r2)
  802f2c:	e0bffe17 	ldw	r2,-8(fp)
  802f30:	10c00115 	stw	r3,4(r2)
  802f34:	e0bffe17 	ldw	r2,-8(fp)
  802f38:	10800117 	ldw	r2,4(r2)
  802f3c:	10800317 	ldw	r2,12(r2)
  802f40:	d0a02515 	stw	r2,-32620(gp)
  802f44:	e0bffd17 	ldw	r2,-12(fp)
  802f48:	d0a02b15 	stw	r2,-32596(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  802f4c:	0001883a 	nop
  802f50:	e6ffff04 	addi	sp,fp,-4
  802f54:	dfc00217 	ldw	ra,8(sp)
  802f58:	df000117 	ldw	fp,4(sp)
  802f5c:	dc000017 	ldw	r16,0(sp)
  802f60:	dec00304 	addi	sp,sp,12
  802f64:	f800283a 	ret

00802f68 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  802f68:	defffc04 	addi	sp,sp,-16
  802f6c:	dfc00315 	stw	ra,12(sp)
  802f70:	df000215 	stw	fp,8(sp)
  802f74:	df000204 	addi	fp,sp,8
  802f78:	e13ffe15 	stw	r4,-8(fp)
  802f7c:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  802f80:	d0a02517 	ldw	r2,-32620(gp)
  802f84:	10800604 	addi	r2,r2,24
  802f88:	100b883a 	mov	r5,r2
  802f8c:	e13ffe17 	ldw	r4,-8(fp)
  802f90:	08003a80 	call	8003a8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  802f94:	01400044 	movi	r5,1
  802f98:	e13fff17 	ldw	r4,-4(fp)
  802f9c:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>
}
  802fa0:	0001883a 	nop
  802fa4:	e037883a 	mov	sp,fp
  802fa8:	dfc00117 	ldw	ra,4(sp)
  802fac:	df000017 	ldw	fp,0(sp)
  802fb0:	dec00204 	addi	sp,sp,8
  802fb4:	f800283a 	ret

00802fb8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
  802fb8:	defffb04 	addi	sp,sp,-20
  802fbc:	dfc00415 	stw	ra,16(sp)
  802fc0:	df000315 	stw	fp,12(sp)
  802fc4:	df000304 	addi	fp,sp,12
  802fc8:	e13ffd15 	stw	r4,-12(fp)
  802fcc:	e17ffe15 	stw	r5,-8(fp)
  802fd0:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  802fd4:	d0a02517 	ldw	r2,-32620(gp)
  802fd8:	e0fffe17 	ldw	r3,-8(fp)
  802fdc:	18e00034 	orhi	r3,r3,32768
  802fe0:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  802fe4:	d0a02517 	ldw	r2,-32620(gp)
  802fe8:	10800604 	addi	r2,r2,24
  802fec:	100b883a 	mov	r5,r2
  802ff0:	e13ffd17 	ldw	r4,-12(fp)
  802ff4:	080031c0 	call	80031c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  802ff8:	01400044 	movi	r5,1
  802ffc:	e13fff17 	ldw	r4,-4(fp)
  803000:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>
}
  803004:	0001883a 	nop
  803008:	e037883a 	mov	sp,fp
  80300c:	dfc00117 	ldw	ra,4(sp)
  803010:	df000017 	ldw	fp,0(sp)
  803014:	dec00204 	addi	sp,sp,8
  803018:	f800283a 	ret

0080301c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  80301c:	defffb04 	addi	sp,sp,-20
  803020:	dfc00415 	stw	ra,16(sp)
  803024:	df000315 	stw	fp,12(sp)
  803028:	df000304 	addi	fp,sp,12
  80302c:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  803030:	e0bfff17 	ldw	r2,-4(fp)
  803034:	10800317 	ldw	r2,12(r2)
  803038:	10800317 	ldw	r2,12(r2)
  80303c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  803040:	e0bffe17 	ldw	r2,-8(fp)
  803044:	10800604 	addi	r2,r2,24
  803048:	1009883a 	mov	r4,r2
  80304c:	08004800 	call	800480 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  803050:	d0a03317 	ldw	r2,-32564(gp)
  803054:	10001a1e 	bne	r2,zero,8030c0 <xTaskRemoveFromEventList+0xa4>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  803058:	e0bffe17 	ldw	r2,-8(fp)
  80305c:	10800104 	addi	r2,r2,4
  803060:	1009883a 	mov	r4,r2
  803064:	08004800 	call	800480 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  803068:	e0bffe17 	ldw	r2,-8(fp)
  80306c:	10800b17 	ldw	r2,44(r2)
  803070:	d0e02b17 	ldw	r3,-32596(gp)
  803074:	1880032e 	bgeu	r3,r2,803084 <xTaskRemoveFromEventList+0x68>
  803078:	e0bffe17 	ldw	r2,-8(fp)
  80307c:	10800b17 	ldw	r2,44(r2)
  803080:	d0a02b15 	stw	r2,-32596(gp)
  803084:	e0bffe17 	ldw	r2,-8(fp)
  803088:	10800b17 	ldw	r2,44(r2)
  80308c:	01400504 	movi	r5,20
  803090:	1009883a 	mov	r4,r2
  803094:	080b2480 	call	80b248 <__mulsi3>
  803098:	1007883a 	mov	r3,r2
  80309c:	008020f4 	movhi	r2,131
  8030a0:	10ad7c04 	addi	r2,r2,-18960
  8030a4:	1887883a 	add	r3,r3,r2
  8030a8:	e0bffe17 	ldw	r2,-8(fp)
  8030ac:	10800104 	addi	r2,r2,4
  8030b0:	100b883a 	mov	r5,r2
  8030b4:	1809883a 	mov	r4,r3
  8030b8:	080031c0 	call	80031c <vListInsertEnd>
  8030bc:	00000606 	br	8030d8 <xTaskRemoveFromEventList+0xbc>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  8030c0:	e0bffe17 	ldw	r2,-8(fp)
  8030c4:	10800604 	addi	r2,r2,24
  8030c8:	100b883a 	mov	r5,r2
  8030cc:	010020f4 	movhi	r4,131
  8030d0:	212d9f04 	addi	r4,r4,-18820
  8030d4:	080031c0 	call	80031c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  8030d8:	e0bffe17 	ldw	r2,-8(fp)
  8030dc:	10800b17 	ldw	r2,44(r2)
  8030e0:	d0e02517 	ldw	r3,-32620(gp)
  8030e4:	18c00b17 	ldw	r3,44(r3)
  8030e8:	1880052e 	bgeu	r3,r2,803100 <xTaskRemoveFromEventList+0xe4>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  8030ec:	00800044 	movi	r2,1
  8030f0:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  8030f4:	00800044 	movi	r2,1
  8030f8:	d0a02e15 	stw	r2,-32584(gp)
  8030fc:	00000106 	br	803104 <xTaskRemoveFromEventList+0xe8>
	}
	else
	{
		xReturn = pdFALSE;
  803100:	e03ffd15 	stw	zero,-12(fp)
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
  803104:	e0bffd17 	ldw	r2,-12(fp)
}
  803108:	e037883a 	mov	sp,fp
  80310c:	dfc00117 	ldw	ra,4(sp)
  803110:	df000017 	ldw	fp,0(sp)
  803114:	dec00204 	addi	sp,sp,8
  803118:	f800283a 	ret

0080311c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
  80311c:	defffa04 	addi	sp,sp,-24
  803120:	dfc00515 	stw	ra,20(sp)
  803124:	df000415 	stw	fp,16(sp)
  803128:	df000404 	addi	fp,sp,16
  80312c:	e13ffe15 	stw	r4,-8(fp)
  803130:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  803134:	e0bfff17 	ldw	r2,-4(fp)
  803138:	10e00034 	orhi	r3,r2,32768
  80313c:	e0bffe17 	ldw	r2,-8(fp)
  803140:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
  803144:	e0bffe17 	ldw	r2,-8(fp)
  803148:	10800317 	ldw	r2,12(r2)
  80314c:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
  803150:	e13ffe17 	ldw	r4,-8(fp)
  803154:	08004800 	call	800480 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  803158:	e0bffd17 	ldw	r2,-12(fp)
  80315c:	10800104 	addi	r2,r2,4
  803160:	1009883a 	mov	r4,r2
  803164:	08004800 	call	800480 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
  803168:	e0bffd17 	ldw	r2,-12(fp)
  80316c:	10800b17 	ldw	r2,44(r2)
  803170:	d0e02b17 	ldw	r3,-32596(gp)
  803174:	1880032e 	bgeu	r3,r2,803184 <xTaskRemoveFromUnorderedEventList+0x68>
  803178:	e0bffd17 	ldw	r2,-12(fp)
  80317c:	10800b17 	ldw	r2,44(r2)
  803180:	d0a02b15 	stw	r2,-32596(gp)
  803184:	e0bffd17 	ldw	r2,-12(fp)
  803188:	10800b17 	ldw	r2,44(r2)
  80318c:	01400504 	movi	r5,20
  803190:	1009883a 	mov	r4,r2
  803194:	080b2480 	call	80b248 <__mulsi3>
  803198:	1007883a 	mov	r3,r2
  80319c:	008020f4 	movhi	r2,131
  8031a0:	10ad7c04 	addi	r2,r2,-18960
  8031a4:	1887883a 	add	r3,r3,r2
  8031a8:	e0bffd17 	ldw	r2,-12(fp)
  8031ac:	10800104 	addi	r2,r2,4
  8031b0:	100b883a 	mov	r5,r2
  8031b4:	1809883a 	mov	r4,r3
  8031b8:	080031c0 	call	80031c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  8031bc:	e0bffd17 	ldw	r2,-12(fp)
  8031c0:	10800b17 	ldw	r2,44(r2)
  8031c4:	d0e02517 	ldw	r3,-32620(gp)
  8031c8:	18c00b17 	ldw	r3,44(r3)
  8031cc:	1880052e 	bgeu	r3,r2,8031e4 <xTaskRemoveFromUnorderedEventList+0xc8>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  8031d0:	00800044 	movi	r2,1
  8031d4:	e0bffc15 	stw	r2,-16(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  8031d8:	00800044 	movi	r2,1
  8031dc:	d0a02e15 	stw	r2,-32584(gp)
  8031e0:	00000106 	br	8031e8 <xTaskRemoveFromUnorderedEventList+0xcc>
	}
	else
	{
		xReturn = pdFALSE;
  8031e4:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  8031e8:	e0bffc17 	ldw	r2,-16(fp)
}
  8031ec:	e037883a 	mov	sp,fp
  8031f0:	dfc00117 	ldw	ra,4(sp)
  8031f4:	df000017 	ldw	fp,0(sp)
  8031f8:	dec00204 	addi	sp,sp,8
  8031fc:	f800283a 	ret

00803200 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  803200:	defffe04 	addi	sp,sp,-8
  803204:	df000115 	stw	fp,4(sp)
  803208:	df000104 	addi	fp,sp,4
  80320c:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  803210:	d0e02f17 	ldw	r3,-32580(gp)
  803214:	e0bfff17 	ldw	r2,-4(fp)
  803218:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
  80321c:	d0e02a17 	ldw	r3,-32600(gp)
  803220:	e0bfff17 	ldw	r2,-4(fp)
  803224:	10c00115 	stw	r3,4(r2)
}
  803228:	0001883a 	nop
  80322c:	e037883a 	mov	sp,fp
  803230:	df000017 	ldw	fp,0(sp)
  803234:	dec00104 	addi	sp,sp,4
  803238:	f800283a 	ret

0080323c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  80323c:	defffa04 	addi	sp,sp,-24
  803240:	dfc00515 	stw	ra,20(sp)
  803244:	df000415 	stw	fp,16(sp)
  803248:	df000404 	addi	fp,sp,16
  80324c:	e13ffe15 	stw	r4,-8(fp)
  803250:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  803254:	08038ac0 	call	8038ac <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  803258:	d0a02a17 	ldw	r2,-32600(gp)
  80325c:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  803260:	e0bfff17 	ldw	r2,-4(fp)
  803264:	10800017 	ldw	r2,0(r2)
  803268:	10bfffd8 	cmpnei	r2,r2,-1
  80326c:	1000021e 	bne	r2,zero,803278 <xTaskCheckForTimeOut+0x3c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  803270:	e03ffc15 	stw	zero,-16(fp)
  803274:	00002106 	br	8032fc <xTaskCheckForTimeOut+0xc0>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  803278:	e0bffe17 	ldw	r2,-8(fp)
  80327c:	10c00017 	ldw	r3,0(r2)
  803280:	d0a02f17 	ldw	r2,-32580(gp)
  803284:	18800726 	beq	r3,r2,8032a4 <xTaskCheckForTimeOut+0x68>
  803288:	e0bffe17 	ldw	r2,-8(fp)
  80328c:	10800117 	ldw	r2,4(r2)
  803290:	e0fffd17 	ldw	r3,-12(fp)
  803294:	18800336 	bltu	r3,r2,8032a4 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  803298:	00800044 	movi	r2,1
  80329c:	e0bffc15 	stw	r2,-16(fp)
  8032a0:	00001606 	br	8032fc <xTaskCheckForTimeOut+0xc0>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  8032a4:	e0bffe17 	ldw	r2,-8(fp)
  8032a8:	10800117 	ldw	r2,4(r2)
  8032ac:	e0fffd17 	ldw	r3,-12(fp)
  8032b0:	1887c83a 	sub	r3,r3,r2
  8032b4:	e0bfff17 	ldw	r2,-4(fp)
  8032b8:	10800017 	ldw	r2,0(r2)
  8032bc:	18800d2e 	bgeu	r3,r2,8032f4 <xTaskCheckForTimeOut+0xb8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
  8032c0:	e0bfff17 	ldw	r2,-4(fp)
  8032c4:	10c00017 	ldw	r3,0(r2)
  8032c8:	e0bffe17 	ldw	r2,-8(fp)
  8032cc:	11000117 	ldw	r4,4(r2)
  8032d0:	e0bffd17 	ldw	r2,-12(fp)
  8032d4:	2085c83a 	sub	r2,r4,r2
  8032d8:	1887883a 	add	r3,r3,r2
  8032dc:	e0bfff17 	ldw	r2,-4(fp)
  8032e0:	10c00015 	stw	r3,0(r2)
			vTaskSetTimeOutState( pxTimeOut );
  8032e4:	e13ffe17 	ldw	r4,-8(fp)
  8032e8:	08032000 	call	803200 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
  8032ec:	e03ffc15 	stw	zero,-16(fp)
  8032f0:	00000206 	br	8032fc <xTaskCheckForTimeOut+0xc0>
		}
		else
		{
			xReturn = pdTRUE;
  8032f4:	00800044 	movi	r2,1
  8032f8:	e0bffc15 	stw	r2,-16(fp)
		}
	}
	taskEXIT_CRITICAL();
  8032fc:	08039000 	call	803900 <vTaskExitCritical>

	return xReturn;
  803300:	e0bffc17 	ldw	r2,-16(fp)
}
  803304:	e037883a 	mov	sp,fp
  803308:	dfc00117 	ldw	ra,4(sp)
  80330c:	df000017 	ldw	fp,0(sp)
  803310:	dec00204 	addi	sp,sp,8
  803314:	f800283a 	ret

00803318 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  803318:	deffff04 	addi	sp,sp,-4
  80331c:	df000015 	stw	fp,0(sp)
  803320:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
  803324:	00800044 	movi	r2,1
  803328:	d0a02e15 	stw	r2,-32584(gp)
}
  80332c:	0001883a 	nop
  803330:	e037883a 	mov	sp,fp
  803334:	df000017 	ldw	fp,0(sp)
  803338:	dec00104 	addi	sp,sp,4
  80333c:	f800283a 	ret

00803340 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  803340:	defffd04 	addi	sp,sp,-12
  803344:	dfc00215 	stw	ra,8(sp)
  803348:	df000115 	stw	fp,4(sp)
  80334c:	df000104 	addi	fp,sp,4
  803350:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  803354:	080341c0 	call	80341c <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  803358:	003ffe06 	br	803354 <__alt_data_end+0xfff03354>

0080335c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  80335c:	defffd04 	addi	sp,sp,-12
  803360:	dfc00215 	stw	ra,8(sp)
  803364:	df000115 	stw	fp,4(sp)
  803368:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  80336c:	e03fff15 	stw	zero,-4(fp)
  803370:	00000c06 	br	8033a4 <prvInitialiseTaskLists+0x48>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  803374:	01400504 	movi	r5,20
  803378:	e13fff17 	ldw	r4,-4(fp)
  80337c:	080b2480 	call	80b248 <__mulsi3>
  803380:	1007883a 	mov	r3,r2
  803384:	008020f4 	movhi	r2,131
  803388:	10ad7c04 	addi	r2,r2,-18960
  80338c:	1885883a 	add	r2,r3,r2
  803390:	1009883a 	mov	r4,r2
  803394:	08002880 	call	800288 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  803398:	e0bfff17 	ldw	r2,-4(fp)
  80339c:	10800044 	addi	r2,r2,1
  8033a0:	e0bfff15 	stw	r2,-4(fp)
  8033a4:	e0bfff17 	ldw	r2,-4(fp)
  8033a8:	10800170 	cmpltui	r2,r2,5
  8033ac:	103ff11e 	bne	r2,zero,803374 <__alt_data_end+0xfff03374>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  8033b0:	010020f4 	movhi	r4,131
  8033b4:	212d9504 	addi	r4,r4,-18860
  8033b8:	08002880 	call	800288 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  8033bc:	010020f4 	movhi	r4,131
  8033c0:	212d9a04 	addi	r4,r4,-18840
  8033c4:	08002880 	call	800288 <vListInitialise>
	vListInitialise( &xPendingReadyList );
  8033c8:	010020f4 	movhi	r4,131
  8033cc:	212d9f04 	addi	r4,r4,-18820
  8033d0:	08002880 	call	800288 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  8033d4:	010020f4 	movhi	r4,131
  8033d8:	212da404 	addi	r4,r4,-18800
  8033dc:	08002880 	call	800288 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  8033e0:	010020f4 	movhi	r4,131
  8033e4:	212da904 	addi	r4,r4,-18780
  8033e8:	08002880 	call	800288 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  8033ec:	008020f4 	movhi	r2,131
  8033f0:	10ad9504 	addi	r2,r2,-18860
  8033f4:	d0a02615 	stw	r2,-32616(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  8033f8:	008020f4 	movhi	r2,131
  8033fc:	10ad9a04 	addi	r2,r2,-18840
  803400:	d0a02715 	stw	r2,-32612(gp)
}
  803404:	0001883a 	nop
  803408:	e037883a 	mov	sp,fp
  80340c:	dfc00117 	ldw	ra,4(sp)
  803410:	df000017 	ldw	fp,0(sp)
  803414:	dec00204 	addi	sp,sp,8
  803418:	f800283a 	ret

0080341c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  80341c:	defffc04 	addi	sp,sp,-16
  803420:	dfc00315 	stw	ra,12(sp)
  803424:	df000215 	stw	fp,8(sp)
  803428:	df000204 	addi	fp,sp,8
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  80342c:	00001d06 	br	8034a4 <prvCheckTasksWaitingTermination+0x88>
		{
			vTaskSuspendAll();
  803430:	0802a4c0 	call	802a4c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  803434:	008020f4 	movhi	r2,131
  803438:	10ada404 	addi	r2,r2,-18800
  80343c:	10800017 	ldw	r2,0(r2)
  803440:	1005003a 	cmpeq	r2,r2,zero
  803444:	10803fcc 	andi	r2,r2,255
  803448:	e0bffe15 	stw	r2,-8(fp)
			}
			( void ) xTaskResumeAll();
  80344c:	0802a780 	call	802a78 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
  803450:	e0bffe17 	ldw	r2,-8(fp)
  803454:	1000131e 	bne	r2,zero,8034a4 <prvCheckTasksWaitingTermination+0x88>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
  803458:	08038ac0 	call	8038ac <vTaskEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
  80345c:	008020f4 	movhi	r2,131
  803460:	10ada404 	addi	r2,r2,-18800
  803464:	10800317 	ldw	r2,12(r2)
  803468:	10800317 	ldw	r2,12(r2)
  80346c:	e0bfff15 	stw	r2,-4(fp)
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803470:	e0bfff17 	ldw	r2,-4(fp)
  803474:	10800104 	addi	r2,r2,4
  803478:	1009883a 	mov	r4,r2
  80347c:	08004800 	call	800480 <uxListRemove>
					--uxCurrentNumberOfTasks;
  803480:	d0a02917 	ldw	r2,-32604(gp)
  803484:	10bfffc4 	addi	r2,r2,-1
  803488:	d0a02915 	stw	r2,-32604(gp)
					--uxDeletedTasksWaitingCleanUp;
  80348c:	d0a02817 	ldw	r2,-32608(gp)
  803490:	10bfffc4 	addi	r2,r2,-1
  803494:	d0a02815 	stw	r2,-32608(gp)
				}
				taskEXIT_CRITICAL();
  803498:	08039000 	call	803900 <vTaskExitCritical>

				prvDeleteTCB( pxTCB );
  80349c:	e13fff17 	ldw	r4,-4(fp)
  8034a0:	08035880 	call	803588 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  8034a4:	d0a02817 	ldw	r2,-32608(gp)
  8034a8:	103fe11e 	bne	r2,zero,803430 <__alt_data_end+0xfff03430>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  8034ac:	0001883a 	nop
  8034b0:	e037883a 	mov	sp,fp
  8034b4:	dfc00117 	ldw	ra,4(sp)
  8034b8:	df000017 	ldw	fp,0(sp)
  8034bc:	dec00204 	addi	sp,sp,8
  8034c0:	f800283a 	ret

008034c4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
  8034c4:	defffd04 	addi	sp,sp,-12
  8034c8:	df000215 	stw	fp,8(sp)
  8034cc:	df000204 	addi	fp,sp,8
  8034d0:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
  8034d4:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  8034d8:	00000606 	br	8034f4 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
  8034dc:	e0bfff17 	ldw	r2,-4(fp)
  8034e0:	10800044 	addi	r2,r2,1
  8034e4:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
  8034e8:	e0bffe17 	ldw	r2,-8(fp)
  8034ec:	10800044 	addi	r2,r2,1
  8034f0:	e0bffe15 	stw	r2,-8(fp)

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  8034f4:	e0bfff17 	ldw	r2,-4(fp)
  8034f8:	10800003 	ldbu	r2,0(r2)
  8034fc:	10803fcc 	andi	r2,r2,255
  803500:	10802960 	cmpeqi	r2,r2,165
  803504:	103ff51e 	bne	r2,zero,8034dc <__alt_data_end+0xfff034dc>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
  803508:	e0bffe17 	ldw	r2,-8(fp)
  80350c:	1004d0ba 	srli	r2,r2,2
  803510:	e0bffe15 	stw	r2,-8(fp)

		return ( uint16_t ) ulCount;
  803514:	e0bffe17 	ldw	r2,-8(fp)
	}
  803518:	e037883a 	mov	sp,fp
  80351c:	df000017 	ldw	fp,0(sp)
  803520:	dec00104 	addi	sp,sp,4
  803524:	f800283a 	ret

00803528 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
  803528:	defffa04 	addi	sp,sp,-24
  80352c:	dfc00515 	stw	ra,20(sp)
  803530:	df000415 	stw	fp,16(sp)
  803534:	df000404 	addi	fp,sp,16
  803538:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
  80353c:	e0bfff17 	ldw	r2,-4(fp)
  803540:	1000021e 	bne	r2,zero,80354c <uxTaskGetStackHighWaterMark+0x24>
  803544:	d0a02517 	ldw	r2,-32620(gp)
  803548:	00000106 	br	803550 <uxTaskGetStackHighWaterMark+0x28>
  80354c:	e0bfff17 	ldw	r2,-4(fp)
  803550:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
  803554:	e0bffc17 	ldw	r2,-16(fp)
  803558:	10800c17 	ldw	r2,48(r2)
  80355c:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
  803560:	e13ffd17 	ldw	r4,-12(fp)
  803564:	08034c40 	call	8034c4 <prvTaskCheckFreeStackSpace>
  803568:	10bfffcc 	andi	r2,r2,65535
  80356c:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
  803570:	e0bffe17 	ldw	r2,-8(fp)
	}
  803574:	e037883a 	mov	sp,fp
  803578:	dfc00117 	ldw	ra,4(sp)
  80357c:	df000017 	ldw	fp,0(sp)
  803580:	dec00204 	addi	sp,sp,8
  803584:	f800283a 	ret

00803588 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  803588:	defffd04 	addi	sp,sp,-12
  80358c:	dfc00215 	stw	ra,8(sp)
  803590:	df000115 	stw	fp,4(sp)
  803594:	df000104 	addi	fp,sp,4
  803598:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
  80359c:	e0bfff17 	ldw	r2,-4(fp)
  8035a0:	10800c17 	ldw	r2,48(r2)
  8035a4:	1009883a 	mov	r4,r2
  8035a8:	0800b680 	call	800b68 <vPortFree>
			vPortFree( pxTCB );
  8035ac:	e13fff17 	ldw	r4,-4(fp)
  8035b0:	0800b680 	call	800b68 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
  8035b4:	0001883a 	nop
  8035b8:	e037883a 	mov	sp,fp
  8035bc:	dfc00117 	ldw	ra,4(sp)
  8035c0:	df000017 	ldw	fp,0(sp)
  8035c4:	dec00204 	addi	sp,sp,8
  8035c8:	f800283a 	ret

008035cc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  8035cc:	defffe04 	addi	sp,sp,-8
  8035d0:	df000115 	stw	fp,4(sp)
  8035d4:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  8035d8:	d0a02617 	ldw	r2,-32616(gp)
  8035dc:	10800017 	ldw	r2,0(r2)
  8035e0:	1000021e 	bne	r2,zero,8035ec <prvResetNextTaskUnblockTime+0x20>
  8035e4:	00800044 	movi	r2,1
  8035e8:	00000106 	br	8035f0 <prvResetNextTaskUnblockTime+0x24>
  8035ec:	0005883a 	mov	r2,zero
  8035f0:	10803fcc 	andi	r2,r2,255
  8035f4:	10000326 	beq	r2,zero,803604 <prvResetNextTaskUnblockTime+0x38>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  8035f8:	00bfffc4 	movi	r2,-1
  8035fc:	d0a03115 	stw	r2,-32572(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  803600:	00000706 	br	803620 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  803604:	d0a02617 	ldw	r2,-32616(gp)
  803608:	10800317 	ldw	r2,12(r2)
  80360c:	10800317 	ldw	r2,12(r2)
  803610:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  803614:	e0bfff17 	ldw	r2,-4(fp)
  803618:	10800117 	ldw	r2,4(r2)
  80361c:	d0a03115 	stw	r2,-32572(gp)
	}
}
  803620:	0001883a 	nop
  803624:	e037883a 	mov	sp,fp
  803628:	df000017 	ldw	fp,0(sp)
  80362c:	dec00104 	addi	sp,sp,4
  803630:	f800283a 	ret

00803634 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
  803634:	defffe04 	addi	sp,sp,-8
  803638:	df000115 	stw	fp,4(sp)
  80363c:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  803640:	d0a02517 	ldw	r2,-32620(gp)
  803644:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
  803648:	e0bfff17 	ldw	r2,-4(fp)
	}
  80364c:	e037883a 	mov	sp,fp
  803650:	df000017 	ldw	fp,0(sp)
  803654:	dec00104 	addi	sp,sp,4
  803658:	f800283a 	ret

0080365c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  80365c:	defffb04 	addi	sp,sp,-20
  803660:	dfc00415 	stw	ra,16(sp)
  803664:	df000315 	stw	fp,12(sp)
  803668:	dc000215 	stw	r16,8(sp)
  80366c:	df000304 	addi	fp,sp,12
  803670:	e13ffe15 	stw	r4,-8(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  803674:	e0bffe17 	ldw	r2,-8(fp)
  803678:	e0bffd15 	stw	r2,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  80367c:	e0bffe17 	ldw	r2,-8(fp)
  803680:	10004126 	beq	r2,zero,803788 <vTaskPriorityInherit+0x12c>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  803684:	e0bffd17 	ldw	r2,-12(fp)
  803688:	10c00b17 	ldw	r3,44(r2)
  80368c:	d0a02517 	ldw	r2,-32620(gp)
  803690:	10800b17 	ldw	r2,44(r2)
  803694:	18803c2e 	bgeu	r3,r2,803788 <vTaskPriorityInherit+0x12c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  803698:	e0bffd17 	ldw	r2,-12(fp)
  80369c:	10800617 	ldw	r2,24(r2)
  8036a0:	10000616 	blt	r2,zero,8036bc <vTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  8036a4:	d0a02517 	ldw	r2,-32620(gp)
  8036a8:	10800b17 	ldw	r2,44(r2)
  8036ac:	00c00144 	movi	r3,5
  8036b0:	1887c83a 	sub	r3,r3,r2
  8036b4:	e0bffd17 	ldw	r2,-12(fp)
  8036b8:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  8036bc:	e0bffd17 	ldw	r2,-12(fp)
  8036c0:	14000517 	ldw	r16,20(r2)
  8036c4:	e0bffd17 	ldw	r2,-12(fp)
  8036c8:	10800b17 	ldw	r2,44(r2)
  8036cc:	01400504 	movi	r5,20
  8036d0:	1009883a 	mov	r4,r2
  8036d4:	080b2480 	call	80b248 <__mulsi3>
  8036d8:	1007883a 	mov	r3,r2
  8036dc:	008020f4 	movhi	r2,131
  8036e0:	10ad7c04 	addi	r2,r2,-18960
  8036e4:	1885883a 	add	r2,r3,r2
  8036e8:	8080021e 	bne	r16,r2,8036f4 <vTaskPriorityInherit+0x98>
  8036ec:	00800044 	movi	r2,1
  8036f0:	00000106 	br	8036f8 <vTaskPriorityInherit+0x9c>
  8036f4:	0005883a 	mov	r2,zero
  8036f8:	10803fcc 	andi	r2,r2,255
  8036fc:	10001e26 	beq	r2,zero,803778 <vTaskPriorityInherit+0x11c>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803700:	e0bffd17 	ldw	r2,-12(fp)
  803704:	10800104 	addi	r2,r2,4
  803708:	1009883a 	mov	r4,r2
  80370c:	08004800 	call	800480 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  803710:	d0a02517 	ldw	r2,-32620(gp)
  803714:	10c00b17 	ldw	r3,44(r2)
  803718:	e0bffd17 	ldw	r2,-12(fp)
  80371c:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxTCB );
  803720:	e0bffd17 	ldw	r2,-12(fp)
  803724:	10800b17 	ldw	r2,44(r2)
  803728:	d0e02b17 	ldw	r3,-32596(gp)
  80372c:	1880032e 	bgeu	r3,r2,80373c <vTaskPriorityInherit+0xe0>
  803730:	e0bffd17 	ldw	r2,-12(fp)
  803734:	10800b17 	ldw	r2,44(r2)
  803738:	d0a02b15 	stw	r2,-32596(gp)
  80373c:	e0bffd17 	ldw	r2,-12(fp)
  803740:	10800b17 	ldw	r2,44(r2)
  803744:	01400504 	movi	r5,20
  803748:	1009883a 	mov	r4,r2
  80374c:	080b2480 	call	80b248 <__mulsi3>
  803750:	1007883a 	mov	r3,r2
  803754:	008020f4 	movhi	r2,131
  803758:	10ad7c04 	addi	r2,r2,-18960
  80375c:	1887883a 	add	r3,r3,r2
  803760:	e0bffd17 	ldw	r2,-12(fp)
  803764:	10800104 	addi	r2,r2,4
  803768:	100b883a 	mov	r5,r2
  80376c:	1809883a 	mov	r4,r3
  803770:	080031c0 	call	80031c <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803774:	00000406 	br	803788 <vTaskPriorityInherit+0x12c>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  803778:	d0a02517 	ldw	r2,-32620(gp)
  80377c:	10c00b17 	ldw	r3,44(r2)
  803780:	e0bffd17 	ldw	r2,-12(fp)
  803784:	10c00b15 	stw	r3,44(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803788:	0001883a 	nop
  80378c:	e6ffff04 	addi	sp,fp,-4
  803790:	dfc00217 	ldw	ra,8(sp)
  803794:	df000117 	ldw	fp,4(sp)
  803798:	dc000017 	ldw	r16,0(sp)
  80379c:	dec00304 	addi	sp,sp,12
  8037a0:	f800283a 	ret

008037a4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  8037a4:	defffb04 	addi	sp,sp,-20
  8037a8:	dfc00415 	stw	ra,16(sp)
  8037ac:	df000315 	stw	fp,12(sp)
  8037b0:	df000304 	addi	fp,sp,12
  8037b4:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
  8037b8:	e0bfff17 	ldw	r2,-4(fp)
  8037bc:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
  8037c0:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
  8037c4:	e0bfff17 	ldw	r2,-4(fp)
  8037c8:	10003226 	beq	r2,zero,803894 <xTaskPriorityDisinherit+0xf0>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
  8037cc:	e0bffe17 	ldw	r2,-8(fp)
  8037d0:	10801117 	ldw	r2,68(r2)
  8037d4:	10ffffc4 	addi	r3,r2,-1
  8037d8:	e0bffe17 	ldw	r2,-8(fp)
  8037dc:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  8037e0:	e0bffe17 	ldw	r2,-8(fp)
  8037e4:	10c00b17 	ldw	r3,44(r2)
  8037e8:	e0bffe17 	ldw	r2,-8(fp)
  8037ec:	10801017 	ldw	r2,64(r2)
  8037f0:	18802826 	beq	r3,r2,803894 <xTaskPriorityDisinherit+0xf0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  8037f4:	e0bffe17 	ldw	r2,-8(fp)
  8037f8:	10801117 	ldw	r2,68(r2)
  8037fc:	1000251e 	bne	r2,zero,803894 <xTaskPriorityDisinherit+0xf0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803800:	e0bffe17 	ldw	r2,-8(fp)
  803804:	10800104 	addi	r2,r2,4
  803808:	1009883a 	mov	r4,r2
  80380c:	08004800 	call	800480 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  803810:	e0bffe17 	ldw	r2,-8(fp)
  803814:	10c01017 	ldw	r3,64(r2)
  803818:	e0bffe17 	ldw	r2,-8(fp)
  80381c:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  803820:	e0bffe17 	ldw	r2,-8(fp)
  803824:	10800b17 	ldw	r2,44(r2)
  803828:	00c00144 	movi	r3,5
  80382c:	1887c83a 	sub	r3,r3,r2
  803830:	e0bffe17 	ldw	r2,-8(fp)
  803834:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
  803838:	e0bffe17 	ldw	r2,-8(fp)
  80383c:	10800b17 	ldw	r2,44(r2)
  803840:	d0e02b17 	ldw	r3,-32596(gp)
  803844:	1880032e 	bgeu	r3,r2,803854 <xTaskPriorityDisinherit+0xb0>
  803848:	e0bffe17 	ldw	r2,-8(fp)
  80384c:	10800b17 	ldw	r2,44(r2)
  803850:	d0a02b15 	stw	r2,-32596(gp)
  803854:	e0bffe17 	ldw	r2,-8(fp)
  803858:	10800b17 	ldw	r2,44(r2)
  80385c:	01400504 	movi	r5,20
  803860:	1009883a 	mov	r4,r2
  803864:	080b2480 	call	80b248 <__mulsi3>
  803868:	1007883a 	mov	r3,r2
  80386c:	008020f4 	movhi	r2,131
  803870:	10ad7c04 	addi	r2,r2,-18960
  803874:	1887883a 	add	r3,r3,r2
  803878:	e0bffe17 	ldw	r2,-8(fp)
  80387c:	10800104 	addi	r2,r2,4
  803880:	100b883a 	mov	r5,r2
  803884:	1809883a 	mov	r4,r3
  803888:	080031c0 	call	80031c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  80388c:	00800044 	movi	r2,1
  803890:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  803894:	e0bffd17 	ldw	r2,-12(fp)
	}
  803898:	e037883a 	mov	sp,fp
  80389c:	dfc00117 	ldw	ra,4(sp)
  8038a0:	df000017 	ldw	fp,0(sp)
  8038a4:	dec00204 	addi	sp,sp,8
  8038a8:	f800283a 	ret

008038ac <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
  8038ac:	defffe04 	addi	sp,sp,-8
  8038b0:	df000115 	stw	fp,4(sp)
  8038b4:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8038b8:	0005303a 	rdctl	r2,status
  8038bc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8038c0:	e0ffff17 	ldw	r3,-4(fp)
  8038c4:	00bfff84 	movi	r2,-2
  8038c8:	1884703a 	and	r2,r3,r2
  8038cc:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
  8038d0:	d0a02c17 	ldw	r2,-32592(gp)
  8038d4:	10000526 	beq	r2,zero,8038ec <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
  8038d8:	d0a02517 	ldw	r2,-32620(gp)
  8038dc:	10c00f17 	ldw	r3,60(r2)
  8038e0:	18c00044 	addi	r3,r3,1
  8038e4:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
  8038e8:	d0a02517 	ldw	r2,-32620(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8038ec:	0001883a 	nop
  8038f0:	e037883a 	mov	sp,fp
  8038f4:	df000017 	ldw	fp,0(sp)
  8038f8:	dec00104 	addi	sp,sp,4
  8038fc:	f800283a 	ret

00803900 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
  803900:	defffe04 	addi	sp,sp,-8
  803904:	df000115 	stw	fp,4(sp)
  803908:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
  80390c:	d0a02c17 	ldw	r2,-32592(gp)
  803910:	10000e26 	beq	r2,zero,80394c <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
  803914:	d0a02517 	ldw	r2,-32620(gp)
  803918:	10800f17 	ldw	r2,60(r2)
  80391c:	10000b26 	beq	r2,zero,80394c <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
  803920:	d0a02517 	ldw	r2,-32620(gp)
  803924:	10c00f17 	ldw	r3,60(r2)
  803928:	18ffffc4 	addi	r3,r3,-1
  80392c:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
  803930:	d0a02517 	ldw	r2,-32620(gp)
  803934:	10800f17 	ldw	r2,60(r2)
  803938:	1000041e 	bne	r2,zero,80394c <vTaskExitCritical+0x4c>
  80393c:	00800044 	movi	r2,1
  803940:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  803944:	e0bfff17 	ldw	r2,-4(fp)
  803948:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  80394c:	0001883a 	nop
  803950:	e037883a 	mov	sp,fp
  803954:	df000017 	ldw	fp,0(sp)
  803958:	dec00104 	addi	sp,sp,4
  80395c:	f800283a 	ret

00803960 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
  803960:	defffe04 	addi	sp,sp,-8
  803964:	df000115 	stw	fp,4(sp)
  803968:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
  80396c:	d0a02517 	ldw	r2,-32620(gp)
  803970:	10800617 	ldw	r2,24(r2)
  803974:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  803978:	d0a02517 	ldw	r2,-32620(gp)
  80397c:	d0e02517 	ldw	r3,-32620(gp)
  803980:	18c00b17 	ldw	r3,44(r3)
  803984:	01000144 	movi	r4,5
  803988:	20c7c83a 	sub	r3,r4,r3
  80398c:	10c00615 	stw	r3,24(r2)

	return uxReturn;
  803990:	e0bfff17 	ldw	r2,-4(fp)
}
  803994:	e037883a 	mov	sp,fp
  803998:	df000017 	ldw	fp,0(sp)
  80399c:	dec00104 	addi	sp,sp,4
  8039a0:	f800283a 	ret

008039a4 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
  8039a4:	deffff04 	addi	sp,sp,-4
  8039a8:	df000015 	stw	fp,0(sp)
  8039ac:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  8039b0:	d0a02517 	ldw	r2,-32620(gp)
  8039b4:	10000426 	beq	r2,zero,8039c8 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  8039b8:	d0a02517 	ldw	r2,-32620(gp)
  8039bc:	10c01117 	ldw	r3,68(r2)
  8039c0:	18c00044 	addi	r3,r3,1
  8039c4:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
  8039c8:	d0a02517 	ldw	r2,-32620(gp)
	}
  8039cc:	e037883a 	mov	sp,fp
  8039d0:	df000017 	ldw	fp,0(sp)
  8039d4:	dec00104 	addi	sp,sp,4
  8039d8:	f800283a 	ret

008039dc <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
  8039dc:	defffb04 	addi	sp,sp,-20
  8039e0:	dfc00415 	stw	ra,16(sp)
  8039e4:	df000315 	stw	fp,12(sp)
  8039e8:	df000304 	addi	fp,sp,12
  8039ec:	e13ffe15 	stw	r4,-8(fp)
  8039f0:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
  8039f4:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
  8039f8:	d0a02517 	ldw	r2,-32620(gp)
  8039fc:	10801217 	ldw	r2,72(r2)
  803a00:	1000091e 	bne	r2,zero,803a28 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  803a04:	d0a02517 	ldw	r2,-32620(gp)
  803a08:	00c00044 	movi	r3,1
  803a0c:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  803a10:	e0bfff17 	ldw	r2,-4(fp)
  803a14:	10000426 	beq	r2,zero,803a28 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  803a18:	01400044 	movi	r5,1
  803a1c:	e13fff17 	ldw	r4,-4(fp)
  803a20:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  803a24:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  803a28:	08039000 	call	803900 <vTaskExitCritical>

		taskENTER_CRITICAL();
  803a2c:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  803a30:	d0a02517 	ldw	r2,-32620(gp)
  803a34:	10801217 	ldw	r2,72(r2)
  803a38:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
  803a3c:	e0bffd17 	ldw	r2,-12(fp)
  803a40:	10000926 	beq	r2,zero,803a68 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
  803a44:	e0bffe17 	ldw	r2,-8(fp)
  803a48:	10000326 	beq	r2,zero,803a58 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
  803a4c:	d0a02517 	ldw	r2,-32620(gp)
  803a50:	10001215 	stw	zero,72(r2)
  803a54:	00000406 	br	803a68 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
  803a58:	d0a02517 	ldw	r2,-32620(gp)
  803a5c:	e0fffd17 	ldw	r3,-12(fp)
  803a60:	18ffffc4 	addi	r3,r3,-1
  803a64:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  803a68:	d0a02517 	ldw	r2,-32620(gp)
  803a6c:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  803a70:	08039000 	call	803900 <vTaskExitCritical>

		return ulReturn;
  803a74:	e0bffd17 	ldw	r2,-12(fp)
	}
  803a78:	e037883a 	mov	sp,fp
  803a7c:	dfc00117 	ldw	ra,4(sp)
  803a80:	df000017 	ldw	fp,0(sp)
  803a84:	dec00204 	addi	sp,sp,8
  803a88:	f800283a 	ret

00803a8c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
  803a8c:	defff904 	addi	sp,sp,-28
  803a90:	dfc00615 	stw	ra,24(sp)
  803a94:	df000515 	stw	fp,20(sp)
  803a98:	df000504 	addi	fp,sp,20
  803a9c:	e13ffc15 	stw	r4,-16(fp)
  803aa0:	e17ffd15 	stw	r5,-12(fp)
  803aa4:	e1bffe15 	stw	r6,-8(fp)
  803aa8:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
  803aac:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
  803ab0:	d0a02517 	ldw	r2,-32620(gp)
  803ab4:	10801303 	ldbu	r2,76(r2)
  803ab8:	10803fcc 	andi	r2,r2,255
  803abc:	108000a0 	cmpeqi	r2,r2,2
  803ac0:	10000f1e 	bne	r2,zero,803b00 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
  803ac4:	d0a02517 	ldw	r2,-32620(gp)
  803ac8:	11001217 	ldw	r4,72(r2)
  803acc:	e0fffc17 	ldw	r3,-16(fp)
  803ad0:	00c6303a 	nor	r3,zero,r3
  803ad4:	20c6703a 	and	r3,r4,r3
  803ad8:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  803adc:	d0a02517 	ldw	r2,-32620(gp)
  803ae0:	00c00044 	movi	r3,1
  803ae4:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  803ae8:	e0bfff17 	ldw	r2,-4(fp)
  803aec:	10000426 	beq	r2,zero,803b00 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  803af0:	01400044 	movi	r5,1
  803af4:	e13fff17 	ldw	r4,-4(fp)
  803af8:	08040c40 	call	8040c4 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  803afc:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  803b00:	08039000 	call	803900 <vTaskExitCritical>

		taskENTER_CRITICAL();
  803b04:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
  803b08:	e0bffe17 	ldw	r2,-8(fp)
  803b0c:	10000426 	beq	r2,zero,803b20 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
  803b10:	d0a02517 	ldw	r2,-32620(gp)
  803b14:	10c01217 	ldw	r3,72(r2)
  803b18:	e0bffe17 	ldw	r2,-8(fp)
  803b1c:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
  803b20:	d0a02517 	ldw	r2,-32620(gp)
  803b24:	10801303 	ldbu	r2,76(r2)
  803b28:	10803fcc 	andi	r2,r2,255
  803b2c:	10800058 	cmpnei	r2,r2,1
  803b30:	1000021e 	bne	r2,zero,803b3c <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
  803b34:	e03ffb15 	stw	zero,-20(fp)
  803b38:	00000806 	br	803b5c <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
  803b3c:	d0a02517 	ldw	r2,-32620(gp)
  803b40:	11001217 	ldw	r4,72(r2)
  803b44:	e0fffd17 	ldw	r3,-12(fp)
  803b48:	00c6303a 	nor	r3,zero,r3
  803b4c:	20c6703a 	and	r3,r4,r3
  803b50:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
  803b54:	00800044 	movi	r2,1
  803b58:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  803b5c:	d0a02517 	ldw	r2,-32620(gp)
  803b60:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  803b64:	08039000 	call	803900 <vTaskExitCritical>

		return xReturn;
  803b68:	e0bffb17 	ldw	r2,-20(fp)
	}
  803b6c:	e037883a 	mov	sp,fp
  803b70:	dfc00117 	ldw	ra,4(sp)
  803b74:	df000017 	ldw	fp,0(sp)
  803b78:	dec00204 	addi	sp,sp,8
  803b7c:	f800283a 	ret

00803b80 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
  803b80:	defff704 	addi	sp,sp,-36
  803b84:	dfc00815 	stw	ra,32(sp)
  803b88:	df000715 	stw	fp,28(sp)
  803b8c:	df000704 	addi	fp,sp,28
  803b90:	e13ffc15 	stw	r4,-16(fp)
  803b94:	e17ffd15 	stw	r5,-12(fp)
  803b98:	e1bffe15 	stw	r6,-8(fp)
  803b9c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
  803ba0:	00800044 	movi	r2,1
  803ba4:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
  803ba8:	e0bffc17 	ldw	r2,-16(fp)
  803bac:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
  803bb0:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
  803bb4:	e0bfff17 	ldw	r2,-4(fp)
  803bb8:	10000426 	beq	r2,zero,803bcc <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  803bbc:	e0bffa17 	ldw	r2,-24(fp)
  803bc0:	10c01217 	ldw	r3,72(r2)
  803bc4:	e0bfff17 	ldw	r2,-4(fp)
  803bc8:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  803bcc:	e0bffa17 	ldw	r2,-24(fp)
  803bd0:	10801303 	ldbu	r2,76(r2)
  803bd4:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  803bd8:	e0bffa17 	ldw	r2,-24(fp)
  803bdc:	00c00084 	movi	r3,2
  803be0:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  803be4:	e0bffe17 	ldw	r2,-8(fp)
  803be8:	10800168 	cmpgeui	r2,r2,5
  803bec:	1000271e 	bne	r2,zero,803c8c <xTaskGenericNotify+0x10c>
  803bf0:	e0bffe17 	ldw	r2,-8(fp)
  803bf4:	100690ba 	slli	r3,r2,2
  803bf8:	00802034 	movhi	r2,128
  803bfc:	108f0304 	addi	r2,r2,15372
  803c00:	1885883a 	add	r2,r3,r2
  803c04:	10800017 	ldw	r2,0(r2)
  803c08:	1000683a 	jmp	r2
  803c0c:	00803c88 	cmpgei	r2,zero,242
  803c10:	00803c20 	cmpeqi	r2,zero,240
  803c14:	00803c3c 	xorhi	r2,zero,240
  803c18:	00803c54 	movui	r2,241
  803c1c:	00803c64 	muli	r2,zero,241
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  803c20:	e0bffa17 	ldw	r2,-24(fp)
  803c24:	10c01217 	ldw	r3,72(r2)
  803c28:	e0bffd17 	ldw	r2,-12(fp)
  803c2c:	1886b03a 	or	r3,r3,r2
  803c30:	e0bffa17 	ldw	r2,-24(fp)
  803c34:	10c01215 	stw	r3,72(r2)
					break;
  803c38:	00001406 	br	803c8c <xTaskGenericNotify+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  803c3c:	e0bffa17 	ldw	r2,-24(fp)
  803c40:	10801217 	ldw	r2,72(r2)
  803c44:	10c00044 	addi	r3,r2,1
  803c48:	e0bffa17 	ldw	r2,-24(fp)
  803c4c:	10c01215 	stw	r3,72(r2)
					break;
  803c50:	00000e06 	br	803c8c <xTaskGenericNotify+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  803c54:	e0bffa17 	ldw	r2,-24(fp)
  803c58:	e0fffd17 	ldw	r3,-12(fp)
  803c5c:	10c01215 	stw	r3,72(r2)
					break;
  803c60:	00000a06 	br	803c8c <xTaskGenericNotify+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  803c64:	e0bffb03 	ldbu	r2,-20(fp)
  803c68:	108000a0 	cmpeqi	r2,r2,2
  803c6c:	1000041e 	bne	r2,zero,803c80 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  803c70:	e0bffa17 	ldw	r2,-24(fp)
  803c74:	e0fffd17 	ldw	r3,-12(fp)
  803c78:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  803c7c:	00000306 	br	803c8c <xTaskGenericNotify+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  803c80:	e03ff915 	stw	zero,-28(fp)
					}
					break;
  803c84:	00000106 	br	803c8c <xTaskGenericNotify+0x10c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
  803c88:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  803c8c:	e0bffb03 	ldbu	r2,-20(fp)
  803c90:	10800058 	cmpnei	r2,r2,1
  803c94:	10001f1e 	bne	r2,zero,803d14 <xTaskGenericNotify+0x194>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803c98:	e0bffa17 	ldw	r2,-24(fp)
  803c9c:	10800104 	addi	r2,r2,4
  803ca0:	1009883a 	mov	r4,r2
  803ca4:	08004800 	call	800480 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
  803ca8:	e0bffa17 	ldw	r2,-24(fp)
  803cac:	10800b17 	ldw	r2,44(r2)
  803cb0:	d0e02b17 	ldw	r3,-32596(gp)
  803cb4:	1880032e 	bgeu	r3,r2,803cc4 <xTaskGenericNotify+0x144>
  803cb8:	e0bffa17 	ldw	r2,-24(fp)
  803cbc:	10800b17 	ldw	r2,44(r2)
  803cc0:	d0a02b15 	stw	r2,-32596(gp)
  803cc4:	e0bffa17 	ldw	r2,-24(fp)
  803cc8:	10800b17 	ldw	r2,44(r2)
  803ccc:	01400504 	movi	r5,20
  803cd0:	1009883a 	mov	r4,r2
  803cd4:	080b2480 	call	80b248 <__mulsi3>
  803cd8:	1007883a 	mov	r3,r2
  803cdc:	008020f4 	movhi	r2,131
  803ce0:	10ad7c04 	addi	r2,r2,-18960
  803ce4:	1887883a 	add	r3,r3,r2
  803ce8:	e0bffa17 	ldw	r2,-24(fp)
  803cec:	10800104 	addi	r2,r2,4
  803cf0:	100b883a 	mov	r5,r2
  803cf4:	1809883a 	mov	r4,r3
  803cf8:	080031c0 	call	80031c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  803cfc:	e0bffa17 	ldw	r2,-24(fp)
  803d00:	10800b17 	ldw	r2,44(r2)
  803d04:	d0e02517 	ldw	r3,-32620(gp)
  803d08:	18c00b17 	ldw	r3,44(r3)
  803d0c:	1880012e 	bgeu	r3,r2,803d14 <xTaskGenericNotify+0x194>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
  803d10:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  803d14:	08039000 	call	803900 <vTaskExitCritical>

		return xReturn;
  803d18:	e0bff917 	ldw	r2,-28(fp)
	}
  803d1c:	e037883a 	mov	sp,fp
  803d20:	dfc00117 	ldw	ra,4(sp)
  803d24:	df000017 	ldw	fp,0(sp)
  803d28:	dec00204 	addi	sp,sp,8
  803d2c:	f800283a 	ret

00803d30 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
  803d30:	defff604 	addi	sp,sp,-40
  803d34:	dfc00915 	stw	ra,36(sp)
  803d38:	df000815 	stw	fp,32(sp)
  803d3c:	df000804 	addi	fp,sp,32
  803d40:	e13ffc15 	stw	r4,-16(fp)
  803d44:	e17ffd15 	stw	r5,-12(fp)
  803d48:	e1bffe15 	stw	r6,-8(fp)
  803d4c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
  803d50:	00800044 	movi	r2,1
  803d54:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
  803d58:	e0bffc17 	ldw	r2,-16(fp)
  803d5c:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  803d60:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
  803d64:	e0bfff17 	ldw	r2,-4(fp)
  803d68:	10000426 	beq	r2,zero,803d7c <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  803d6c:	e0bff917 	ldw	r2,-28(fp)
  803d70:	10c01217 	ldw	r3,72(r2)
  803d74:	e0bfff17 	ldw	r2,-4(fp)
  803d78:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  803d7c:	e0bff917 	ldw	r2,-28(fp)
  803d80:	10801303 	ldbu	r2,76(r2)
  803d84:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  803d88:	e0bff917 	ldw	r2,-28(fp)
  803d8c:	00c00084 	movi	r3,2
  803d90:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  803d94:	e0bffe17 	ldw	r2,-8(fp)
  803d98:	10800168 	cmpgeui	r2,r2,5
  803d9c:	1000271e 	bne	r2,zero,803e3c <xTaskGenericNotifyFromISR+0x10c>
  803da0:	e0bffe17 	ldw	r2,-8(fp)
  803da4:	100690ba 	slli	r3,r2,2
  803da8:	00802034 	movhi	r2,128
  803dac:	108f6f04 	addi	r2,r2,15804
  803db0:	1885883a 	add	r2,r3,r2
  803db4:	10800017 	ldw	r2,0(r2)
  803db8:	1000683a 	jmp	r2
  803dbc:	00803e38 	rdprs	r2,zero,248
  803dc0:	00803dd0 	cmplti	r2,zero,247
  803dc4:	00803dec 	andhi	r2,zero,247
  803dc8:	00803e04 	movi	r2,248
  803dcc:	00803e14 	movui	r2,248
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  803dd0:	e0bff917 	ldw	r2,-28(fp)
  803dd4:	10c01217 	ldw	r3,72(r2)
  803dd8:	e0bffd17 	ldw	r2,-12(fp)
  803ddc:	1886b03a 	or	r3,r3,r2
  803de0:	e0bff917 	ldw	r2,-28(fp)
  803de4:	10c01215 	stw	r3,72(r2)
					break;
  803de8:	00001406 	br	803e3c <xTaskGenericNotifyFromISR+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  803dec:	e0bff917 	ldw	r2,-28(fp)
  803df0:	10801217 	ldw	r2,72(r2)
  803df4:	10c00044 	addi	r3,r2,1
  803df8:	e0bff917 	ldw	r2,-28(fp)
  803dfc:	10c01215 	stw	r3,72(r2)
					break;
  803e00:	00000e06 	br	803e3c <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  803e04:	e0bff917 	ldw	r2,-28(fp)
  803e08:	e0fffd17 	ldw	r3,-12(fp)
  803e0c:	10c01215 	stw	r3,72(r2)
					break;
  803e10:	00000a06 	br	803e3c <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  803e14:	e0bffb03 	ldbu	r2,-20(fp)
  803e18:	108000a0 	cmpeqi	r2,r2,2
  803e1c:	1000041e 	bne	r2,zero,803e30 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  803e20:	e0bff917 	ldw	r2,-28(fp)
  803e24:	e0fffd17 	ldw	r3,-12(fp)
  803e28:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  803e2c:	00000306 	br	803e3c <xTaskGenericNotifyFromISR+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  803e30:	e03ff815 	stw	zero,-32(fp)
					}
					break;
  803e34:	00000106 	br	803e3c <xTaskGenericNotifyFromISR+0x10c>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
  803e38:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  803e3c:	e0bffb03 	ldbu	r2,-20(fp)
  803e40:	10800058 	cmpnei	r2,r2,1
  803e44:	10002f1e 	bne	r2,zero,803f04 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  803e48:	d0a03317 	ldw	r2,-32564(gp)
  803e4c:	10001a1e 	bne	r2,zero,803eb8 <xTaskGenericNotifyFromISR+0x188>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803e50:	e0bff917 	ldw	r2,-28(fp)
  803e54:	10800104 	addi	r2,r2,4
  803e58:	1009883a 	mov	r4,r2
  803e5c:	08004800 	call	800480 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803e60:	e0bff917 	ldw	r2,-28(fp)
  803e64:	10800b17 	ldw	r2,44(r2)
  803e68:	d0e02b17 	ldw	r3,-32596(gp)
  803e6c:	1880032e 	bgeu	r3,r2,803e7c <xTaskGenericNotifyFromISR+0x14c>
  803e70:	e0bff917 	ldw	r2,-28(fp)
  803e74:	10800b17 	ldw	r2,44(r2)
  803e78:	d0a02b15 	stw	r2,-32596(gp)
  803e7c:	e0bff917 	ldw	r2,-28(fp)
  803e80:	10800b17 	ldw	r2,44(r2)
  803e84:	01400504 	movi	r5,20
  803e88:	1009883a 	mov	r4,r2
  803e8c:	080b2480 	call	80b248 <__mulsi3>
  803e90:	1007883a 	mov	r3,r2
  803e94:	008020f4 	movhi	r2,131
  803e98:	10ad7c04 	addi	r2,r2,-18960
  803e9c:	1887883a 	add	r3,r3,r2
  803ea0:	e0bff917 	ldw	r2,-28(fp)
  803ea4:	10800104 	addi	r2,r2,4
  803ea8:	100b883a 	mov	r5,r2
  803eac:	1809883a 	mov	r4,r3
  803eb0:	080031c0 	call	80031c <vListInsertEnd>
  803eb4:	00000606 	br	803ed0 <xTaskGenericNotifyFromISR+0x1a0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  803eb8:	e0bff917 	ldw	r2,-28(fp)
  803ebc:	10800604 	addi	r2,r2,24
  803ec0:	100b883a 	mov	r5,r2
  803ec4:	010020f4 	movhi	r4,131
  803ec8:	212d9f04 	addi	r4,r4,-18820
  803ecc:	080031c0 	call	80031c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  803ed0:	e0bff917 	ldw	r2,-28(fp)
  803ed4:	10800b17 	ldw	r2,44(r2)
  803ed8:	d0e02517 	ldw	r3,-32620(gp)
  803edc:	18c00b17 	ldw	r3,44(r3)
  803ee0:	1880082e 	bgeu	r3,r2,803f04 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  803ee4:	e0800217 	ldw	r2,8(fp)
  803ee8:	10000426 	beq	r2,zero,803efc <xTaskGenericNotifyFromISR+0x1cc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  803eec:	e0800217 	ldw	r2,8(fp)
  803ef0:	00c00044 	movi	r3,1
  803ef4:	10c00015 	stw	r3,0(r2)
  803ef8:	00000206 	br	803f04 <xTaskGenericNotifyFromISR+0x1d4>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
  803efc:	00800044 	movi	r2,1
  803f00:	d0a02e15 	stw	r2,-32584(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
  803f04:	e0bff817 	ldw	r2,-32(fp)
	}
  803f08:	e037883a 	mov	sp,fp
  803f0c:	dfc00117 	ldw	ra,4(sp)
  803f10:	df000017 	ldw	fp,0(sp)
  803f14:	dec00204 	addi	sp,sp,8
  803f18:	f800283a 	ret

00803f1c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
  803f1c:	defff904 	addi	sp,sp,-28
  803f20:	dfc00615 	stw	ra,24(sp)
  803f24:	df000515 	stw	fp,20(sp)
  803f28:	df000504 	addi	fp,sp,20
  803f2c:	e13ffe15 	stw	r4,-8(fp)
  803f30:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
  803f34:	e0bffe17 	ldw	r2,-8(fp)
  803f38:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  803f3c:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
  803f40:	e0bffb17 	ldw	r2,-20(fp)
  803f44:	10801303 	ldbu	r2,76(r2)
  803f48:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  803f4c:	e0bffb17 	ldw	r2,-20(fp)
  803f50:	00c00084 	movi	r3,2
  803f54:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
  803f58:	e0bffb17 	ldw	r2,-20(fp)
  803f5c:	10801217 	ldw	r2,72(r2)
  803f60:	10c00044 	addi	r3,r2,1
  803f64:	e0bffb17 	ldw	r2,-20(fp)
  803f68:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  803f6c:	e0bffd03 	ldbu	r2,-12(fp)
  803f70:	10800058 	cmpnei	r2,r2,1
  803f74:	10002f1e 	bne	r2,zero,804034 <vTaskNotifyGiveFromISR+0x118>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  803f78:	d0a03317 	ldw	r2,-32564(gp)
  803f7c:	10001a1e 	bne	r2,zero,803fe8 <vTaskNotifyGiveFromISR+0xcc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803f80:	e0bffb17 	ldw	r2,-20(fp)
  803f84:	10800104 	addi	r2,r2,4
  803f88:	1009883a 	mov	r4,r2
  803f8c:	08004800 	call	800480 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803f90:	e0bffb17 	ldw	r2,-20(fp)
  803f94:	10800b17 	ldw	r2,44(r2)
  803f98:	d0e02b17 	ldw	r3,-32596(gp)
  803f9c:	1880032e 	bgeu	r3,r2,803fac <vTaskNotifyGiveFromISR+0x90>
  803fa0:	e0bffb17 	ldw	r2,-20(fp)
  803fa4:	10800b17 	ldw	r2,44(r2)
  803fa8:	d0a02b15 	stw	r2,-32596(gp)
  803fac:	e0bffb17 	ldw	r2,-20(fp)
  803fb0:	10800b17 	ldw	r2,44(r2)
  803fb4:	01400504 	movi	r5,20
  803fb8:	1009883a 	mov	r4,r2
  803fbc:	080b2480 	call	80b248 <__mulsi3>
  803fc0:	1007883a 	mov	r3,r2
  803fc4:	008020f4 	movhi	r2,131
  803fc8:	10ad7c04 	addi	r2,r2,-18960
  803fcc:	1887883a 	add	r3,r3,r2
  803fd0:	e0bffb17 	ldw	r2,-20(fp)
  803fd4:	10800104 	addi	r2,r2,4
  803fd8:	100b883a 	mov	r5,r2
  803fdc:	1809883a 	mov	r4,r3
  803fe0:	080031c0 	call	80031c <vListInsertEnd>
  803fe4:	00000606 	br	804000 <vTaskNotifyGiveFromISR+0xe4>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  803fe8:	e0bffb17 	ldw	r2,-20(fp)
  803fec:	10800604 	addi	r2,r2,24
  803ff0:	100b883a 	mov	r5,r2
  803ff4:	010020f4 	movhi	r4,131
  803ff8:	212d9f04 	addi	r4,r4,-18820
  803ffc:	080031c0 	call	80031c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  804000:	e0bffb17 	ldw	r2,-20(fp)
  804004:	10800b17 	ldw	r2,44(r2)
  804008:	d0e02517 	ldw	r3,-32620(gp)
  80400c:	18c00b17 	ldw	r3,44(r3)
  804010:	1880082e 	bgeu	r3,r2,804034 <vTaskNotifyGiveFromISR+0x118>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  804014:	e0bfff17 	ldw	r2,-4(fp)
  804018:	10000426 	beq	r2,zero,80402c <vTaskNotifyGiveFromISR+0x110>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  80401c:	e0bfff17 	ldw	r2,-4(fp)
  804020:	00c00044 	movi	r3,1
  804024:	10c00015 	stw	r3,0(r2)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
  804028:	00000206 	br	804034 <vTaskNotifyGiveFromISR+0x118>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
  80402c:	00800044 	movi	r2,1
  804030:	d0a02e15 	stw	r2,-32584(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
  804034:	0001883a 	nop
  804038:	e037883a 	mov	sp,fp
  80403c:	dfc00117 	ldw	ra,4(sp)
  804040:	df000017 	ldw	fp,0(sp)
  804044:	dec00204 	addi	sp,sp,8
  804048:	f800283a 	ret

0080404c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
  80404c:	defffb04 	addi	sp,sp,-20
  804050:	dfc00415 	stw	ra,16(sp)
  804054:	df000315 	stw	fp,12(sp)
  804058:	df000304 	addi	fp,sp,12
  80405c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
  804060:	e0bfff17 	ldw	r2,-4(fp)
  804064:	1000021e 	bne	r2,zero,804070 <xTaskNotifyStateClear+0x24>
  804068:	d0a02517 	ldw	r2,-32620(gp)
  80406c:	00000106 	br	804074 <xTaskNotifyStateClear+0x28>
  804070:	e0bfff17 	ldw	r2,-4(fp)
  804074:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
  804078:	08038ac0 	call	8038ac <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
  80407c:	e0bffe17 	ldw	r2,-8(fp)
  804080:	10801303 	ldbu	r2,76(r2)
  804084:	10803fcc 	andi	r2,r2,255
  804088:	10800098 	cmpnei	r2,r2,2
  80408c:	1000051e 	bne	r2,zero,8040a4 <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  804090:	e0bffe17 	ldw	r2,-8(fp)
  804094:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
  804098:	00800044 	movi	r2,1
  80409c:	e0bffd15 	stw	r2,-12(fp)
  8040a0:	00000106 	br	8040a8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
  8040a4:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
  8040a8:	08039000 	call	803900 <vTaskExitCritical>

		return xReturn;
  8040ac:	e0bffd17 	ldw	r2,-12(fp)
	}
  8040b0:	e037883a 	mov	sp,fp
  8040b4:	dfc00117 	ldw	ra,4(sp)
  8040b8:	df000017 	ldw	fp,0(sp)
  8040bc:	dec00204 	addi	sp,sp,8
  8040c0:	f800283a 	ret

008040c4 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  8040c4:	defffa04 	addi	sp,sp,-24
  8040c8:	dfc00515 	stw	ra,20(sp)
  8040cc:	df000415 	stw	fp,16(sp)
  8040d0:	df000404 	addi	fp,sp,16
  8040d4:	e13ffe15 	stw	r4,-8(fp)
  8040d8:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  8040dc:	d0a02a17 	ldw	r2,-32600(gp)
  8040e0:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  8040e4:	d0a02517 	ldw	r2,-32620(gp)
  8040e8:	10800104 	addi	r2,r2,4
  8040ec:	1009883a 	mov	r4,r2
  8040f0:	08004800 	call	800480 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  8040f4:	e0bffe17 	ldw	r2,-8(fp)
  8040f8:	10bfffd8 	cmpnei	r2,r2,-1
  8040fc:	1000091e 	bne	r2,zero,804124 <prvAddCurrentTaskToDelayedList+0x60>
  804100:	e0bfff17 	ldw	r2,-4(fp)
  804104:	10000726 	beq	r2,zero,804124 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  804108:	d0a02517 	ldw	r2,-32620(gp)
  80410c:	10800104 	addi	r2,r2,4
  804110:	100b883a 	mov	r5,r2
  804114:	010020f4 	movhi	r4,131
  804118:	212da904 	addi	r4,r4,-18780
  80411c:	080031c0 	call	80031c <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  804120:	00001c06 	br	804194 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  804124:	e0fffc17 	ldw	r3,-16(fp)
  804128:	e0bffe17 	ldw	r2,-8(fp)
  80412c:	1885883a 	add	r2,r3,r2
  804130:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  804134:	d0a02517 	ldw	r2,-32620(gp)
  804138:	e0fffd17 	ldw	r3,-12(fp)
  80413c:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
  804140:	e0fffd17 	ldw	r3,-12(fp)
  804144:	e0bffc17 	ldw	r2,-16(fp)
  804148:	1880072e 	bgeu	r3,r2,804168 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  80414c:	d0e02717 	ldw	r3,-32612(gp)
  804150:	d0a02517 	ldw	r2,-32620(gp)
  804154:	10800104 	addi	r2,r2,4
  804158:	100b883a 	mov	r5,r2
  80415c:	1809883a 	mov	r4,r3
  804160:	08003a80 	call	8003a8 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  804164:	00000b06 	br	804194 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  804168:	d0e02617 	ldw	r3,-32616(gp)
  80416c:	d0a02517 	ldw	r2,-32620(gp)
  804170:	10800104 	addi	r2,r2,4
  804174:	100b883a 	mov	r5,r2
  804178:	1809883a 	mov	r4,r3
  80417c:	08003a80 	call	8003a8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  804180:	d0a03117 	ldw	r2,-32572(gp)
  804184:	e0fffd17 	ldw	r3,-12(fp)
  804188:	1880022e 	bgeu	r3,r2,804194 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
  80418c:	e0bffd17 	ldw	r2,-12(fp)
  804190:	d0a03115 	stw	r2,-32572(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  804194:	0001883a 	nop
  804198:	e037883a 	mov	sp,fp
  80419c:	dfc00117 	ldw	ra,4(sp)
  8041a0:	df000017 	ldw	fp,0(sp)
  8041a4:	dec00204 	addi	sp,sp,8
  8041a8:	f800283a 	ret

008041ac <LoadFont>:


FontList	FntList[NumOfFont];


int LoadFont(void){
  8041ac:	deffff04 	addi	sp,sp,-4
  8041b0:	df000015 	stw	fp,0(sp)
  8041b4:	d839883a 	mov	fp,sp

	int height,width;

	FntList[0].pFnt=(GFXfont *)&FreeMono9pt7b;
  8041b8:	008020f4 	movhi	r2,131
  8041bc:	10adae04 	addi	r2,r2,-18760
  8041c0:	00c02074 	movhi	r3,129
  8041c4:	18ca5104 	addi	r3,r3,10564
  8041c8:	10c00015 	stw	r3,0(r2)
	strcpy(FntList[0].FontName,"Mono9pt7b\0");
  8041cc:	008020f4 	movhi	r2,131
  8041d0:	10adaf04 	addi	r2,r2,-18756
  8041d4:	00dbdbb4 	movhi	r3,28526
  8041d8:	18dbd344 	addi	r3,r3,28493
  8041dc:	10c00015 	stw	r3,0(r2)
  8041e0:	00cddd34 	movhi	r3,14196
  8041e4:	18dc0e44 	addi	r3,r3,28729
  8041e8:	10c00115 	stw	r3,4(r2)
  8041ec:	00c01884 	movi	r3,98
  8041f0:	10c0020d 	sth	r3,8(r2)

	FntList[1].pFnt=(GFXfont *)&FreeMonoBold18pt7b;
  8041f4:	008020f4 	movhi	r2,131
  8041f8:	10adae04 	addi	r2,r2,-18760
  8041fc:	00c02074 	movhi	r3,129
  804200:	18cecc04 	addi	r3,r3,15152
  804204:	10c00515 	stw	r3,20(r2)
	strcpy(FntList[1].FontName,"MonoBold18pt7b\0");
  804208:	008020f4 	movhi	r2,131
  80420c:	10adb404 	addi	r2,r2,-18736
  804210:	00dbdbb4 	movhi	r3,28526
  804214:	18dbd344 	addi	r3,r3,28493
  804218:	10c00015 	stw	r3,0(r2)
  80421c:	00d91b34 	movhi	r3,25708
  804220:	18dbd084 	addi	r3,r3,28482
  804224:	10c00115 	stw	r3,4(r2)
  804228:	00dd1c34 	movhi	r3,29808
  80422c:	18ce0c44 	addi	r3,r3,14385
  804230:	10c00215 	stw	r3,8(r2)
  804234:	00d88dc4 	movi	r3,25143
  804238:	10c0030d 	sth	r3,12(r2)
  80423c:	10000385 	stb	zero,14(r2)

	FntList[2].pFnt=(GFXfont *)&FreeSans18pt7b;
  804240:	008020f4 	movhi	r2,131
  804244:	10adae04 	addi	r2,r2,-18760
  804248:	00c02074 	movhi	r3,129
  80424c:	18d39d04 	addi	r3,r3,20084
  804250:	10c00a15 	stw	r3,40(r2)
	strcpy(FntList[2].FontName,"FreeSans18pt7b\0");
  804254:	008020f4 	movhi	r2,131
  804258:	10adb904 	addi	r2,r2,-18716
  80425c:	00d95974 	movhi	r3,25957
  804260:	18dc9184 	addi	r3,r3,29254
  804264:	10c00015 	stw	r3,0(r2)
  804268:	00dcdbb4 	movhi	r3,29550
  80426c:	18d854c4 	addi	r3,r3,24915
  804270:	10c00115 	stw	r3,4(r2)
  804274:	00dd1c34 	movhi	r3,29808
  804278:	18ce0c44 	addi	r3,r3,14385
  80427c:	10c00215 	stw	r3,8(r2)
  804280:	00d88dc4 	movi	r3,25143
  804284:	10c0030d 	sth	r3,12(r2)
  804288:	10000385 	stb	zero,14(r2)

	FntList[3].pFnt=(GFXfont *)&FreeSerif18pt7b;
  80428c:	008020f4 	movhi	r2,131
  804290:	10adae04 	addi	r2,r2,-18760
  804294:	00c02074 	movhi	r3,129
  804298:	18d82a04 	addi	r3,r3,24744
  80429c:	10c00f15 	stw	r3,60(r2)
	strcpy(FntList[3].FontName,"FreeSerif18pt7b\0");
  8042a0:	008020f4 	movhi	r2,131
  8042a4:	10adae04 	addi	r2,r2,-18760
  8042a8:	00c02074 	movhi	r3,129
  8042ac:	18d82d04 	addi	r3,r3,24756
  8042b0:	19000017 	ldw	r4,0(r3)
  8042b4:	11001015 	stw	r4,64(r2)
  8042b8:	19000117 	ldw	r4,4(r3)
  8042bc:	11001115 	stw	r4,68(r2)
  8042c0:	19000217 	ldw	r4,8(r3)
  8042c4:	11001215 	stw	r4,72(r2)
  8042c8:	18c00317 	ldw	r3,12(r3)
  8042cc:	10c01315 	stw	r3,76(r2)


	return 2;
  8042d0:	00800084 	movi	r2,2
}
  8042d4:	e037883a 	mov	sp,fp
  8042d8:	df000017 	ldw	fp,0(sp)
  8042dc:	dec00104 	addi	sp,sp,4
  8042e0:	f800283a 	ret

008042e4 <get_LCD_DMA_sts>:
#define Write_Data16_9341(data)	pLCD_DATA16_PORT=data

ILI9341mod	*pILI9341 = (ILI9341mod *)ILI9341SPI_BASE;
DMAMOD *pLCD_DMA = (DMAMOD *)DMA_LCD_BASE;

int get_LCD_DMA_sts(){
  8042e4:	deffff04 	addi	sp,sp,-4
  8042e8:	df000015 	stw	fp,0(sp)
  8042ec:	d839883a 	mov	fp,sp
	return pLCD_DMA->STATUSreg &_b_DMA_BUSY;
  8042f0:	d0a00b17 	ldw	r2,-32724(gp)
  8042f4:	10800017 	ldw	r2,0(r2)
  8042f8:	1080008c 	andi	r2,r2,2
}
  8042fc:	e037883a 	mov	sp,fp
  804300:	df000017 	ldw	fp,0(sp)
  804304:	dec00104 	addi	sp,sp,4
  804308:	f800283a 	ret

0080430c <init_LCD_DMA>:


void init_LCD_DMA(){
  80430c:	deffff04 	addi	sp,sp,-4
  804310:	df000015 	stw	fp,0(sp)
  804314:	d839883a 	mov	fp,sp
	pLCD_DMA->CTRLreg = 	_b_DMA_SWRESET;	//soft reset
  804318:	d0a00b17 	ldw	r2,-32724(gp)
  80431c:	00c40004 	movi	r3,4096
  804320:	10c00615 	stw	r3,24(r2)
	pLCD_DMA->CTRLreg = 	0;	//soft reset
  804324:	d0a00b17 	ldw	r2,-32724(gp)
  804328:	10000615 	stw	zero,24(r2)

	pLCD_DMA->CTRLreg = 	_b_DMA_HW		//316bit only
  80432c:	d0a00b17 	ldw	r2,-32724(gp)
  804330:	00c0a084 	movi	r3,642
  804334:	10c00615 	stw	r3,24(r2)
						|	_b_DMA_WCON		//destination is fixed address;
						|	_b_DMA_LEEN	;	//
									//disable interrupt
}
  804338:	0001883a 	nop
  80433c:	e037883a 	mov	sp,fp
  804340:	df000017 	ldw	fp,0(sp)
  804344:	dec00104 	addi	sp,sp,4
  804348:	f800283a 	ret

0080434c <start_LCD_DMA_BitBLT>:

void start_LCD_DMA_BitBLT(int src_addr,int length){
  80434c:	defffd04 	addi	sp,sp,-12
  804350:	df000215 	stw	fp,8(sp)
  804354:	df000204 	addi	fp,sp,8
  804358:	e13ffe15 	stw	r4,-8(fp)
  80435c:	e17fff15 	stw	r5,-4(fp)
	pLCD_DMA->CTRLreg &= ~_b_DMA_GO;	//destination is fixed address;
  804360:	d0a00b17 	ldw	r2,-32724(gp)
  804364:	d0e00b17 	ldw	r3,-32724(gp)
  804368:	19000617 	ldw	r4,24(r3)
  80436c:	00fffdc4 	movi	r3,-9
  804370:	20c6703a 	and	r3,r4,r3
  804374:	10c00615 	stw	r3,24(r2)

	pLCD_DMA->CTRLreg |= 	_b_DMA_WCON;	//destination is fixed address;
  804378:	d0a00b17 	ldw	r2,-32724(gp)
  80437c:	d0e00b17 	ldw	r3,-32724(gp)
  804380:	18c00617 	ldw	r3,24(r3)
  804384:	18c08014 	ori	r3,r3,512
  804388:	10c00615 	stw	r3,24(r2)
	pLCD_DMA->CTRLreg &= 	~_b_DMA_RCON;	//RCON<=0 source address increment
  80438c:	d0a00b17 	ldw	r2,-32724(gp)
  804390:	d0e00b17 	ldw	r3,-32724(gp)
  804394:	19000617 	ldw	r4,24(r3)
  804398:	00ffbfc4 	movi	r3,-257
  80439c:	20c6703a 	and	r3,r4,r3
  8043a0:	10c00615 	stw	r3,24(r2)
	pLCD_DMA->RD_ADDRreg	= src_addr;
  8043a4:	d0a00b17 	ldw	r2,-32724(gp)
  8043a8:	e0fffe17 	ldw	r3,-8(fp)
  8043ac:	10c00115 	stw	r3,4(r2)
	pLCD_DMA->WR_ADDRreg	= (int)&pILI9341->DATA16reg;
  8043b0:	d0a00b17 	ldw	r2,-32724(gp)
  8043b4:	d0e00a17 	ldw	r3,-32728(gp)
  8043b8:	18c00304 	addi	r3,r3,12
  8043bc:	10c00215 	stw	r3,8(r2)
	pLCD_DMA->LENGTHreg	= length;
  8043c0:	d0a00b17 	ldw	r2,-32724(gp)
  8043c4:	e0ffff17 	ldw	r3,-4(fp)
  8043c8:	10c00315 	stw	r3,12(r2)

	pLCD_DMA->CTRLreg |= 	_b_DMA_GO;	//destination is fixed address;
  8043cc:	d0a00b17 	ldw	r2,-32724(gp)
  8043d0:	d0e00b17 	ldw	r3,-32724(gp)
  8043d4:	18c00617 	ldw	r3,24(r3)
  8043d8:	18c00214 	ori	r3,r3,8
  8043dc:	10c00615 	stw	r3,24(r2)
}
  8043e0:	0001883a 	nop
  8043e4:	e037883a 	mov	sp,fp
  8043e8:	df000017 	ldw	fp,0(sp)
  8043ec:	dec00104 	addi	sp,sp,4
  8043f0:	f800283a 	ret

008043f4 <start_LCD_DMA_FILL>:

void start_LCD_DMA_FILL(int src_addr,int length){
  8043f4:	defffd04 	addi	sp,sp,-12
  8043f8:	df000215 	stw	fp,8(sp)
  8043fc:	df000204 	addi	fp,sp,8
  804400:	e13ffe15 	stw	r4,-8(fp)
  804404:	e17fff15 	stw	r5,-4(fp)

	pLCD_DMA->CTRLreg &= ~_b_DMA_GO;	//destination is fixed address;
  804408:	d0a00b17 	ldw	r2,-32724(gp)
  80440c:	d0e00b17 	ldw	r3,-32724(gp)
  804410:	19000617 	ldw	r4,24(r3)
  804414:	00fffdc4 	movi	r3,-9
  804418:	20c6703a 	and	r3,r4,r3
  80441c:	10c00615 	stw	r3,24(r2)

	pLCD_DMA->CTRLreg |= 	_b_DMA_WCON;	//destination is fixed address;
  804420:	d0a00b17 	ldw	r2,-32724(gp)
  804424:	d0e00b17 	ldw	r3,-32724(gp)
  804428:	18c00617 	ldw	r3,24(r3)
  80442c:	18c08014 	ori	r3,r3,512
  804430:	10c00615 	stw	r3,24(r2)
	pLCD_DMA->CTRLreg |= _b_DMA_RCON;	//RCON:1  source address constant
  804434:	d0a00b17 	ldw	r2,-32724(gp)
  804438:	d0e00b17 	ldw	r3,-32724(gp)
  80443c:	18c00617 	ldw	r3,24(r3)
  804440:	18c04014 	ori	r3,r3,256
  804444:	10c00615 	stw	r3,24(r2)

	pLCD_DMA->RD_ADDRreg	= src_addr;
  804448:	d0a00b17 	ldw	r2,-32724(gp)
  80444c:	e0fffe17 	ldw	r3,-8(fp)
  804450:	10c00115 	stw	r3,4(r2)
	pLCD_DMA->WR_ADDRreg	= (int )&pILI9341->DATA16reg;
  804454:	d0a00b17 	ldw	r2,-32724(gp)
  804458:	d0e00a17 	ldw	r3,-32728(gp)
  80445c:	18c00304 	addi	r3,r3,12
  804460:	10c00215 	stw	r3,8(r2)
	pLCD_DMA->LENGTHreg	= length;
  804464:	d0a00b17 	ldw	r2,-32724(gp)
  804468:	e0ffff17 	ldw	r3,-4(fp)
  80446c:	10c00315 	stw	r3,12(r2)


	pLCD_DMA->CTRLreg |= _b_DMA_GO;	//destination is fixed address;
  804470:	d0a00b17 	ldw	r2,-32724(gp)
  804474:	d0e00b17 	ldw	r3,-32724(gp)
  804478:	18c00617 	ldw	r3,24(r3)
  80447c:	18c00214 	ori	r3,r3,8
  804480:	10c00615 	stw	r3,24(r2)
}
  804484:	0001883a 	nop
  804488:	e037883a 	mov	sp,fp
  80448c:	df000017 	ldw	fp,0(sp)
  804490:	dec00104 	addi	sp,sp,4
  804494:	f800283a 	ret

00804498 <start_LCD_DMA_BufferFill>:

void start_LCD_DMA_BufferFill(int src_addr,int dst_addr,int length){
  804498:	defffc04 	addi	sp,sp,-16
  80449c:	df000315 	stw	fp,12(sp)
  8044a0:	df000304 	addi	fp,sp,12
  8044a4:	e13ffd15 	stw	r4,-12(fp)
  8044a8:	e17ffe15 	stw	r5,-8(fp)
  8044ac:	e1bfff15 	stw	r6,-4(fp)
	pLCD_DMA->CTRLreg &= ~_b_DMA_GO;	//destination is fixed address;
  8044b0:	d0a00b17 	ldw	r2,-32724(gp)
  8044b4:	d0e00b17 	ldw	r3,-32724(gp)
  8044b8:	19000617 	ldw	r4,24(r3)
  8044bc:	00fffdc4 	movi	r3,-9
  8044c0:	20c6703a 	and	r3,r4,r3
  8044c4:	10c00615 	stw	r3,24(r2)

	pLCD_DMA->CTRLreg &=  ~_b_DMA_WCON;	//destination is fixed address;
  8044c8:	d0a00b17 	ldw	r2,-32724(gp)
  8044cc:	d0e00b17 	ldw	r3,-32724(gp)
  8044d0:	19000617 	ldw	r4,24(r3)
  8044d4:	00ff7fc4 	movi	r3,-513
  8044d8:	20c6703a 	and	r3,r4,r3
  8044dc:	10c00615 	stw	r3,24(r2)
	pLCD_DMA->CTRLreg |= _b_DMA_RCON;	//RCON:1  source address constant
  8044e0:	d0a00b17 	ldw	r2,-32724(gp)
  8044e4:	d0e00b17 	ldw	r3,-32724(gp)
  8044e8:	18c00617 	ldw	r3,24(r3)
  8044ec:	18c04014 	ori	r3,r3,256
  8044f0:	10c00615 	stw	r3,24(r2)

	pLCD_DMA->RD_ADDRreg	= src_addr;
  8044f4:	d0a00b17 	ldw	r2,-32724(gp)
  8044f8:	e0fffd17 	ldw	r3,-12(fp)
  8044fc:	10c00115 	stw	r3,4(r2)
	pLCD_DMA->WR_ADDRreg	= dst_addr;
  804500:	d0a00b17 	ldw	r2,-32724(gp)
  804504:	e0fffe17 	ldw	r3,-8(fp)
  804508:	10c00215 	stw	r3,8(r2)
	pLCD_DMA->LENGTHreg	= length;
  80450c:	d0a00b17 	ldw	r2,-32724(gp)
  804510:	e0ffff17 	ldw	r3,-4(fp)
  804514:	10c00315 	stw	r3,12(r2)

	pLCD_DMA->CTRLreg |= _b_DMA_GO;	//destination is fixed address;
  804518:	d0a00b17 	ldw	r2,-32724(gp)
  80451c:	d0e00b17 	ldw	r3,-32724(gp)
  804520:	18c00617 	ldw	r3,24(r3)
  804524:	18c00214 	ori	r3,r3,8
  804528:	10c00615 	stw	r3,24(r2)
}
  80452c:	0001883a 	nop
  804530:	e037883a 	mov	sp,fp
  804534:	df000017 	ldw	fp,0(sp)
  804538:	dec00104 	addi	sp,sp,4
  80453c:	f800283a 	ret

00804540 <init_9341>:

void init_9341(int16_t color){
  804540:	defffc04 	addi	sp,sp,-16
  804544:	dfc00315 	stw	ra,12(sp)
  804548:	df000215 	stw	fp,8(sp)
  80454c:	df000204 	addi	fp,sp,8
  804550:	2005883a 	mov	r2,r4
  804554:	e0bfff0d 	sth	r2,-4(fp)

	init_LCD_DMA(pLCD_DMA);
  804558:	d0a00b17 	ldw	r2,-32724(gp)
  80455c:	1009883a 	mov	r4,r2
  804560:	080430c0 	call	80430c <init_LCD_DMA>

	LCD_RESET_LOW();
  804564:	008e0204 	movi	r2,14344
  804568:	00c00044 	movi	r3,1
  80456c:	10c00015 	stw	r3,0(r2)
	vTaskDelay( 10/ portTICK_PERIOD_MS);
  804570:	01000284 	movi	r4,10
  804574:	08023680 	call	802368 <vTaskDelay>
	LCD_RESET_HIGH();
  804578:	008e0204 	movi	r2,14344
  80457c:	10000015 	stw	zero,0(r2)
	vTaskDelay( 10/ portTICK_PERIOD_MS);
  804580:	01000284 	movi	r4,10
  804584:	08023680 	call	802368 <vTaskDelay>

    Write_Command_9341(0xEF);
  804588:	008e0004 	movi	r2,14336
  80458c:	00c03bc4 	movi	r3,239
  804590:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x03);
  804594:	008e0104 	movi	r2,14340
  804598:	00c000c4 	movi	r3,3
  80459c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x80);
  8045a0:	008e0104 	movi	r2,14340
  8045a4:	00c02004 	movi	r3,128
  8045a8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x02);
  8045ac:	008e0104 	movi	r2,14340
  8045b0:	00c00084 	movi	r3,2
  8045b4:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xCF);
  8045b8:	008e0004 	movi	r2,14336
  8045bc:	00c033c4 	movi	r3,207
  8045c0:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  8045c4:	008e0104 	movi	r2,14340
  8045c8:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0XC1);
  8045cc:	008e0104 	movi	r2,14340
  8045d0:	00c03044 	movi	r3,193
  8045d4:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0X30);
  8045d8:	008e0104 	movi	r2,14340
  8045dc:	00c00c04 	movi	r3,48
  8045e0:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xED);
  8045e4:	008e0004 	movi	r2,14336
  8045e8:	00c03b44 	movi	r3,237
  8045ec:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x64);
  8045f0:	008e0104 	movi	r2,14340
  8045f4:	00c01904 	movi	r3,100
  8045f8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x03);
  8045fc:	008e0104 	movi	r2,14340
  804600:	00c000c4 	movi	r3,3
  804604:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0X12);
  804608:	008e0104 	movi	r2,14340
  80460c:	00c00484 	movi	r3,18
  804610:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0X81);
  804614:	008e0104 	movi	r2,14340
  804618:	00c02044 	movi	r3,129
  80461c:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xE8);
  804620:	008e0004 	movi	r2,14336
  804624:	00c03a04 	movi	r3,232
  804628:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x85);
  80462c:	008e0104 	movi	r2,14340
  804630:	00c02144 	movi	r3,133
  804634:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  804638:	008e0104 	movi	r2,14340
  80463c:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0x78);
  804640:	008e0104 	movi	r2,14340
  804644:	00c01e04 	movi	r3,120
  804648:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xCB);
  80464c:	008e0004 	movi	r2,14336
  804650:	00c032c4 	movi	r3,203
  804654:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x39);
  804658:	008e0104 	movi	r2,14340
  80465c:	00c00e44 	movi	r3,57
  804660:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x2C);
  804664:	008e0104 	movi	r2,14340
  804668:	00c00b04 	movi	r3,44
  80466c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  804670:	008e0104 	movi	r2,14340
  804674:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0x34);
  804678:	008e0104 	movi	r2,14340
  80467c:	00c00d04 	movi	r3,52
  804680:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x02);
  804684:	008e0104 	movi	r2,14340
  804688:	00c00084 	movi	r3,2
  80468c:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xF7);
  804690:	008e0004 	movi	r2,14336
  804694:	00c03dc4 	movi	r3,247
  804698:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x20);
  80469c:	008e0104 	movi	r2,14340
  8046a0:	00c00804 	movi	r3,32
  8046a4:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xEA);
  8046a8:	008e0004 	movi	r2,14336
  8046ac:	00c03a84 	movi	r3,234
  8046b0:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  8046b4:	008e0104 	movi	r2,14340
  8046b8:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0x00);
  8046bc:	008e0104 	movi	r2,14340
  8046c0:	10000015 	stw	zero,0(r2)

    Write_Command_9341(ILI9341_PWCTR1);    //Power control
  8046c4:	008e0004 	movi	r2,14336
  8046c8:	00c03004 	movi	r3,192
  8046cc:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x23);   //VRH[5:0]
  8046d0:	008e0104 	movi	r2,14340
  8046d4:	00c008c4 	movi	r3,35
  8046d8:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_PWCTR2);    //Power control
  8046dc:	008e0004 	movi	r2,14336
  8046e0:	00c03044 	movi	r3,193
  8046e4:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x10);   //SAP[2:0];BT[3:0]
  8046e8:	008e0104 	movi	r2,14340
  8046ec:	00c00404 	movi	r3,16
  8046f0:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_VMCTR1);    //VCM control
  8046f4:	008e0004 	movi	r2,14336
  8046f8:	00c03144 	movi	r3,197
  8046fc:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x3e);
  804700:	008e0104 	movi	r2,14340
  804704:	00c00f84 	movi	r3,62
  804708:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x28);
  80470c:	008e0104 	movi	r2,14340
  804710:	00c00a04 	movi	r3,40
  804714:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_VMCTR2);    //VCM control2
  804718:	008e0004 	movi	r2,14336
  80471c:	00c031c4 	movi	r3,199
  804720:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x86);  //--
  804724:	008e0104 	movi	r2,14340
  804728:	00c02184 	movi	r3,134
  80472c:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_MADCTL);    // Memory Access Control
  804730:	008e0004 	movi	r2,14336
  804734:	00c00d84 	movi	r3,54
  804738:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(MAC_PORTRAIT);
  80473c:	008e0104 	movi	r2,14340
  804740:	00c03a04 	movi	r3,232
  804744:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_VSCRSADD); // Vertical scroll
  804748:	008e0004 	movi	r2,14336
  80474c:	00c00dc4 	movi	r3,55
  804750:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0);                 // Zero
  804754:	008e0104 	movi	r2,14340
  804758:	10000015 	stw	zero,0(r2)

    Write_Command_9341(ILI9341_PIXFMT);
  80475c:	008e0004 	movi	r2,14336
  804760:	00c00e84 	movi	r3,58
  804764:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x55);
  804768:	008e0104 	movi	r2,14340
  80476c:	00c01544 	movi	r3,85
  804770:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_FRMCTR1);
  804774:	008e0004 	movi	r2,14336
  804778:	00c02c44 	movi	r3,177
  80477c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  804780:	008e0104 	movi	r2,14340
  804784:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0x18);
  804788:	008e0104 	movi	r2,14340
  80478c:	00c00604 	movi	r3,24
  804790:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_DFUNCTR);    // Display Function Control
  804794:	008e0004 	movi	r2,14336
  804798:	00c02d84 	movi	r3,182
  80479c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x08);
  8047a0:	008e0104 	movi	r2,14340
  8047a4:	00c00204 	movi	r3,8
  8047a8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x82);
  8047ac:	008e0104 	movi	r2,14340
  8047b0:	00c02084 	movi	r3,130
  8047b4:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x27);
  8047b8:	008e0104 	movi	r2,14340
  8047bc:	00c009c4 	movi	r3,39
  8047c0:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(0xF2);    // 3Gamma Function Disable
  8047c4:	008e0004 	movi	r2,14336
  8047c8:	00c03c84 	movi	r3,242
  8047cc:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  8047d0:	008e0104 	movi	r2,14340
  8047d4:	10000015 	stw	zero,0(r2)

    Write_Command_9341(ILI9341_GAMMASET);    //Gamma curve selected
  8047d8:	008e0004 	movi	r2,14336
  8047dc:	00c00984 	movi	r3,38
  8047e0:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x01);
  8047e4:	008e0104 	movi	r2,14340
  8047e8:	00c00044 	movi	r3,1
  8047ec:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_GMCTRP1);    //Set Gamma
  8047f0:	008e0004 	movi	r2,14336
  8047f4:	00c03804 	movi	r3,224
  8047f8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0F);
  8047fc:	008e0104 	movi	r2,14340
  804800:	00c003c4 	movi	r3,15
  804804:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x31);
  804808:	008e0104 	movi	r2,14340
  80480c:	00c00c44 	movi	r3,49
  804810:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x2B);
  804814:	008e0104 	movi	r2,14340
  804818:	00c00ac4 	movi	r3,43
  80481c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0C);
  804820:	008e0104 	movi	r2,14340
  804824:	00c00304 	movi	r3,12
  804828:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0E);
  80482c:	008e0104 	movi	r2,14340
  804830:	00c00384 	movi	r3,14
  804834:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x08);
  804838:	008e0104 	movi	r2,14340
  80483c:	00c00204 	movi	r3,8
  804840:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x4E);
  804844:	008e0104 	movi	r2,14340
  804848:	00c01384 	movi	r3,78
  80484c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0xF1);
  804850:	008e0104 	movi	r2,14340
  804854:	00c03c44 	movi	r3,241
  804858:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x37);
  80485c:	008e0104 	movi	r2,14340
  804860:	00c00dc4 	movi	r3,55
  804864:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x07);
  804868:	008e0104 	movi	r2,14340
  80486c:	00c001c4 	movi	r3,7
  804870:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x10);
  804874:	008e0104 	movi	r2,14340
  804878:	00c00404 	movi	r3,16
  80487c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x03);
  804880:	008e0104 	movi	r2,14340
  804884:	00c000c4 	movi	r3,3
  804888:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0E);
  80488c:	008e0104 	movi	r2,14340
  804890:	00c00384 	movi	r3,14
  804894:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x09);
  804898:	008e0104 	movi	r2,14340
  80489c:	00c00244 	movi	r3,9
  8048a0:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  8048a4:	008e0104 	movi	r2,14340
  8048a8:	10000015 	stw	zero,0(r2)

    Write_Command_9341(ILI9341_GMCTRN1);    //Set Gamma
  8048ac:	008e0004 	movi	r2,14336
  8048b0:	00c03844 	movi	r3,225
  8048b4:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x00);
  8048b8:	008e0104 	movi	r2,14340
  8048bc:	10000015 	stw	zero,0(r2)
    Write_Data_9341(0x0E);
  8048c0:	008e0104 	movi	r2,14340
  8048c4:	00c00384 	movi	r3,14
  8048c8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x14);
  8048cc:	008e0104 	movi	r2,14340
  8048d0:	00c00504 	movi	r3,20
  8048d4:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x03);
  8048d8:	008e0104 	movi	r2,14340
  8048dc:	00c000c4 	movi	r3,3
  8048e0:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x11);
  8048e4:	008e0104 	movi	r2,14340
  8048e8:	00c00444 	movi	r3,17
  8048ec:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x07);
  8048f0:	008e0104 	movi	r2,14340
  8048f4:	00c001c4 	movi	r3,7
  8048f8:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x31);
  8048fc:	008e0104 	movi	r2,14340
  804900:	00c00c44 	movi	r3,49
  804904:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0xC1);
  804908:	008e0104 	movi	r2,14340
  80490c:	00c03044 	movi	r3,193
  804910:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x48);
  804914:	008e0104 	movi	r2,14340
  804918:	00c01204 	movi	r3,72
  80491c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x08);
  804920:	008e0104 	movi	r2,14340
  804924:	00c00204 	movi	r3,8
  804928:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0F);
  80492c:	008e0104 	movi	r2,14340
  804930:	00c003c4 	movi	r3,15
  804934:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0C);
  804938:	008e0104 	movi	r2,14340
  80493c:	00c00304 	movi	r3,12
  804940:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x31);
  804944:	008e0104 	movi	r2,14340
  804948:	00c00c44 	movi	r3,49
  80494c:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x36);
  804950:	008e0104 	movi	r2,14340
  804954:	00c00d84 	movi	r3,54
  804958:	10c00015 	stw	r3,0(r2)
    Write_Data_9341(0x0F);
  80495c:	008e0104 	movi	r2,14340
  804960:	00c003c4 	movi	r3,15
  804964:	10c00015 	stw	r3,0(r2)

    Write_Command_9341(ILI9341_SLPOUT);    //Exit Sleep
  804968:	008e0004 	movi	r2,14336
  80496c:	00c00444 	movi	r3,17
  804970:	10c00015 	stw	r3,0(r2)
	vTaskDelay( 50/ portTICK_PERIOD_MS);
  804974:	01000c84 	movi	r4,50
  804978:	08023680 	call	802368 <vTaskDelay>
    Write_Command_9341(ILI9341_DISPON);    //Display on
  80497c:	008e0004 	movi	r2,14336
  804980:	00c00a44 	movi	r3,41
  804984:	10c00015 	stw	r3,0(r2)
	vTaskDelay( 50/ portTICK_PERIOD_MS);
  804988:	01000c84 	movi	r4,50
  80498c:	08023680 	call	802368 <vTaskDelay>

	Rectangle_9341(0,319,0, 239,color);
  804990:	e0bfff0b 	ldhu	r2,-4(fp)
  804994:	10bfffcc 	andi	r2,r2,65535
  804998:	d8800015 	stw	r2,0(sp)
  80499c:	01c03bc4 	movi	r7,239
  8049a0:	000d883a 	mov	r6,zero
  8049a4:	01404fc4 	movi	r5,319
  8049a8:	0009883a 	mov	r4,zero
  8049ac:	0804cc40 	call	804cc4 <Rectangle_9341>


	//    endWrite();
}
  8049b0:	0001883a 	nop
  8049b4:	e037883a 	mov	sp,fp
  8049b8:	dfc00117 	ldw	ra,4(sp)
  8049bc:	df000017 	ldw	fp,0(sp)
  8049c0:	dec00204 	addi	sp,sp,8
  8049c4:	f800283a 	ret

008049c8 <BitBlt_9341>:


int BitBlt_9341(uint16_t sx, uint16_t ex, uint16_t sy, uint16_t ey,uint16_t *data) {
  8049c8:	defff604 	addi	sp,sp,-40
  8049cc:	dfc00915 	stw	ra,36(sp)
  8049d0:	df000815 	stw	fp,32(sp)
  8049d4:	df000804 	addi	fp,sp,32
  8049d8:	2011883a 	mov	r8,r4
  8049dc:	2809883a 	mov	r4,r5
  8049e0:	3007883a 	mov	r3,r6
  8049e4:	3805883a 	mov	r2,r7
  8049e8:	e23ffc0d 	sth	r8,-16(fp)
  8049ec:	e13ffd0d 	sth	r4,-12(fp)
  8049f0:	e0fffe0d 	sth	r3,-8(fp)
  8049f4:	e0bfff0d 	sth	r2,-4(fp)
	int size,flag;
	int i;
	uint16_t *endp;
	uint16_t *sp;

	if((sx<0) ||(sx>ex) || (ex>=ILI9341_IMG_WIDTH)){
  8049f8:	e0bffc0b 	ldhu	r2,-16(fp)
  8049fc:	e0fffd0b 	ldhu	r3,-12(fp)
  804a00:	18800336 	bltu	r3,r2,804a10 <BitBlt_9341+0x48>
  804a04:	e0bffd0b 	ldhu	r2,-12(fp)
  804a08:	10805030 	cmpltui	r2,r2,320
  804a0c:	1000021e 	bne	r2,zero,804a18 <BitBlt_9341+0x50>
		return -1;
  804a10:	00bfffc4 	movi	r2,-1
  804a14:	00004d06 	br	804b4c <BitBlt_9341+0x184>
	}
	if((sy<0) ||(sy>ey) || (ey>=ILI9341_IMG_HEIGHT)){
  804a18:	e0bffe0b 	ldhu	r2,-8(fp)
  804a1c:	e0ffff0b 	ldhu	r3,-4(fp)
  804a20:	18800336 	bltu	r3,r2,804a30 <BitBlt_9341+0x68>
  804a24:	e0bfff0b 	ldhu	r2,-4(fp)
  804a28:	10803c30 	cmpltui	r2,r2,240
  804a2c:	1000021e 	bne	r2,zero,804a38 <BitBlt_9341+0x70>
		return -1;
  804a30:	00bfffc4 	movi	r2,-1
  804a34:	00004506 	br	804b4c <BitBlt_9341+0x184>
	}

	sp=data;
  804a38:	e0800217 	ldw	r2,8(fp)
  804a3c:	e0bff915 	stw	r2,-28(fp)

#ifdef	DATA16EXTENTION
	GRAY_MODE_OFF();
  804a40:	008e0204 	movi	r2,14344
  804a44:	10800017 	ldw	r2,0(r2)
  804a48:	008e0204 	movi	r2,14344
  804a4c:	10000015 	stw	zero,0(r2)
	Write_Command_9341(ILI9341_CASET);
  804a50:	008e0004 	movi	r2,14336
  804a54:	00c00a84 	movi	r3,42
  804a58:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sx);
  804a5c:	008e0304 	movi	r2,14348
  804a60:	e0fffc0b 	ldhu	r3,-16(fp)
  804a64:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ex);
  804a68:	008e0304 	movi	r2,14348
  804a6c:	e0fffd0b 	ldhu	r3,-12(fp)
  804a70:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_PASET);
  804a74:	008e0004 	movi	r2,14336
  804a78:	00c00ac4 	movi	r3,43
  804a7c:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sy);
  804a80:	008e0304 	movi	r2,14348
  804a84:	e0fffe0b 	ldhu	r3,-8(fp)
  804a88:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ey);
  804a8c:	008e0304 	movi	r2,14348
  804a90:	e0ffff0b 	ldhu	r3,-4(fp)
  804a94:	10c00015 	stw	r3,0(r2)
	Write_Command_9341(ILI9341_RAMWR);
  804a98:	008e0004 	movi	r2,14336
  804a9c:	00c00b04 	movi	r3,44
  804aa0:	10c00015 	stw	r3,0(r2)

	endp=(ex-sx+1)*(ey-sy+1)+sp;
  804aa4:	e0fffd0b 	ldhu	r3,-12(fp)
  804aa8:	e0bffc0b 	ldhu	r2,-16(fp)
  804aac:	1885c83a 	sub	r2,r3,r2
  804ab0:	11000044 	addi	r4,r2,1
  804ab4:	e0ffff0b 	ldhu	r3,-4(fp)
  804ab8:	e0bffe0b 	ldhu	r2,-8(fp)
  804abc:	1885c83a 	sub	r2,r3,r2
  804ac0:	10800044 	addi	r2,r2,1
  804ac4:	100b883a 	mov	r5,r2
  804ac8:	080b2480 	call	80b248 <__mulsi3>
  804acc:	1085883a 	add	r2,r2,r2
  804ad0:	1007883a 	mov	r3,r2
  804ad4:	e0bff917 	ldw	r2,-28(fp)
  804ad8:	10c5883a 	add	r2,r2,r3
  804adc:	e0bffa15 	stw	r2,-24(fp)
	size=(ex-sx+1)*(ey-sy+1);
  804ae0:	e0fffd0b 	ldhu	r3,-12(fp)
  804ae4:	e0bffc0b 	ldhu	r2,-16(fp)
  804ae8:	1885c83a 	sub	r2,r3,r2
  804aec:	11000044 	addi	r4,r2,1
  804af0:	e0ffff0b 	ldhu	r3,-4(fp)
  804af4:	e0bffe0b 	ldhu	r2,-8(fp)
  804af8:	1885c83a 	sub	r2,r3,r2
  804afc:	10800044 	addi	r2,r2,1
  804b00:	100b883a 	mov	r5,r2
  804b04:	080b2480 	call	80b248 <__mulsi3>
  804b08:	e0bffb15 	stw	r2,-20(fp)
#ifdef LCD_DMA
	start_LCD_DMA_BitBLT( (int)data, size*2);
  804b0c:	e0c00217 	ldw	r3,8(fp)
  804b10:	e0bffb17 	ldw	r2,-20(fp)
  804b14:	1085883a 	add	r2,r2,r2
  804b18:	100b883a 	mov	r5,r2
  804b1c:	1809883a 	mov	r4,r3
  804b20:	080434c0 	call	80434c <start_LCD_DMA_BitBLT>
	flag = get_LCD_DMA_sts();
  804b24:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  804b28:	e0bff815 	stw	r2,-32(fp)
	while (flag!=0){
  804b2c:	00000406 	br	804b40 <BitBlt_9341+0x178>
		flag = get_LCD_DMA_sts();
  804b30:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  804b34:	e0bff815 	stw	r2,-32(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  804b38:	01000044 	movi	r4,1
  804b3c:	08023680 	call	802368 <vTaskDelay>
	endp=(ex-sx+1)*(ey-sy+1)+sp;
	size=(ex-sx+1)*(ey-sy+1);
#ifdef LCD_DMA
	start_LCD_DMA_BitBLT( (int)data, size*2);
	flag = get_LCD_DMA_sts();
	while (flag!=0){
  804b40:	e0bff817 	ldw	r2,-32(fp)
  804b44:	103ffa1e 	bne	r2,zero,804b30 <__alt_data_end+0xfff04b30>

		Write_Data_9341(*sp>>8);
		Write_Data_9341((*sp) & 0xff);
	}
#endif
	return 0;
  804b48:	0005883a 	mov	r2,zero
}
  804b4c:	e037883a 	mov	sp,fp
  804b50:	dfc00117 	ldw	ra,4(sp)
  804b54:	df000017 	ldw	fp,0(sp)
  804b58:	dec00204 	addi	sp,sp,8
  804b5c:	f800283a 	ret

00804b60 <BitBlt_9341_GRAY8>:

int BitBlt_9341_GRAY8(uint16_t sx, uint16_t ex, uint16_t sy, uint16_t ey,uint8_t *data) {
  804b60:	defff704 	addi	sp,sp,-36
  804b64:	dfc00815 	stw	ra,32(sp)
  804b68:	df000715 	stw	fp,28(sp)
  804b6c:	df000704 	addi	fp,sp,28
  804b70:	2011883a 	mov	r8,r4
  804b74:	2809883a 	mov	r4,r5
  804b78:	3007883a 	mov	r3,r6
  804b7c:	3805883a 	mov	r2,r7
  804b80:	e23ffc0d 	sth	r8,-16(fp)
  804b84:	e13ffd0d 	sth	r4,-12(fp)
  804b88:	e0fffe0d 	sth	r3,-8(fp)
  804b8c:	e0bfff0d 	sth	r2,-4(fp)
  // VRAMCMD_MEMORY_WRITE

	int i;
	uint8_t *sp,*endp;

	if((sx<0) ||(sx>ex) || (ex>=ILI9341_IMG_WIDTH)){
  804b90:	e0bffc0b 	ldhu	r2,-16(fp)
  804b94:	e0fffd0b 	ldhu	r3,-12(fp)
  804b98:	18800336 	bltu	r3,r2,804ba8 <BitBlt_9341_GRAY8+0x48>
  804b9c:	e0bffd0b 	ldhu	r2,-12(fp)
  804ba0:	10805030 	cmpltui	r2,r2,320
  804ba4:	1000021e 	bne	r2,zero,804bb0 <BitBlt_9341_GRAY8+0x50>
		return -1;
  804ba8:	00bfffc4 	movi	r2,-1
  804bac:	00004006 	br	804cb0 <BitBlt_9341_GRAY8+0x150>
	}
	if((sy<0) ||(sy>ey) || (ey>=ILI9341_IMG_HEIGHT)){
  804bb0:	e0bffe0b 	ldhu	r2,-8(fp)
  804bb4:	e0ffff0b 	ldhu	r3,-4(fp)
  804bb8:	18800336 	bltu	r3,r2,804bc8 <BitBlt_9341_GRAY8+0x68>
  804bbc:	e0bfff0b 	ldhu	r2,-4(fp)
  804bc0:	10803c30 	cmpltui	r2,r2,240
  804bc4:	1000021e 	bne	r2,zero,804bd0 <BitBlt_9341_GRAY8+0x70>
		return -1;
  804bc8:	00bfffc4 	movi	r2,-1
  804bcc:	00003806 	br	804cb0 <BitBlt_9341_GRAY8+0x150>
	}

	sp = (uint8_t *)data;
  804bd0:	e0800217 	ldw	r2,8(fp)
  804bd4:	e0bffa15 	stw	r2,-24(fp)

	Write_Command_9341(ILI9341_CASET);
  804bd8:	008e0004 	movi	r2,14336
  804bdc:	00c00a84 	movi	r3,42
  804be0:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sx);
  804be4:	008e0304 	movi	r2,14348
  804be8:	e0fffc0b 	ldhu	r3,-16(fp)
  804bec:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ex);
  804bf0:	008e0304 	movi	r2,14348
  804bf4:	e0fffd0b 	ldhu	r3,-12(fp)
  804bf8:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_PASET);
  804bfc:	008e0004 	movi	r2,14336
  804c00:	00c00ac4 	movi	r3,43
  804c04:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sy);
  804c08:	008e0304 	movi	r2,14348
  804c0c:	e0fffe0b 	ldhu	r3,-8(fp)
  804c10:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ey);
  804c14:	008e0304 	movi	r2,14348
  804c18:	e0ffff0b 	ldhu	r3,-4(fp)
  804c1c:	10c00015 	stw	r3,0(r2)
	Write_Command_9341(ILI9341_RAMWR);
  804c20:	008e0004 	movi	r2,14336
  804c24:	00c00b04 	movi	r3,44
  804c28:	10c00015 	stw	r3,0(r2)

	GRAY_MODE_ON();
  804c2c:	008e0204 	movi	r2,14344
  804c30:	00c00084 	movi	r3,2
  804c34:	10c00015 	stw	r3,0(r2)

	endp=(ex-sx+1)*(ey-sy+1)+sp;
  804c38:	e0fffd0b 	ldhu	r3,-12(fp)
  804c3c:	e0bffc0b 	ldhu	r2,-16(fp)
  804c40:	1885c83a 	sub	r2,r3,r2
  804c44:	11000044 	addi	r4,r2,1
  804c48:	e0ffff0b 	ldhu	r3,-4(fp)
  804c4c:	e0bffe0b 	ldhu	r2,-8(fp)
  804c50:	1885c83a 	sub	r2,r3,r2
  804c54:	10800044 	addi	r2,r2,1
  804c58:	100b883a 	mov	r5,r2
  804c5c:	080b2480 	call	80b248 <__mulsi3>
  804c60:	1007883a 	mov	r3,r2
  804c64:	e0bffa17 	ldw	r2,-24(fp)
  804c68:	10c5883a 	add	r2,r2,r3
  804c6c:	e0bffb15 	stw	r2,-20(fp)
	for(;sp<endp;i++,sp++){
  804c70:	00000b06 	br	804ca0 <BitBlt_9341_GRAY8+0x140>
		Write_Data16_9341(*sp);
  804c74:	008e0304 	movi	r2,14348
  804c78:	e0fffa17 	ldw	r3,-24(fp)
  804c7c:	18c00003 	ldbu	r3,0(r3)
  804c80:	18c03fcc 	andi	r3,r3,255
  804c84:	10c00015 	stw	r3,0(r2)
	Write_Command_9341(ILI9341_RAMWR);

	GRAY_MODE_ON();

	endp=(ex-sx+1)*(ey-sy+1)+sp;
	for(;sp<endp;i++,sp++){
  804c88:	e0bff917 	ldw	r2,-28(fp)
  804c8c:	10800044 	addi	r2,r2,1
  804c90:	e0bff915 	stw	r2,-28(fp)
  804c94:	e0bffa17 	ldw	r2,-24(fp)
  804c98:	10800044 	addi	r2,r2,1
  804c9c:	e0bffa15 	stw	r2,-24(fp)
  804ca0:	e0fffa17 	ldw	r3,-24(fp)
  804ca4:	e0bffb17 	ldw	r2,-20(fp)
  804ca8:	18bff236 	bltu	r3,r2,804c74 <__alt_data_end+0xfff04c74>
		Write_Data16_9341(*sp);
	}
	return 0;
  804cac:	0005883a 	mov	r2,zero
}
  804cb0:	e037883a 	mov	sp,fp
  804cb4:	dfc00117 	ldw	ra,4(sp)
  804cb8:	df000017 	ldw	fp,0(sp)
  804cbc:	dec00204 	addi	sp,sp,8
  804cc0:	f800283a 	ret

00804cc4 <Rectangle_9341>:


int Rectangle_9341(uint16_t sx, uint16_t ex, uint16_t sy, uint16_t ey,uint16_t color) {
  804cc4:	defff604 	addi	sp,sp,-40
  804cc8:	dfc00915 	stw	ra,36(sp)
  804ccc:	df000815 	stw	fp,32(sp)
  804cd0:	df000804 	addi	fp,sp,32
  804cd4:	2011883a 	mov	r8,r4
  804cd8:	3009883a 	mov	r4,r6
  804cdc:	3807883a 	mov	r3,r7
  804ce0:	e0800217 	ldw	r2,8(fp)
  804ce4:	e23ffb0d 	sth	r8,-20(fp)
  804ce8:	e17ffc0d 	sth	r5,-16(fp)
  804cec:	e13ffd0d 	sth	r4,-12(fp)
  804cf0:	e0fffe0d 	sth	r3,-8(fp)
  804cf4:	e0bfff0d 	sth	r2,-4(fp)

	int size;
	volatile int flag;
	int loop_count;

	if((sx<0) ||(sx>ex) || (ex>=ILI9341_IMG_WIDTH)){
  804cf8:	e0bffb0b 	ldhu	r2,-20(fp)
  804cfc:	e0fffc0b 	ldhu	r3,-16(fp)
  804d00:	18800336 	bltu	r3,r2,804d10 <Rectangle_9341+0x4c>
  804d04:	e0bffc0b 	ldhu	r2,-16(fp)
  804d08:	10805030 	cmpltui	r2,r2,320
  804d0c:	1000021e 	bne	r2,zero,804d18 <Rectangle_9341+0x54>
		return -1;
  804d10:	00bfffc4 	movi	r2,-1
  804d14:	00003c06 	br	804e08 <Rectangle_9341+0x144>
	}
	if((sy<0) ||(sy>ey) || (ey>=ILI9341_IMG_HEIGHT)){
  804d18:	e0bffd0b 	ldhu	r2,-12(fp)
  804d1c:	e0fffe0b 	ldhu	r3,-8(fp)
  804d20:	18800336 	bltu	r3,r2,804d30 <Rectangle_9341+0x6c>
  804d24:	e0bffe0b 	ldhu	r2,-8(fp)
  804d28:	10803c30 	cmpltui	r2,r2,240
  804d2c:	1000021e 	bne	r2,zero,804d38 <Rectangle_9341+0x74>
		return -1;
  804d30:	00bfffc4 	movi	r2,-1
  804d34:	00003406 	br	804e08 <Rectangle_9341+0x144>
	}
#ifdef	DATA16EXTENTION
	Write_Command_9341(ILI9341_CASET);
  804d38:	008e0004 	movi	r2,14336
  804d3c:	00c00a84 	movi	r3,42
  804d40:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sx);
  804d44:	008e0304 	movi	r2,14348
  804d48:	e0fffb0b 	ldhu	r3,-20(fp)
  804d4c:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ex);
  804d50:	008e0304 	movi	r2,14348
  804d54:	e0fffc0b 	ldhu	r3,-16(fp)
  804d58:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_PASET);
  804d5c:	008e0004 	movi	r2,14336
  804d60:	00c00ac4 	movi	r3,43
  804d64:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(sy);
  804d68:	008e0304 	movi	r2,14348
  804d6c:	e0fffd0b 	ldhu	r3,-12(fp)
  804d70:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(ey);
  804d74:	008e0304 	movi	r2,14348
  804d78:	e0fffe0b 	ldhu	r3,-8(fp)
  804d7c:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_RAMWR);
  804d80:	008e0004 	movi	r2,14336
  804d84:	00c00b04 	movi	r3,44
  804d88:	10c00015 	stw	r3,0(r2)
	size=(ex-sx+1)*(ey-sy+1);
  804d8c:	e0fffc0b 	ldhu	r3,-16(fp)
  804d90:	e0bffb0b 	ldhu	r2,-20(fp)
  804d94:	1885c83a 	sub	r2,r3,r2
  804d98:	11000044 	addi	r4,r2,1
  804d9c:	e0fffe0b 	ldhu	r3,-8(fp)
  804da0:	e0bffd0b 	ldhu	r2,-12(fp)
  804da4:	1885c83a 	sub	r2,r3,r2
  804da8:	10800044 	addi	r2,r2,1
  804dac:	100b883a 	mov	r5,r2
  804db0:	080b2480 	call	80b248 <__mulsi3>
  804db4:	e0bff915 	stw	r2,-28(fp)
#ifdef LCD_DMA
	start_LCD_DMA_FILL( (int)&color, size*2);
  804db8:	e0ffff04 	addi	r3,fp,-4
  804dbc:	e0bff917 	ldw	r2,-28(fp)
  804dc0:	1085883a 	add	r2,r2,r2
  804dc4:	100b883a 	mov	r5,r2
  804dc8:	1809883a 	mov	r4,r3
  804dcc:	08043f40 	call	8043f4 <start_LCD_DMA_FILL>
	loop_count=0;
  804dd0:	e03ff815 	stw	zero,-32(fp)
	flag = get_LCD_DMA_sts();
  804dd4:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  804dd8:	e0bffa15 	stw	r2,-24(fp)
	while (flag!=0){
  804ddc:	00000706 	br	804dfc <Rectangle_9341+0x138>
		flag = get_LCD_DMA_sts();
  804de0:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  804de4:	e0bffa15 	stw	r2,-24(fp)
		loop_count++;
  804de8:	e0bff817 	ldw	r2,-32(fp)
  804dec:	10800044 	addi	r2,r2,1
  804df0:	e0bff815 	stw	r2,-32(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  804df4:	01000044 	movi	r4,1
  804df8:	08023680 	call	802368 <vTaskDelay>
	size=(ex-sx+1)*(ey-sy+1);
#ifdef LCD_DMA
	start_LCD_DMA_FILL( (int)&color, size*2);
	loop_count=0;
	flag = get_LCD_DMA_sts();
	while (flag!=0){
  804dfc:	e0bffa17 	ldw	r2,-24(fp)
  804e00:	103ff71e 	bne	r2,zero,804de0 <__alt_data_end+0xfff04de0>
	for(;size>0;size--){
		Write_Data_9341((uint8_t)(color>>8));	//8bit
		Write_Data_9341((uint8_t)( color & 0xff));	//8bit
	}
#endif
	return 0;
  804e04:	0005883a 	mov	r2,zero
}
  804e08:	e037883a 	mov	sp,fp
  804e0c:	dfc00117 	ldw	ra,4(sp)
  804e10:	df000017 	ldw	fp,0(sp)
  804e14:	dec00204 	addi	sp,sp,8
  804e18:	f800283a 	ret

00804e1c <Pset_9341>:

int Pset_9341(uint16_t x, uint16_t y,uint16_t color) {
  804e1c:	defffc04 	addi	sp,sp,-16
  804e20:	df000315 	stw	fp,12(sp)
  804e24:	df000304 	addi	fp,sp,12
  804e28:	2807883a 	mov	r3,r5
  804e2c:	3005883a 	mov	r2,r6
  804e30:	e13ffd0d 	sth	r4,-12(fp)
  804e34:	e0fffe0d 	sth	r3,-8(fp)
  804e38:	e0bfff0d 	sth	r2,-4(fp)
  // 

	if((x<0) ||(x>=ILI9341_IMG_WIDTH)){		return -1;	}
  804e3c:	e0bffd0b 	ldhu	r2,-12(fp)
  804e40:	10805030 	cmpltui	r2,r2,320
  804e44:	1000021e 	bne	r2,zero,804e50 <Pset_9341+0x34>
  804e48:	00bfffc4 	movi	r2,-1
  804e4c:	00001e06 	br	804ec8 <Pset_9341+0xac>
	if((y<0) ||(y>=ILI9341_IMG_HEIGHT)){	return -1;	}
  804e50:	e0bffe0b 	ldhu	r2,-8(fp)
  804e54:	10803c30 	cmpltui	r2,r2,240
  804e58:	1000021e 	bne	r2,zero,804e64 <Pset_9341+0x48>
  804e5c:	00bfffc4 	movi	r2,-1
  804e60:	00001906 	br	804ec8 <Pset_9341+0xac>
#ifdef	DATA16EXTENTION
	Write_Command_9341(ILI9341_CASET);
  804e64:	008e0004 	movi	r2,14336
  804e68:	00c00a84 	movi	r3,42
  804e6c:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(x);
  804e70:	008e0304 	movi	r2,14348
  804e74:	e0fffd0b 	ldhu	r3,-12(fp)
  804e78:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(x);
  804e7c:	008e0304 	movi	r2,14348
  804e80:	e0fffd0b 	ldhu	r3,-12(fp)
  804e84:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_PASET);
  804e88:	008e0004 	movi	r2,14336
  804e8c:	00c00ac4 	movi	r3,43
  804e90:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(y);
  804e94:	008e0304 	movi	r2,14348
  804e98:	e0fffe0b 	ldhu	r3,-8(fp)
  804e9c:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(y);
  804ea0:	008e0304 	movi	r2,14348
  804ea4:	e0fffe0b 	ldhu	r3,-8(fp)
  804ea8:	10c00015 	stw	r3,0(r2)

	Write_Command_9341(ILI9341_RAMWR);
  804eac:	008e0004 	movi	r2,14336
  804eb0:	00c00b04 	movi	r3,44
  804eb4:	10c00015 	stw	r3,0(r2)
	Write_Data16_9341(color);
  804eb8:	008e0304 	movi	r2,14348
  804ebc:	e0ffff0b 	ldhu	r3,-4(fp)
  804ec0:	10c00015 	stw	r3,0(r2)
	Write_Command_9341(ILI9341_RAMWR);

	Write_Data_9341((uint8_t)((color>>8)));	//8bit
	Write_Data_9341((uint8_t)((color & 0xff)));	//8bit
#endif
	return 0;
  804ec4:	0005883a 	mov	r2,zero
}
  804ec8:	e037883a 	mov	sp,fp
  804ecc:	df000017 	ldw	fp,0(sp)
  804ed0:	dec00104 	addi	sp,sp,4
  804ed4:	f800283a 	ret

00804ed8 <ClearScreen_9341>:


void ClearScreen_9341(uint16_t color) {
  804ed8:	defffc04 	addi	sp,sp,-16
  804edc:	dfc00315 	stw	ra,12(sp)
  804ee0:	df000215 	stw	fp,8(sp)
  804ee4:	df000204 	addi	fp,sp,8
  804ee8:	2005883a 	mov	r2,r4
  804eec:	e0bfff0d 	sth	r2,-4(fp)
	Rectangle_9341(0,319, 0, 239,color);
  804ef0:	e0bfff0b 	ldhu	r2,-4(fp)
  804ef4:	d8800015 	stw	r2,0(sp)
  804ef8:	01c03bc4 	movi	r7,239
  804efc:	000d883a 	mov	r6,zero
  804f00:	01404fc4 	movi	r5,319
  804f04:	0009883a 	mov	r4,zero
  804f08:	0804cc40 	call	804cc4 <Rectangle_9341>
}
  804f0c:	0001883a 	nop
  804f10:	e037883a 	mov	sp,fp
  804f14:	dfc00117 	ldw	ra,4(sp)
  804f18:	df000017 	ldw	fp,0(sp)
  804f1c:	dec00204 	addi	sp,sp,8
  804f20:	f800283a 	ret

00804f24 <drawVline_9341>:

int drawVline_9341(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
  804f24:	defff904 	addi	sp,sp,-28
  804f28:	dfc00615 	stw	ra,24(sp)
  804f2c:	df000515 	stw	fp,20(sp)
  804f30:	df000504 	addi	fp,sp,20
  804f34:	2011883a 	mov	r8,r4
  804f38:	2809883a 	mov	r4,r5
  804f3c:	3007883a 	mov	r3,r6
  804f40:	3805883a 	mov	r2,r7
  804f44:	e23ffc0d 	sth	r8,-16(fp)
  804f48:	e13ffd0d 	sth	r4,-12(fp)
  804f4c:	e0fffe0d 	sth	r3,-8(fp)
  804f50:	e0bfff0d 	sth	r2,-4(fp)
	int i;

	for(i=0;i<length;i++){
  804f54:	e03ffb15 	stw	zero,-20(fp)
  804f58:	00000e06 	br	804f94 <drawVline_9341+0x70>
		Pset_9341(x, y+i,color);
  804f5c:	e0fffc0b 	ldhu	r3,-16(fp)
  804f60:	e0bffb17 	ldw	r2,-20(fp)
  804f64:	1009883a 	mov	r4,r2
  804f68:	e0bffd0b 	ldhu	r2,-12(fp)
  804f6c:	2085883a 	add	r2,r4,r2
  804f70:	10bfffcc 	andi	r2,r2,65535
  804f74:	e13fff0b 	ldhu	r4,-4(fp)
  804f78:	200d883a 	mov	r6,r4
  804f7c:	100b883a 	mov	r5,r2
  804f80:	1809883a 	mov	r4,r3
  804f84:	0804e1c0 	call	804e1c <Pset_9341>
}

int drawVline_9341(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
	int i;

	for(i=0;i<length;i++){
  804f88:	e0bffb17 	ldw	r2,-20(fp)
  804f8c:	10800044 	addi	r2,r2,1
  804f90:	e0bffb15 	stw	r2,-20(fp)
  804f94:	e0bffe0b 	ldhu	r2,-8(fp)
  804f98:	e0fffb17 	ldw	r3,-20(fp)
  804f9c:	18bfef16 	blt	r3,r2,804f5c <__alt_data_end+0xfff04f5c>
		Pset_9341(x, y+i,color);
	}

	return 0;
  804fa0:	0005883a 	mov	r2,zero
}
  804fa4:	e037883a 	mov	sp,fp
  804fa8:	dfc00117 	ldw	ra,4(sp)
  804fac:	df000017 	ldw	fp,0(sp)
  804fb0:	dec00204 	addi	sp,sp,8
  804fb4:	f800283a 	ret

00804fb8 <drawHline_9341>:

int drawHline_9341(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
  804fb8:	defff904 	addi	sp,sp,-28
  804fbc:	dfc00615 	stw	ra,24(sp)
  804fc0:	df000515 	stw	fp,20(sp)
  804fc4:	df000504 	addi	fp,sp,20
  804fc8:	2011883a 	mov	r8,r4
  804fcc:	2809883a 	mov	r4,r5
  804fd0:	3007883a 	mov	r3,r6
  804fd4:	3805883a 	mov	r2,r7
  804fd8:	e23ffc0d 	sth	r8,-16(fp)
  804fdc:	e13ffd0d 	sth	r4,-12(fp)
  804fe0:	e0fffe0d 	sth	r3,-8(fp)
  804fe4:	e0bfff0d 	sth	r2,-4(fp)
	int i;

	for(i=0;i<length;i++){
  804fe8:	e03ffb15 	stw	zero,-20(fp)
  804fec:	00000e06 	br	805028 <drawHline_9341+0x70>
		Pset_9341(x+i, y,color);
  804ff0:	e0bffb17 	ldw	r2,-20(fp)
  804ff4:	1007883a 	mov	r3,r2
  804ff8:	e0bffc0b 	ldhu	r2,-16(fp)
  804ffc:	1885883a 	add	r2,r3,r2
  805000:	10bfffcc 	andi	r2,r2,65535
  805004:	e0fffd0b 	ldhu	r3,-12(fp)
  805008:	e13fff0b 	ldhu	r4,-4(fp)
  80500c:	200d883a 	mov	r6,r4
  805010:	180b883a 	mov	r5,r3
  805014:	1009883a 	mov	r4,r2
  805018:	0804e1c0 	call	804e1c <Pset_9341>
}

int drawHline_9341(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
	int i;

	for(i=0;i<length;i++){
  80501c:	e0bffb17 	ldw	r2,-20(fp)
  805020:	10800044 	addi	r2,r2,1
  805024:	e0bffb15 	stw	r2,-20(fp)
  805028:	e0bffe0b 	ldhu	r2,-8(fp)
  80502c:	e0fffb17 	ldw	r3,-20(fp)
  805030:	18bfef16 	blt	r3,r2,804ff0 <__alt_data_end+0xfff04ff0>
		Pset_9341(x+i, y,color);
	}

	return 0;
  805034:	0005883a 	mov	r2,zero
}
  805038:	e037883a 	mov	sp,fp
  80503c:	dfc00117 	ldw	ra,4(sp)
  805040:	df000017 	ldw	fp,0(sp)
  805044:	dec00204 	addi	sp,sp,8
  805048:	f800283a 	ret

0080504c <drawLine_9341>:

int drawLine_9341(uint16_t sx,uint16_t sy,uint16_t ex,uint16_t ey,uint16_t color)
{
  80504c:	defff404 	addi	sp,sp,-48
  805050:	dfc00b15 	stw	ra,44(sp)
  805054:	df000a15 	stw	fp,40(sp)
  805058:	dc000915 	stw	r16,36(sp)
  80505c:	df000a04 	addi	fp,sp,40
  805060:	2011883a 	mov	r8,r4
  805064:	3009883a 	mov	r4,r6
  805068:	3807883a 	mov	r3,r7
  80506c:	e0800217 	ldw	r2,8(fp)
  805070:	e23ffa0d 	sth	r8,-24(fp)
  805074:	e17ffb0d 	sth	r5,-20(fp)
  805078:	e13ffc0d 	sth	r4,-16(fp)
  80507c:	e0fffd0d 	sth	r3,-12(fp)
  805080:	e0bffe0d 	sth	r2,-8(fp)
	float a,b;
	int x,y;


	if((sx<0)||(sx>=ILI9341_IMG_WIDTH))		return -1;
  805084:	e0bffa0b 	ldhu	r2,-24(fp)
  805088:	10805030 	cmpltui	r2,r2,320
  80508c:	1000021e 	bne	r2,zero,805098 <drawLine_9341+0x4c>
  805090:	00bfffc4 	movi	r2,-1
  805094:	0001b706 	br	805774 <drawLine_9341+0x728>
	if((sy<0)||(sy>=ILI9341_IMG_HEIGHT))	return -1;
  805098:	e0bffb0b 	ldhu	r2,-20(fp)
  80509c:	10803c30 	cmpltui	r2,r2,240
  8050a0:	1000021e 	bne	r2,zero,8050ac <drawLine_9341+0x60>
  8050a4:	00bfffc4 	movi	r2,-1
  8050a8:	0001b206 	br	805774 <drawLine_9341+0x728>
	if((ex<0)||(ex>=ILI9341_IMG_WIDTH))		return -1;
  8050ac:	e0bffc0b 	ldhu	r2,-16(fp)
  8050b0:	10805030 	cmpltui	r2,r2,320
  8050b4:	1000021e 	bne	r2,zero,8050c0 <drawLine_9341+0x74>
  8050b8:	00bfffc4 	movi	r2,-1
  8050bc:	0001ad06 	br	805774 <drawLine_9341+0x728>
	if((ey<0)||(ey>=ILI9341_IMG_HEIGHT))	return -1;
  8050c0:	e0bffd0b 	ldhu	r2,-12(fp)
  8050c4:	10803c30 	cmpltui	r2,r2,240
  8050c8:	1000021e 	bne	r2,zero,8050d4 <drawLine_9341+0x88>
  8050cc:	00bfffc4 	movi	r2,-1
  8050d0:	0001a806 	br	805774 <drawLine_9341+0x728>

	if(sx==ex){
  8050d4:	e0fffa0b 	ldhu	r3,-24(fp)
  8050d8:	e0bffc0b 	ldhu	r2,-16(fp)
  8050dc:	1880251e 	bne	r3,r2,805174 <drawLine_9341+0x128>
		if(sy<ey){
  8050e0:	e0fffb0b 	ldhu	r3,-20(fp)
  8050e4:	e0bffd0b 	ldhu	r2,-12(fp)
  8050e8:	18800c2e 	bgeu	r3,r2,80511c <drawLine_9341+0xd0>
			drawVline_9341(sx,sy,(ey-sy+1),color);
  8050ec:	e13ffa0b 	ldhu	r4,-24(fp)
  8050f0:	e17ffb0b 	ldhu	r5,-20(fp)
  8050f4:	e0fffd0b 	ldhu	r3,-12(fp)
  8050f8:	e0bffb0b 	ldhu	r2,-20(fp)
  8050fc:	1885c83a 	sub	r2,r3,r2
  805100:	10800044 	addi	r2,r2,1
  805104:	10bfffcc 	andi	r2,r2,65535
  805108:	e0fffe0b 	ldhu	r3,-8(fp)
  80510c:	180f883a 	mov	r7,r3
  805110:	100d883a 	mov	r6,r2
  805114:	0804f240 	call	804f24 <drawVline_9341>
  805118:	00001606 	br	805174 <drawLine_9341+0x128>
		}
		else if(ey<sy){
  80511c:	e0fffd0b 	ldhu	r3,-12(fp)
  805120:	e0bffb0b 	ldhu	r2,-20(fp)
  805124:	18800c2e 	bgeu	r3,r2,805158 <drawLine_9341+0x10c>
			drawVline_9341(sx,ey,(sy-ey+1),color);
  805128:	e13ffa0b 	ldhu	r4,-24(fp)
  80512c:	e17ffd0b 	ldhu	r5,-12(fp)
  805130:	e0fffb0b 	ldhu	r3,-20(fp)
  805134:	e0bffd0b 	ldhu	r2,-12(fp)
  805138:	1885c83a 	sub	r2,r3,r2
  80513c:	10800044 	addi	r2,r2,1
  805140:	10bfffcc 	andi	r2,r2,65535
  805144:	e0fffe0b 	ldhu	r3,-8(fp)
  805148:	180f883a 	mov	r7,r3
  80514c:	100d883a 	mov	r6,r2
  805150:	0804f240 	call	804f24 <drawVline_9341>
  805154:	00000706 	br	805174 <drawLine_9341+0x128>
		}
		else{
			Pset_9341(sx,sy,color);
  805158:	e0bffa0b 	ldhu	r2,-24(fp)
  80515c:	e0fffb0b 	ldhu	r3,-20(fp)
  805160:	e13ffe0b 	ldhu	r4,-8(fp)
  805164:	200d883a 	mov	r6,r4
  805168:	180b883a 	mov	r5,r3
  80516c:	1009883a 	mov	r4,r2
  805170:	0804e1c0 	call	804e1c <Pset_9341>
		}
	}

	if(sy==ey){
  805174:	e0fffb0b 	ldhu	r3,-20(fp)
  805178:	e0bffd0b 	ldhu	r2,-12(fp)
  80517c:	1880251e 	bne	r3,r2,805214 <drawLine_9341+0x1c8>
		if(sx<ex){
  805180:	e0fffa0b 	ldhu	r3,-24(fp)
  805184:	e0bffc0b 	ldhu	r2,-16(fp)
  805188:	18800c2e 	bgeu	r3,r2,8051bc <drawLine_9341+0x170>
			drawHline_9341(sx,sy,(ex-sx+1),color);
  80518c:	e13ffa0b 	ldhu	r4,-24(fp)
  805190:	e17ffb0b 	ldhu	r5,-20(fp)
  805194:	e0fffc0b 	ldhu	r3,-16(fp)
  805198:	e0bffa0b 	ldhu	r2,-24(fp)
  80519c:	1885c83a 	sub	r2,r3,r2
  8051a0:	10800044 	addi	r2,r2,1
  8051a4:	10bfffcc 	andi	r2,r2,65535
  8051a8:	e0fffe0b 	ldhu	r3,-8(fp)
  8051ac:	180f883a 	mov	r7,r3
  8051b0:	100d883a 	mov	r6,r2
  8051b4:	0804fb80 	call	804fb8 <drawHline_9341>
  8051b8:	00001606 	br	805214 <drawLine_9341+0x1c8>
		}
		else if(ex<sx){
  8051bc:	e0fffc0b 	ldhu	r3,-16(fp)
  8051c0:	e0bffa0b 	ldhu	r2,-24(fp)
  8051c4:	18800c2e 	bgeu	r3,r2,8051f8 <drawLine_9341+0x1ac>
			drawHline_9341(ex,sy,(sx-ex+1),color);
  8051c8:	e13ffc0b 	ldhu	r4,-16(fp)
  8051cc:	e17ffb0b 	ldhu	r5,-20(fp)
  8051d0:	e0fffa0b 	ldhu	r3,-24(fp)
  8051d4:	e0bffc0b 	ldhu	r2,-16(fp)
  8051d8:	1885c83a 	sub	r2,r3,r2
  8051dc:	10800044 	addi	r2,r2,1
  8051e0:	10bfffcc 	andi	r2,r2,65535
  8051e4:	e0fffe0b 	ldhu	r3,-8(fp)
  8051e8:	180f883a 	mov	r7,r3
  8051ec:	100d883a 	mov	r6,r2
  8051f0:	0804fb80 	call	804fb8 <drawHline_9341>
  8051f4:	00000706 	br	805214 <drawLine_9341+0x1c8>
		}
		else{
			Pset_9341(sx,sy,color);
  8051f8:	e0bffa0b 	ldhu	r2,-24(fp)
  8051fc:	e0fffb0b 	ldhu	r3,-20(fp)
  805200:	e13ffe0b 	ldhu	r4,-8(fp)
  805204:	200d883a 	mov	r6,r4
  805208:	180b883a 	mov	r5,r3
  80520c:	1009883a 	mov	r4,r2
  805210:	0804e1c0 	call	804e1c <Pset_9341>
		}
	}

	if(abs(ex-sx)>abs(ey-sy))
  805214:	e0fffc0b 	ldhu	r3,-16(fp)
  805218:	e0bffa0b 	ldhu	r2,-24(fp)
  80521c:	1885c83a 	sub	r2,r3,r2
  805220:	1000010e 	bge	r2,zero,805228 <drawLine_9341+0x1dc>
  805224:	0085c83a 	sub	r2,zero,r2
  805228:	1009883a 	mov	r4,r2
  80522c:	e0fffd0b 	ldhu	r3,-12(fp)
  805230:	e0bffb0b 	ldhu	r2,-20(fp)
  805234:	1885c83a 	sub	r2,r3,r2
  805238:	1000010e 	bge	r2,zero,805240 <drawLine_9341+0x1f4>
  80523c:	0085c83a 	sub	r2,zero,r2
  805240:	1100a60e 	bge	r2,r4,8054dc <drawLine_9341+0x490>
	{	//y = ax + b
		b=(float)(sy*ex-ey*sx)/(float)(ex-sx);
  805244:	e0bffb0b 	ldhu	r2,-20(fp)
  805248:	e0fffc0b 	ldhu	r3,-16(fp)
  80524c:	180b883a 	mov	r5,r3
  805250:	1009883a 	mov	r4,r2
  805254:	080b2480 	call	80b248 <__mulsi3>
  805258:	1021883a 	mov	r16,r2
  80525c:	e0bffd0b 	ldhu	r2,-12(fp)
  805260:	e0fffa0b 	ldhu	r3,-24(fp)
  805264:	180b883a 	mov	r5,r3
  805268:	1009883a 	mov	r4,r2
  80526c:	080b2480 	call	80b248 <__mulsi3>
  805270:	8085c83a 	sub	r2,r16,r2
  805274:	1009883a 	mov	r4,r2
  805278:	080c5b80 	call	80c5b8 <__floatsisf>
  80527c:	1021883a 	mov	r16,r2
  805280:	e0fffc0b 	ldhu	r3,-16(fp)
  805284:	e0bffa0b 	ldhu	r2,-24(fp)
  805288:	1885c83a 	sub	r2,r3,r2
  80528c:	1009883a 	mov	r4,r2
  805290:	080c5b80 	call	80c5b8 <__floatsisf>
  805294:	1007883a 	mov	r3,r2
  805298:	180b883a 	mov	r5,r3
  80529c:	8009883a 	mov	r4,r16
  8052a0:	080b7380 	call	80b738 <__divsf3>
  8052a4:	1007883a 	mov	r3,r2
  8052a8:	e0fff915 	stw	r3,-28(fp)
		if(ex!=0){
  8052ac:	e0bffc0b 	ldhu	r2,-16(fp)
  8052b0:	10001326 	beq	r2,zero,805300 <drawLine_9341+0x2b4>
			a=((float)ey-b)/(float)ex;
  8052b4:	e0bffd0b 	ldhu	r2,-12(fp)
  8052b8:	1009883a 	mov	r4,r2
  8052bc:	080c6dc0 	call	80c6dc <__floatunsisf>
  8052c0:	1007883a 	mov	r3,r2
  8052c4:	e17ff917 	ldw	r5,-28(fp)
  8052c8:	1809883a 	mov	r4,r3
  8052cc:	080c0640 	call	80c064 <__subsf3>
  8052d0:	1007883a 	mov	r3,r2
  8052d4:	1821883a 	mov	r16,r3
  8052d8:	e0bffc0b 	ldhu	r2,-16(fp)
  8052dc:	1009883a 	mov	r4,r2
  8052e0:	080c6dc0 	call	80c6dc <__floatunsisf>
  8052e4:	1007883a 	mov	r3,r2
  8052e8:	180b883a 	mov	r5,r3
  8052ec:	8009883a 	mov	r4,r16
  8052f0:	080b7380 	call	80b738 <__divsf3>
  8052f4:	1007883a 	mov	r3,r2
  8052f8:	e0fff615 	stw	r3,-40(fp)
  8052fc:	00001206 	br	805348 <drawLine_9341+0x2fc>
		}else{
			a=((float)sy-b)/(float)sx;
  805300:	e0bffb0b 	ldhu	r2,-20(fp)
  805304:	1009883a 	mov	r4,r2
  805308:	080c6dc0 	call	80c6dc <__floatunsisf>
  80530c:	1007883a 	mov	r3,r2
  805310:	e17ff917 	ldw	r5,-28(fp)
  805314:	1809883a 	mov	r4,r3
  805318:	080c0640 	call	80c064 <__subsf3>
  80531c:	1007883a 	mov	r3,r2
  805320:	1821883a 	mov	r16,r3
  805324:	e0bffa0b 	ldhu	r2,-24(fp)
  805328:	1009883a 	mov	r4,r2
  80532c:	080c6dc0 	call	80c6dc <__floatunsisf>
  805330:	1007883a 	mov	r3,r2
  805334:	180b883a 	mov	r5,r3
  805338:	8009883a 	mov	r4,r16
  80533c:	080b7380 	call	80b738 <__divsf3>
  805340:	1007883a 	mov	r3,r2
  805344:	e0fff615 	stw	r3,-40(fp)
		}

		if (sx<ex){
  805348:	e0fffa0b 	ldhu	r3,-24(fp)
  80534c:	e0bffc0b 	ldhu	r2,-16(fp)
  805350:	1880312e 	bgeu	r3,r2,805418 <drawLine_9341+0x3cc>
			for(x=sx;x<=ex;x++){
  805354:	e0bffa0b 	ldhu	r2,-24(fp)
  805358:	e0bff715 	stw	r2,-36(fp)
  80535c:	00002a06 	br	805408 <drawLine_9341+0x3bc>
				y=(int)(((x*a)+b)+0.5);
  805360:	e13ff717 	ldw	r4,-36(fp)
  805364:	080c5b80 	call	80c5b8 <__floatsisf>
  805368:	1007883a 	mov	r3,r2
  80536c:	e17ff617 	ldw	r5,-40(fp)
  805370:	1809883a 	mov	r4,r3
  805374:	080bc340 	call	80bc34 <__mulsf3>
  805378:	1007883a 	mov	r3,r2
  80537c:	1805883a 	mov	r2,r3
  805380:	e17ff917 	ldw	r5,-28(fp)
  805384:	1009883a 	mov	r4,r2
  805388:	080b2700 	call	80b270 <__addsf3>
  80538c:	1007883a 	mov	r3,r2
  805390:	1805883a 	mov	r2,r3
  805394:	1009883a 	mov	r4,r2
  805398:	080ef640 	call	80ef64 <__extendsfdf2>
  80539c:	1011883a 	mov	r8,r2
  8053a0:	1813883a 	mov	r9,r3
  8053a4:	000d883a 	mov	r6,zero
  8053a8:	01cff834 	movhi	r7,16352
  8053ac:	4009883a 	mov	r4,r8
  8053b0:	480b883a 	mov	r5,r9
  8053b4:	080c7cc0 	call	80c7cc <__adddf3>
  8053b8:	1009883a 	mov	r4,r2
  8053bc:	180b883a 	mov	r5,r3
  8053c0:	2005883a 	mov	r2,r4
  8053c4:	2807883a 	mov	r3,r5
  8053c8:	1009883a 	mov	r4,r2
  8053cc:	180b883a 	mov	r5,r3
  8053d0:	080ee080 	call	80ee08 <__fixdfsi>
  8053d4:	e0bff815 	stw	r2,-32(fp)
				Pset_9341(x,y,color);
  8053d8:	e0bff717 	ldw	r2,-36(fp)
  8053dc:	10ffffcc 	andi	r3,r2,65535
  8053e0:	e0bff817 	ldw	r2,-32(fp)
  8053e4:	10bfffcc 	andi	r2,r2,65535
  8053e8:	e13ffe0b 	ldhu	r4,-8(fp)
  8053ec:	200d883a 	mov	r6,r4
  8053f0:	100b883a 	mov	r5,r2
  8053f4:	1809883a 	mov	r4,r3
  8053f8:	0804e1c0 	call	804e1c <Pset_9341>
		}else{
			a=((float)sy-b)/(float)sx;
		}

		if (sx<ex){
			for(x=sx;x<=ex;x++){
  8053fc:	e0bff717 	ldw	r2,-36(fp)
  805400:	10800044 	addi	r2,r2,1
  805404:	e0bff715 	stw	r2,-36(fp)
  805408:	e0fffc0b 	ldhu	r3,-16(fp)
  80540c:	e0bff717 	ldw	r2,-36(fp)
  805410:	18bfd30e 	bge	r3,r2,805360 <__alt_data_end+0xfff05360>
  805414:	0000d606 	br	805770 <drawLine_9341+0x724>
				y=(int)(((x*a)+b)+0.5);
				Pset_9341(x,y,color);
			}
		}
		else{
			for(x=ex;x<=sx;x++){
  805418:	e0bffc0b 	ldhu	r2,-16(fp)
  80541c:	e0bff715 	stw	r2,-36(fp)
  805420:	00002a06 	br	8054cc <drawLine_9341+0x480>
				y=(int)(((x*a)+b)+0.5);
  805424:	e13ff717 	ldw	r4,-36(fp)
  805428:	080c5b80 	call	80c5b8 <__floatsisf>
  80542c:	1007883a 	mov	r3,r2
  805430:	e17ff617 	ldw	r5,-40(fp)
  805434:	1809883a 	mov	r4,r3
  805438:	080bc340 	call	80bc34 <__mulsf3>
  80543c:	1007883a 	mov	r3,r2
  805440:	1805883a 	mov	r2,r3
  805444:	e17ff917 	ldw	r5,-28(fp)
  805448:	1009883a 	mov	r4,r2
  80544c:	080b2700 	call	80b270 <__addsf3>
  805450:	1007883a 	mov	r3,r2
  805454:	1805883a 	mov	r2,r3
  805458:	1009883a 	mov	r4,r2
  80545c:	080ef640 	call	80ef64 <__extendsfdf2>
  805460:	1011883a 	mov	r8,r2
  805464:	1813883a 	mov	r9,r3
  805468:	000d883a 	mov	r6,zero
  80546c:	01cff834 	movhi	r7,16352
  805470:	4009883a 	mov	r4,r8
  805474:	480b883a 	mov	r5,r9
  805478:	080c7cc0 	call	80c7cc <__adddf3>
  80547c:	1009883a 	mov	r4,r2
  805480:	180b883a 	mov	r5,r3
  805484:	2005883a 	mov	r2,r4
  805488:	2807883a 	mov	r3,r5
  80548c:	1009883a 	mov	r4,r2
  805490:	180b883a 	mov	r5,r3
  805494:	080ee080 	call	80ee08 <__fixdfsi>
  805498:	e0bff815 	stw	r2,-32(fp)
				Pset_9341(x,y,color);
  80549c:	e0bff717 	ldw	r2,-36(fp)
  8054a0:	10ffffcc 	andi	r3,r2,65535
  8054a4:	e0bff817 	ldw	r2,-32(fp)
  8054a8:	10bfffcc 	andi	r2,r2,65535
  8054ac:	e13ffe0b 	ldhu	r4,-8(fp)
  8054b0:	200d883a 	mov	r6,r4
  8054b4:	100b883a 	mov	r5,r2
  8054b8:	1809883a 	mov	r4,r3
  8054bc:	0804e1c0 	call	804e1c <Pset_9341>
				y=(int)(((x*a)+b)+0.5);
				Pset_9341(x,y,color);
			}
		}
		else{
			for(x=ex;x<=sx;x++){
  8054c0:	e0bff717 	ldw	r2,-36(fp)
  8054c4:	10800044 	addi	r2,r2,1
  8054c8:	e0bff715 	stw	r2,-36(fp)
  8054cc:	e0fffa0b 	ldhu	r3,-24(fp)
  8054d0:	e0bff717 	ldw	r2,-36(fp)
  8054d4:	18bfd30e 	bge	r3,r2,805424 <__alt_data_end+0xfff05424>
  8054d8:	0000a506 	br	805770 <drawLine_9341+0x724>
			}

		}
	}else{
		//x = ay + b
		b=(float)(sx*ey-ex*sy)/(float)(ey-sy);
  8054dc:	e0bffa0b 	ldhu	r2,-24(fp)
  8054e0:	e0fffd0b 	ldhu	r3,-12(fp)
  8054e4:	180b883a 	mov	r5,r3
  8054e8:	1009883a 	mov	r4,r2
  8054ec:	080b2480 	call	80b248 <__mulsi3>
  8054f0:	1021883a 	mov	r16,r2
  8054f4:	e0bffc0b 	ldhu	r2,-16(fp)
  8054f8:	e0fffb0b 	ldhu	r3,-20(fp)
  8054fc:	180b883a 	mov	r5,r3
  805500:	1009883a 	mov	r4,r2
  805504:	080b2480 	call	80b248 <__mulsi3>
  805508:	8085c83a 	sub	r2,r16,r2
  80550c:	1009883a 	mov	r4,r2
  805510:	080c5b80 	call	80c5b8 <__floatsisf>
  805514:	1021883a 	mov	r16,r2
  805518:	e0fffd0b 	ldhu	r3,-12(fp)
  80551c:	e0bffb0b 	ldhu	r2,-20(fp)
  805520:	1885c83a 	sub	r2,r3,r2
  805524:	1009883a 	mov	r4,r2
  805528:	080c5b80 	call	80c5b8 <__floatsisf>
  80552c:	1007883a 	mov	r3,r2
  805530:	180b883a 	mov	r5,r3
  805534:	8009883a 	mov	r4,r16
  805538:	080b7380 	call	80b738 <__divsf3>
  80553c:	1007883a 	mov	r3,r2
  805540:	e0fff915 	stw	r3,-28(fp)
		if(ey!=0){
  805544:	e0bffd0b 	ldhu	r2,-12(fp)
  805548:	10001326 	beq	r2,zero,805598 <drawLine_9341+0x54c>
			a=((float)ex-b)/(float)ey;
  80554c:	e0bffc0b 	ldhu	r2,-16(fp)
  805550:	1009883a 	mov	r4,r2
  805554:	080c6dc0 	call	80c6dc <__floatunsisf>
  805558:	1007883a 	mov	r3,r2
  80555c:	e17ff917 	ldw	r5,-28(fp)
  805560:	1809883a 	mov	r4,r3
  805564:	080c0640 	call	80c064 <__subsf3>
  805568:	1007883a 	mov	r3,r2
  80556c:	1821883a 	mov	r16,r3
  805570:	e0bffd0b 	ldhu	r2,-12(fp)
  805574:	1009883a 	mov	r4,r2
  805578:	080c6dc0 	call	80c6dc <__floatunsisf>
  80557c:	1007883a 	mov	r3,r2
  805580:	180b883a 	mov	r5,r3
  805584:	8009883a 	mov	r4,r16
  805588:	080b7380 	call	80b738 <__divsf3>
  80558c:	1007883a 	mov	r3,r2
  805590:	e0fff615 	stw	r3,-40(fp)
  805594:	00001206 	br	8055e0 <drawLine_9341+0x594>
		}else{
			a=((float)sx-b)/(float)sy;
  805598:	e0bffa0b 	ldhu	r2,-24(fp)
  80559c:	1009883a 	mov	r4,r2
  8055a0:	080c6dc0 	call	80c6dc <__floatunsisf>
  8055a4:	1007883a 	mov	r3,r2
  8055a8:	e17ff917 	ldw	r5,-28(fp)
  8055ac:	1809883a 	mov	r4,r3
  8055b0:	080c0640 	call	80c064 <__subsf3>
  8055b4:	1007883a 	mov	r3,r2
  8055b8:	1821883a 	mov	r16,r3
  8055bc:	e0bffb0b 	ldhu	r2,-20(fp)
  8055c0:	1009883a 	mov	r4,r2
  8055c4:	080c6dc0 	call	80c6dc <__floatunsisf>
  8055c8:	1007883a 	mov	r3,r2
  8055cc:	180b883a 	mov	r5,r3
  8055d0:	8009883a 	mov	r4,r16
  8055d4:	080b7380 	call	80b738 <__divsf3>
  8055d8:	1007883a 	mov	r3,r2
  8055dc:	e0fff615 	stw	r3,-40(fp)
		}
		if (sy<ey){
  8055e0:	e0fffb0b 	ldhu	r3,-20(fp)
  8055e4:	e0bffd0b 	ldhu	r2,-12(fp)
  8055e8:	1880312e 	bgeu	r3,r2,8056b0 <drawLine_9341+0x664>
			for(y=sy;y<=ey;y++){
  8055ec:	e0bffb0b 	ldhu	r2,-20(fp)
  8055f0:	e0bff815 	stw	r2,-32(fp)
  8055f4:	00002a06 	br	8056a0 <drawLine_9341+0x654>
				x=(int)(((y*a)+b)+0.5);
  8055f8:	e13ff817 	ldw	r4,-32(fp)
  8055fc:	080c5b80 	call	80c5b8 <__floatsisf>
  805600:	1007883a 	mov	r3,r2
  805604:	e17ff617 	ldw	r5,-40(fp)
  805608:	1809883a 	mov	r4,r3
  80560c:	080bc340 	call	80bc34 <__mulsf3>
  805610:	1007883a 	mov	r3,r2
  805614:	1805883a 	mov	r2,r3
  805618:	e17ff917 	ldw	r5,-28(fp)
  80561c:	1009883a 	mov	r4,r2
  805620:	080b2700 	call	80b270 <__addsf3>
  805624:	1007883a 	mov	r3,r2
  805628:	1805883a 	mov	r2,r3
  80562c:	1009883a 	mov	r4,r2
  805630:	080ef640 	call	80ef64 <__extendsfdf2>
  805634:	1011883a 	mov	r8,r2
  805638:	1813883a 	mov	r9,r3
  80563c:	000d883a 	mov	r6,zero
  805640:	01cff834 	movhi	r7,16352
  805644:	4009883a 	mov	r4,r8
  805648:	480b883a 	mov	r5,r9
  80564c:	080c7cc0 	call	80c7cc <__adddf3>
  805650:	1009883a 	mov	r4,r2
  805654:	180b883a 	mov	r5,r3
  805658:	2005883a 	mov	r2,r4
  80565c:	2807883a 	mov	r3,r5
  805660:	1009883a 	mov	r4,r2
  805664:	180b883a 	mov	r5,r3
  805668:	080ee080 	call	80ee08 <__fixdfsi>
  80566c:	e0bff715 	stw	r2,-36(fp)
				Pset_9341(x,y,color);
  805670:	e0bff717 	ldw	r2,-36(fp)
  805674:	10ffffcc 	andi	r3,r2,65535
  805678:	e0bff817 	ldw	r2,-32(fp)
  80567c:	10bfffcc 	andi	r2,r2,65535
  805680:	e13ffe0b 	ldhu	r4,-8(fp)
  805684:	200d883a 	mov	r6,r4
  805688:	100b883a 	mov	r5,r2
  80568c:	1809883a 	mov	r4,r3
  805690:	0804e1c0 	call	804e1c <Pset_9341>
			a=((float)ex-b)/(float)ey;
		}else{
			a=((float)sx-b)/(float)sy;
		}
		if (sy<ey){
			for(y=sy;y<=ey;y++){
  805694:	e0bff817 	ldw	r2,-32(fp)
  805698:	10800044 	addi	r2,r2,1
  80569c:	e0bff815 	stw	r2,-32(fp)
  8056a0:	e0fffd0b 	ldhu	r3,-12(fp)
  8056a4:	e0bff817 	ldw	r2,-32(fp)
  8056a8:	18bfd30e 	bge	r3,r2,8055f8 <__alt_data_end+0xfff055f8>
  8056ac:	00003006 	br	805770 <drawLine_9341+0x724>
				x=(int)(((y*a)+b)+0.5);
				Pset_9341(x,y,color);
			}
		}
		else{
			for(y=ey;y<=sy;y++){
  8056b0:	e0bffd0b 	ldhu	r2,-12(fp)
  8056b4:	e0bff815 	stw	r2,-32(fp)
  8056b8:	00002a06 	br	805764 <drawLine_9341+0x718>
				x=(int)(((y*a)+b)+0.5);
  8056bc:	e13ff817 	ldw	r4,-32(fp)
  8056c0:	080c5b80 	call	80c5b8 <__floatsisf>
  8056c4:	1007883a 	mov	r3,r2
  8056c8:	e17ff617 	ldw	r5,-40(fp)
  8056cc:	1809883a 	mov	r4,r3
  8056d0:	080bc340 	call	80bc34 <__mulsf3>
  8056d4:	1007883a 	mov	r3,r2
  8056d8:	1805883a 	mov	r2,r3
  8056dc:	e17ff917 	ldw	r5,-28(fp)
  8056e0:	1009883a 	mov	r4,r2
  8056e4:	080b2700 	call	80b270 <__addsf3>
  8056e8:	1007883a 	mov	r3,r2
  8056ec:	1805883a 	mov	r2,r3
  8056f0:	1009883a 	mov	r4,r2
  8056f4:	080ef640 	call	80ef64 <__extendsfdf2>
  8056f8:	1011883a 	mov	r8,r2
  8056fc:	1813883a 	mov	r9,r3
  805700:	000d883a 	mov	r6,zero
  805704:	01cff834 	movhi	r7,16352
  805708:	4009883a 	mov	r4,r8
  80570c:	480b883a 	mov	r5,r9
  805710:	080c7cc0 	call	80c7cc <__adddf3>
  805714:	1009883a 	mov	r4,r2
  805718:	180b883a 	mov	r5,r3
  80571c:	2005883a 	mov	r2,r4
  805720:	2807883a 	mov	r3,r5
  805724:	1009883a 	mov	r4,r2
  805728:	180b883a 	mov	r5,r3
  80572c:	080ee080 	call	80ee08 <__fixdfsi>
  805730:	e0bff715 	stw	r2,-36(fp)
				Pset_9341(x,y,color);
  805734:	e0bff717 	ldw	r2,-36(fp)
  805738:	10ffffcc 	andi	r3,r2,65535
  80573c:	e0bff817 	ldw	r2,-32(fp)
  805740:	10bfffcc 	andi	r2,r2,65535
  805744:	e13ffe0b 	ldhu	r4,-8(fp)
  805748:	200d883a 	mov	r6,r4
  80574c:	100b883a 	mov	r5,r2
  805750:	1809883a 	mov	r4,r3
  805754:	0804e1c0 	call	804e1c <Pset_9341>
				x=(int)(((y*a)+b)+0.5);
				Pset_9341(x,y,color);
			}
		}
		else{
			for(y=ey;y<=sy;y++){
  805758:	e0bff817 	ldw	r2,-32(fp)
  80575c:	10800044 	addi	r2,r2,1
  805760:	e0bff815 	stw	r2,-32(fp)
  805764:	e0fffb0b 	ldhu	r3,-20(fp)
  805768:	e0bff817 	ldw	r2,-32(fp)
  80576c:	18bfd30e 	bge	r3,r2,8056bc <__alt_data_end+0xfff056bc>
				x=(int)(((y*a)+b)+0.5);
				Pset_9341(x,y,color);
			}
		}
	}
	return 0;
  805770:	0005883a 	mov	r2,zero
}
  805774:	e6ffff04 	addi	sp,fp,-4
  805778:	dfc00217 	ldw	ra,8(sp)
  80577c:	df000117 	ldw	fp,4(sp)
  805780:	dc000017 	ldw	r16,0(sp)
  805784:	dec00304 	addi	sp,sp,12
  805788:	f800283a 	ret

0080578c <Box_9341>:


int Box_9341(uint16_t xs,uint16_t ys, uint16_t xe,uint16_t ye,uint16_t color){
  80578c:	defff904 	addi	sp,sp,-28
  805790:	dfc00615 	stw	ra,24(sp)
  805794:	df000515 	stw	fp,20(sp)
  805798:	df000504 	addi	fp,sp,20
  80579c:	2011883a 	mov	r8,r4
  8057a0:	3009883a 	mov	r4,r6
  8057a4:	3807883a 	mov	r3,r7
  8057a8:	e0800217 	ldw	r2,8(fp)
  8057ac:	e23ffb0d 	sth	r8,-20(fp)
  8057b0:	e17ffc0d 	sth	r5,-16(fp)
  8057b4:	e13ffd0d 	sth	r4,-12(fp)
  8057b8:	e0fffe0d 	sth	r3,-8(fp)
  8057bc:	e0bfff0d 	sth	r2,-4(fp)

	drawVline_9341(xs,ys,(ye-ys+1),color);
  8057c0:	e13ffb0b 	ldhu	r4,-20(fp)
  8057c4:	e17ffc0b 	ldhu	r5,-16(fp)
  8057c8:	e0fffe0b 	ldhu	r3,-8(fp)
  8057cc:	e0bffc0b 	ldhu	r2,-16(fp)
  8057d0:	1885c83a 	sub	r2,r3,r2
  8057d4:	10800044 	addi	r2,r2,1
  8057d8:	10bfffcc 	andi	r2,r2,65535
  8057dc:	e0ffff0b 	ldhu	r3,-4(fp)
  8057e0:	180f883a 	mov	r7,r3
  8057e4:	100d883a 	mov	r6,r2
  8057e8:	0804f240 	call	804f24 <drawVline_9341>
	drawVline_9341(xe,ys,(ye-ys+1),color);
  8057ec:	e13ffd0b 	ldhu	r4,-12(fp)
  8057f0:	e17ffc0b 	ldhu	r5,-16(fp)
  8057f4:	e0fffe0b 	ldhu	r3,-8(fp)
  8057f8:	e0bffc0b 	ldhu	r2,-16(fp)
  8057fc:	1885c83a 	sub	r2,r3,r2
  805800:	10800044 	addi	r2,r2,1
  805804:	10bfffcc 	andi	r2,r2,65535
  805808:	e0ffff0b 	ldhu	r3,-4(fp)
  80580c:	180f883a 	mov	r7,r3
  805810:	100d883a 	mov	r6,r2
  805814:	0804f240 	call	804f24 <drawVline_9341>
	drawHline_9341(xs,ys,(xe-xs+1),color);
  805818:	e13ffb0b 	ldhu	r4,-20(fp)
  80581c:	e17ffc0b 	ldhu	r5,-16(fp)
  805820:	e0fffd0b 	ldhu	r3,-12(fp)
  805824:	e0bffb0b 	ldhu	r2,-20(fp)
  805828:	1885c83a 	sub	r2,r3,r2
  80582c:	10800044 	addi	r2,r2,1
  805830:	10bfffcc 	andi	r2,r2,65535
  805834:	e0ffff0b 	ldhu	r3,-4(fp)
  805838:	180f883a 	mov	r7,r3
  80583c:	100d883a 	mov	r6,r2
  805840:	0804fb80 	call	804fb8 <drawHline_9341>
	drawHline_9341(xs,ye,(xe-xs+1),color);
  805844:	e13ffb0b 	ldhu	r4,-20(fp)
  805848:	e17ffe0b 	ldhu	r5,-8(fp)
  80584c:	e0fffd0b 	ldhu	r3,-12(fp)
  805850:	e0bffb0b 	ldhu	r2,-20(fp)
  805854:	1885c83a 	sub	r2,r3,r2
  805858:	10800044 	addi	r2,r2,1
  80585c:	10bfffcc 	andi	r2,r2,65535
  805860:	e0ffff0b 	ldhu	r3,-4(fp)
  805864:	180f883a 	mov	r7,r3
  805868:	100d883a 	mov	r6,r2
  80586c:	0804fb80 	call	804fb8 <drawHline_9341>
	return 0;
  805870:	0005883a 	mov	r2,zero
}
  805874:	e037883a 	mov	sp,fp
  805878:	dfc00117 	ldw	ra,4(sp)
  80587c:	df000017 	ldw	fp,0(sp)
  805880:	dec00204 	addi	sp,sp,8
  805884:	f800283a 	ret

00805888 <init_DMAMOD>:
//
//	SDRAMFT245C^tF[XW[iFIFOAhXj]T|[g
//


void init_DMAMOD(DMAMOD *p){
  805888:	defffe04 	addi	sp,sp,-8
  80588c:	df000115 	stw	fp,4(sp)
  805890:	df000104 	addi	fp,sp,4
  805894:	e13fff15 	stw	r4,-4(fp)
	p->CTRLreg = 	_b_DMA_SWRESET;	//soft reset
  805898:	e0bfff17 	ldw	r2,-4(fp)
  80589c:	00c40004 	movi	r3,4096
  8058a0:	10c00615 	stw	r3,24(r2)
	p->CTRLreg = 	0;	//soft reset
  8058a4:	e0bfff17 	ldw	r2,-4(fp)
  8058a8:	10000615 	stw	zero,24(r2)

	p->CTRLreg = 	_b_DMA_WORD		//32bit only
  8058ac:	e0bfff17 	ldw	r2,-4(fp)
  8058b0:	00c0a104 	movi	r3,644
  8058b4:	10c00615 	stw	r3,24(r2)
				|	_b_DMA_WCON		//destination is fixed address;
				|	_b_DMA_LEEN	;				//source address increment
									//disable interrupt
}
  8058b8:	0001883a 	nop
  8058bc:	e037883a 	mov	sp,fp
  8058c0:	df000017 	ldw	fp,0(sp)
  8058c4:	dec00104 	addi	sp,sp,4
  8058c8:	f800283a 	ret

008058cc <startDMA>:

void startDMA(DMAMOD *p,int src_addr,int dst_addr,int length){
  8058cc:	defffb04 	addi	sp,sp,-20
  8058d0:	df000415 	stw	fp,16(sp)
  8058d4:	df000404 	addi	fp,sp,16
  8058d8:	e13ffc15 	stw	r4,-16(fp)
  8058dc:	e17ffd15 	stw	r5,-12(fp)
  8058e0:	e1bffe15 	stw	r6,-8(fp)
  8058e4:	e1ffff15 	stw	r7,-4(fp)
	p->RD_ADDRreg	= src_addr;
  8058e8:	e0bffc17 	ldw	r2,-16(fp)
  8058ec:	e0fffd17 	ldw	r3,-12(fp)
  8058f0:	10c00115 	stw	r3,4(r2)
	p->WR_ADDRreg	= dst_addr;
  8058f4:	e0bffc17 	ldw	r2,-16(fp)
  8058f8:	e0fffe17 	ldw	r3,-8(fp)
  8058fc:	10c00215 	stw	r3,8(r2)
	p->LENGTHreg	= length;
  805900:	e0bffc17 	ldw	r2,-16(fp)
  805904:	e0ffff17 	ldw	r3,-4(fp)
  805908:	10c00315 	stw	r3,12(r2)

	p->CTRLreg |= 	_b_DMA_GO;	//destination is fixed address;
  80590c:	e0bffc17 	ldw	r2,-16(fp)
  805910:	10800617 	ldw	r2,24(r2)
  805914:	10c00214 	ori	r3,r2,8
  805918:	e0bffc17 	ldw	r2,-16(fp)
  80591c:	10c00615 	stw	r3,24(r2)
}
  805920:	0001883a 	nop
  805924:	e037883a 	mov	sp,fp
  805928:	df000017 	ldw	fp,0(sp)
  80592c:	dec00104 	addi	sp,sp,4
  805930:	f800283a 	ret

00805934 <getDMAsts>:

int getDMAsts(DMAMOD *p){
  805934:	defffe04 	addi	sp,sp,-8
  805938:	df000115 	stw	fp,4(sp)
  80593c:	df000104 	addi	fp,sp,4
  805940:	e13fff15 	stw	r4,-4(fp)
	return p->STATUSreg &_b_DMA_BUSY;
  805944:	e0bfff17 	ldw	r2,-4(fp)
  805948:	10800017 	ldw	r2,0(r2)
  80594c:	1080008c 	andi	r2,r2,2
}
  805950:	e037883a 	mov	sp,fp
  805954:	df000017 	ldw	fp,0(sp)
  805958:	dec00104 	addi	sp,sp,4
  80595c:	f800283a 	ret

00805960 <initFT245mod>:
FT245_DATA	Ft245Data;

CmdRespBuf CmdBuf;
CmdRespBuf RspBuf;

void initFT245mod(void){
  805960:	deffff04 	addi	sp,sp,-4
  805964:	df000015 	stw	fp,0(sp)
  805968:	d839883a 	mov	fp,sp

//	pFT245->CtrlReg =_bCrlBit +_bFT245ResetBit;
	pFT245->CtrlReg =_bCrlBit;
  80596c:	d0a00d17 	ldw	r2,-32716(gp)
  805970:	00c00044 	movi	r3,1
  805974:	10c00015 	stw	r3,0(r2)
	pFT245->IrqReg = 0x0;	//~
  805978:	d0a00d17 	ldw	r2,-32716(gp)
  80597c:	10000115 	stw	zero,4(r2)

	pFT245->CtrlReg =	_bCrlBit;
  805980:	d0a00d17 	ldw	r2,-32716(gp)
  805984:	00c00044 	movi	r3,1
  805988:	10c00015 	stw	r3,0(r2)
	pFT245->CtrlReg =	0x00;
  80598c:	d0a00d17 	ldw	r2,-32716(gp)
  805990:	10000015 	stw	zero,0(r2)

}
  805994:	0001883a 	nop
  805998:	e037883a 	mov	sp,fp
  80599c:	df000017 	ldw	fp,0(sp)
  8059a0:	dec00104 	addi	sp,sp,4
  8059a4:	f800283a 	ret

008059a8 <FT245_IRQ_SERVICE>:

//
static void FT245_IRQ_SERVICE(void *sts,alt_u32 IntID)
{
  8059a8:	defffb04 	addi	sp,sp,-20
  8059ac:	dfc00415 	stw	ra,16(sp)
  8059b0:	df000315 	stw	fp,12(sp)
  8059b4:	df000304 	addi	fp,sp,12
  8059b8:	e13ffe15 	stw	r4,-8(fp)
  8059bc:	e17fff15 	stw	r5,-4(fp)
	char	recv_char;

	//Recieve Interrupt?
	if ((pFT245->IrqReg & _bRxIrqStsBit)!=0){
  8059c0:	d0a00d17 	ldw	r2,-32716(gp)
  8059c4:	10800117 	ldw	r2,4(r2)
  8059c8:	1080010c 	andi	r2,r2,4
  8059cc:	10000626 	beq	r2,zero,8059e8 <FT245_IRQ_SERVICE+0x40>
		recv_char=pFT245->RxReg;
  8059d0:	d0a00d17 	ldw	r2,-32716(gp)
  8059d4:	10800317 	ldw	r2,12(r2)
  8059d8:	e0bffd05 	stb	r2,-12(fp)
		CmndSeq	(recv_char);
  8059dc:	e0bffd07 	ldb	r2,-12(fp)
  8059e0:	1009883a 	mov	r4,r2
  8059e4:	08071f00 	call	8071f0 <CmndSeq>
	}
}
  8059e8:	0001883a 	nop
  8059ec:	e037883a 	mov	sp,fp
  8059f0:	dfc00117 	ldw	ra,4(sp)
  8059f4:	df000017 	ldw	fp,0(sp)
  8059f8:	dec00204 	addi	sp,sp,8
  8059fc:	f800283a 	ret

00805a00 <FT245IRQregist>:

//o^
void FT245IRQregist(void){
  805a00:	defffe04 	addi	sp,sp,-8
  805a04:	dfc00115 	stw	ra,4(sp)
  805a08:	df000015 	stw	fp,0(sp)
  805a0c:	d839883a 	mov	fp,sp

    alt_irq_register(FT245_IRQ,(long * )&Ft245Data, FT245_IRQ_SERVICE);
  805a10:	01802034 	movhi	r6,128
  805a14:	31966a04 	addi	r6,r6,22952
  805a18:	014020f4 	movhi	r5,131
  805a1c:	296dc204 	addi	r5,r5,-18680
  805a20:	01000184 	movi	r4,6
  805a24:	08007480 	call	800748 <alt_irq_register>

}
  805a28:	0001883a 	nop
  805a2c:	e037883a 	mov	sp,fp
  805a30:	dfc00117 	ldw	ra,4(sp)
  805a34:	df000017 	ldw	fp,0(sp)
  805a38:	dec00204 	addi	sp,sp,8
  805a3c:	f800283a 	ret

00805a40 <FT245_EnableRxIrq>:
///////////////////////////////////
//M/~
void FT245_EnableRxIrq(void){
  805a40:	defffe04 	addi	sp,sp,-8
  805a44:	df000115 	stw	fp,4(sp)
  805a48:	df000104 	addi	fp,sp,4
	int dummy;

	while(1){
		dummy=pFT245->RxReg;
  805a4c:	d0a00d17 	ldw	r2,-32716(gp)
  805a50:	10800317 	ldw	r2,12(r2)
  805a54:	e0bfff15 	stw	r2,-4(fp)
		pFT245->RxReg=dummy;
  805a58:	d0a00d17 	ldw	r2,-32716(gp)
  805a5c:	e0ffff17 	ldw	r3,-4(fp)
  805a60:	10c00315 	stw	r3,12(r2)
		if ((pFT245->IrqReg & _bRxIrqStsBit)==0)						break;
  805a64:	d0a00d17 	ldw	r2,-32716(gp)
  805a68:	10800117 	ldw	r2,4(r2)
  805a6c:	1080010c 	andi	r2,r2,4
  805a70:	10000126 	beq	r2,zero,805a78 <FT245_EnableRxIrq+0x38>
	}
  805a74:	003ff506 	br	805a4c <__alt_data_end+0xfff05a4c>
	int dummy;

	while(1){
		dummy=pFT245->RxReg;
		pFT245->RxReg=dummy;
		if ((pFT245->IrqReg & _bRxIrqStsBit)==0)						break;
  805a78:	0001883a 	nop
	}
	Ft245Data.RcvCnt=0;
  805a7c:	008020f4 	movhi	r2,131
  805a80:	10adc204 	addi	r2,r2,-18680
  805a84:	10000415 	stw	zero,16(r2)
	Ft245Data.OverFlow=0;
  805a88:	008020f4 	movhi	r2,131
  805a8c:	10adc204 	addi	r2,r2,-18680
  805a90:	10000515 	stw	zero,20(r2)
	pFT245->IrqReg |= _bRxIrqEnBit;
  805a94:	d0a00d17 	ldw	r2,-32716(gp)
  805a98:	d0e00d17 	ldw	r3,-32716(gp)
  805a9c:	18c00117 	ldw	r3,4(r3)
  805aa0:	18c00054 	ori	r3,r3,1
  805aa4:	10c00115 	stw	r3,4(r2)
}
  805aa8:	0001883a 	nop
  805aac:	e037883a 	mov	sp,fp
  805ab0:	df000017 	ldw	fp,0(sp)
  805ab4:	dec00104 	addi	sp,sp,4
  805ab8:	f800283a 	ret

00805abc <FT245_DisableRxIrq>:

void FT245_DisableRxIrq(void){
  805abc:	deffff04 	addi	sp,sp,-4
  805ac0:	df000015 	stw	fp,0(sp)
  805ac4:	d839883a 	mov	fp,sp
	pFT245->IrqReg &= ~_bRxIrqEnBit;
  805ac8:	d0a00d17 	ldw	r2,-32716(gp)
  805acc:	d0e00d17 	ldw	r3,-32716(gp)
  805ad0:	19000117 	ldw	r4,4(r3)
  805ad4:	00ffff84 	movi	r3,-2
  805ad8:	20c6703a 	and	r3,r4,r3
  805adc:	10c00115 	stw	r3,4(r2)
}
  805ae0:	0001883a 	nop
  805ae4:	e037883a 	mov	sp,fp
  805ae8:	df000017 	ldw	fp,0(sp)
  805aec:	dec00104 	addi	sp,sp,4
  805af0:	f800283a 	ret

00805af4 <FT245_SendChar>:

int FT245_SendChar(char send_char){
  805af4:	defffe04 	addi	sp,sp,-8
  805af8:	df000115 	stw	fp,4(sp)
  805afc:	df000104 	addi	fp,sp,4
  805b00:	2005883a 	mov	r2,r4
  805b04:	e0bfff05 	stb	r2,-4(fp)
	if (pFT245->CtrlReg & _bTxBusyBit){
  805b08:	d0a00d17 	ldw	r2,-32716(gp)
  805b0c:	10800017 	ldw	r2,0(r2)
  805b10:	1080020c 	andi	r2,r2,8
  805b14:	10000226 	beq	r2,zero,805b20 <FT245_SendChar+0x2c>
		return -1;	//M
  805b18:	00bfffc4 	movi	r2,-1
  805b1c:	00000a06 	br	805b48 <FT245_SendChar+0x54>
	}
	if((pFT245->CtrlReg&_bRxRdyBit)!=0){
  805b20:	d0a00d17 	ldw	r2,-32716(gp)
  805b24:	10800017 	ldw	r2,0(r2)
  805b28:	1080008c 	andi	r2,r2,2
  805b2c:	10000226 	beq	r2,zero,805b38 <FT245_SendChar+0x44>
		return -1;//Mf[^L
  805b30:	00bfffc4 	movi	r2,-1
  805b34:	00000406 	br	805b48 <FT245_SendChar+0x54>
	}
	pFT245->TxReg=send_char;
  805b38:	d0a00d17 	ldw	r2,-32716(gp)
  805b3c:	e0ffff07 	ldb	r3,-4(fp)
  805b40:	10c00215 	stw	r3,8(r2)
	return 0;
  805b44:	0005883a 	mov	r2,zero
}
  805b48:	e037883a 	mov	sp,fp
  805b4c:	df000017 	ldw	fp,0(sp)
  805b50:	dec00104 	addi	sp,sp,4
  805b54:	f800283a 	ret

00805b58 <FT245_SendBlock>:

int FT245_SendBlock(char *src,int count){
  805b58:	defff904 	addi	sp,sp,-28
  805b5c:	dfc00615 	stw	ra,24(sp)
  805b60:	df000515 	stw	fp,20(sp)
  805b64:	df000504 	addi	fp,sp,20
  805b68:	e13ffe15 	stw	r4,-8(fp)
  805b6c:	e17fff15 	stw	r5,-4(fp)

	char senddata;
	int i;
	int flag;
	int remain;
	for(i=0;i<count;i++,src++){
  805b70:	e03ffb15 	stw	zero,-20(fp)
  805b74:	00001b06 	br	805be4 <FT245_SendBlock+0x8c>

		while (pFT245->CtrlReg & _bTxBusyBit){
			flag=pFT245->CtrlReg;	//M
  805b78:	d0a00d17 	ldw	r2,-32716(gp)
  805b7c:	10800017 	ldw	r2,0(r2)
  805b80:	e0bffc15 	stw	r2,-16(fp)
	int i;
	int flag;
	int remain;
	for(i=0;i<count;i++,src++){

		while (pFT245->CtrlReg & _bTxBusyBit){
  805b84:	d0a00d17 	ldw	r2,-32716(gp)
  805b88:	10800017 	ldw	r2,0(r2)
  805b8c:	1080020c 	andi	r2,r2,8
  805b90:	103ff91e 	bne	r2,zero,805b78 <__alt_data_end+0xfff05b78>
			flag=pFT245->CtrlReg;	//M
		}
		while((pFT245->CtrlReg&_bRxRdyBit)!=0){
  805b94:	00000306 	br	805ba4 <FT245_SendBlock+0x4c>
			flag=pFT245->CtrlReg;	//Mf[^L
  805b98:	d0a00d17 	ldw	r2,-32716(gp)
  805b9c:	10800017 	ldw	r2,0(r2)
  805ba0:	e0bffc15 	stw	r2,-16(fp)
	for(i=0;i<count;i++,src++){

		while (pFT245->CtrlReg & _bTxBusyBit){
			flag=pFT245->CtrlReg;	//M
		}
		while((pFT245->CtrlReg&_bRxRdyBit)!=0){
  805ba4:	d0a00d17 	ldw	r2,-32716(gp)
  805ba8:	10800017 	ldw	r2,0(r2)
  805bac:	1080008c 	andi	r2,r2,2
  805bb0:	103ff91e 	bne	r2,zero,805b98 <__alt_data_end+0xfff05b98>
			flag=pFT245->CtrlReg;	//Mf[^L
		}

		senddata=*src;
  805bb4:	e0bffe17 	ldw	r2,-8(fp)
  805bb8:	10800003 	ldbu	r2,0(r2)
  805bbc:	e0bffd05 	stb	r2,-12(fp)
		FT245_SendChar(senddata);
  805bc0:	e0bffd07 	ldb	r2,-12(fp)
  805bc4:	1009883a 	mov	r4,r2
  805bc8:	0805af40 	call	805af4 <FT245_SendChar>

	char senddata;
	int i;
	int flag;
	int remain;
	for(i=0;i<count;i++,src++){
  805bcc:	e0bffb17 	ldw	r2,-20(fp)
  805bd0:	10800044 	addi	r2,r2,1
  805bd4:	e0bffb15 	stw	r2,-20(fp)
  805bd8:	e0bffe17 	ldw	r2,-8(fp)
  805bdc:	10800044 	addi	r2,r2,1
  805be0:	e0bffe15 	stw	r2,-8(fp)
  805be4:	e0fffb17 	ldw	r3,-20(fp)
  805be8:	e0bfff17 	ldw	r2,-4(fp)
  805bec:	18bfe516 	blt	r3,r2,805b84 <__alt_data_end+0xfff05b84>
		senddata=*src;
		FT245_SendChar(senddata);
	}


	return 0;
  805bf0:	0005883a 	mov	r2,zero
}
  805bf4:	e037883a 	mov	sp,fp
  805bf8:	dfc00117 	ldw	ra,4(sp)
  805bfc:	df000017 	ldw	fp,0(sp)
  805c00:	dec00204 	addi	sp,sp,8
  805c04:	f800283a 	ret

00805c08 <FT245_Send_DMA_FIFO>:

int FT245_Send_DMA_FIFO(int src,int count){
  805c08:	defff704 	addi	sp,sp,-36
  805c0c:	dfc00815 	stw	ra,32(sp)
  805c10:	df000715 	stw	fp,28(sp)
  805c14:	df000704 	addi	fp,sp,28
  805c18:	e13ffe15 	stw	r4,-8(fp)
  805c1c:	e17fff15 	stw	r5,-4(fp)

	char senddata;
	int i;
	int flag;
	int remain;
	int length=8192;	//0x2000 byte = 0x800word;
  805c20:	00880004 	movi	r2,8192
  805c24:	e0bffb15 	stw	r2,-20(fp)
	int *sp,*dp;

#define DMA 1

#if DMA
	dst_addr = (int)&pFT245->Fifo;	//write address is fixed
  805c28:	d0a00d17 	ldw	r2,-32716(gp)
  805c2c:	10800404 	addi	r2,r2,16
  805c30:	e0bffd15 	stw	r2,-12(fp)
//	dst_addr = 0x6200000;	//write address is fixed
	src_addr = src;			//read address is incremented in while loop
  805c34:	e0bffe17 	ldw	r2,-8(fp)
  805c38:	e0bffc15 	stw	r2,-16(fp)
	remain=count;
  805c3c:	e0bfff17 	ldw	r2,-4(fp)
  805c40:	e0bffa15 	stw	r2,-24(fp)
	init_DMAMOD(pDMA);
  805c44:	d0a00c17 	ldw	r2,-32720(gp)
  805c48:	1009883a 	mov	r4,r2
  805c4c:	08058880 	call	805888 <init_DMAMOD>
	while(remain){
  805c50:	00002906 	br	805cf8 <FT245_Send_DMA_FIFO+0xf0>
		flag=pFT245->CtrlReg;
  805c54:	d0a00d17 	ldw	r2,-32716(gp)
  805c58:	10800017 	ldw	r2,0(r2)
  805c5c:	e0bff915 	stw	r2,-28(fp)

		while (pFT245->CtrlReg & _bFIFO_FULL){
  805c60:	00000306 	br	805c70 <FT245_Send_DMA_FIFO+0x68>
			flag=pFT245->CtrlReg;	//FIFO FULL
  805c64:	d0a00d17 	ldw	r2,-32716(gp)
  805c68:	10800017 	ldw	r2,0(r2)
  805c6c:	e0bff915 	stw	r2,-28(fp)
	remain=count;
	init_DMAMOD(pDMA);
	while(remain){
		flag=pFT245->CtrlReg;

		while (pFT245->CtrlReg & _bFIFO_FULL){
  805c70:	d0a00d17 	ldw	r2,-32716(gp)
  805c74:	10800017 	ldw	r2,0(r2)
  805c78:	1080080c 	andi	r2,r2,32
  805c7c:	103ff91e 	bne	r2,zero,805c64 <__alt_data_end+0xfff05c64>
			flag=pFT245->CtrlReg;	//FIFO FULL
		}

		if (remain<length){
  805c80:	e0fffa17 	ldw	r3,-24(fp)
  805c84:	e0bffb17 	ldw	r2,-20(fp)
  805c88:	1880020e 	bge	r3,r2,805c94 <FT245_Send_DMA_FIFO+0x8c>
			length=remain;
  805c8c:	e0bffa17 	ldw	r2,-24(fp)
  805c90:	e0bffb15 	stw	r2,-20(fp)
		}
		startDMA(pDMA,src_addr,dst_addr,length);
  805c94:	d0a00c17 	ldw	r2,-32720(gp)
  805c98:	e1fffb17 	ldw	r7,-20(fp)
  805c9c:	e1bffd17 	ldw	r6,-12(fp)
  805ca0:	e17ffc17 	ldw	r5,-16(fp)
  805ca4:	1009883a 	mov	r4,r2
  805ca8:	08058cc0 	call	8058cc <startDMA>
		flag = getDMAsts(pDMA);
  805cac:	d0a00c17 	ldw	r2,-32720(gp)
  805cb0:	1009883a 	mov	r4,r2
  805cb4:	08059340 	call	805934 <getDMAsts>
  805cb8:	e0bff915 	stw	r2,-28(fp)

		while(flag!=0){
  805cbc:	00000406 	br	805cd0 <FT245_Send_DMA_FIFO+0xc8>
			flag = getDMAsts(pDMA);
  805cc0:	d0a00c17 	ldw	r2,-32720(gp)
  805cc4:	1009883a 	mov	r4,r2
  805cc8:	08059340 	call	805934 <getDMAsts>
  805ccc:	e0bff915 	stw	r2,-28(fp)
			length=remain;
		}
		startDMA(pDMA,src_addr,dst_addr,length);
		flag = getDMAsts(pDMA);

		while(flag!=0){
  805cd0:	e0bff917 	ldw	r2,-28(fp)
  805cd4:	103ffa1e 	bne	r2,zero,805cc0 <__alt_data_end+0xfff05cc0>
			flag = getDMAsts(pDMA);
		}
		remain-=length;
  805cd8:	e0fffa17 	ldw	r3,-24(fp)
  805cdc:	e0bffb17 	ldw	r2,-20(fp)
  805ce0:	1885c83a 	sub	r2,r3,r2
  805ce4:	e0bffa15 	stw	r2,-24(fp)
		src_addr+=length;
  805ce8:	e0fffc17 	ldw	r3,-16(fp)
  805cec:	e0bffb17 	ldw	r2,-20(fp)
  805cf0:	1885883a 	add	r2,r3,r2
  805cf4:	e0bffc15 	stw	r2,-16(fp)
	dst_addr = (int)&pFT245->Fifo;	//write address is fixed
//	dst_addr = 0x6200000;	//write address is fixed
	src_addr = src;			//read address is incremented in while loop
	remain=count;
	init_DMAMOD(pDMA);
	while(remain){
  805cf8:	e0bffa17 	ldw	r2,-24(fp)
  805cfc:	103fd51e 	bne	r2,zero,805c54 <__alt_data_end+0xfff05c54>
		*dp=*sp;
	}


#endif
	return 0;
  805d00:	0005883a 	mov	r2,zero
}
  805d04:	e037883a 	mov	sp,fp
  805d08:	dfc00117 	ldw	ra,4(sp)
  805d0c:	df000017 	ldw	fp,0(sp)
  805d10:	dec00204 	addi	sp,sp,8
  805d14:	f800283a 	ret

00805d18 <encodeRGB565>:
#include "grp_lcd.h"
#include "./FONT/fonts.h"

extern FontList	FntList[NumOfFont];

uint16_t encodeRGB565(uint8_t RED,uint8_t GREEN,uint8_t BLUE){
  805d18:	defffb04 	addi	sp,sp,-20
  805d1c:	df000415 	stw	fp,16(sp)
  805d20:	df000404 	addi	fp,sp,16
  805d24:	2807883a 	mov	r3,r5
  805d28:	3005883a 	mov	r2,r6
  805d2c:	e13ffd05 	stb	r4,-12(fp)
  805d30:	e0fffe05 	stb	r3,-8(fp)
  805d34:	e0bfff05 	stb	r2,-4(fp)
	uint16_t TEMP=0;
  805d38:	e03ffc0d 	sth	zero,-16(fp)

	TEMP += (RED&0xf8)<<8;
  805d3c:	e0bffd03 	ldbu	r2,-12(fp)
  805d40:	10803e0c 	andi	r2,r2,248
  805d44:	1004923a 	slli	r2,r2,8
  805d48:	1007883a 	mov	r3,r2
  805d4c:	e0bffc0b 	ldhu	r2,-16(fp)
  805d50:	1885883a 	add	r2,r3,r2
  805d54:	e0bffc0d 	sth	r2,-16(fp)
	TEMP += (GREEN&0xfC)<<3;
  805d58:	e0bffe03 	ldbu	r2,-8(fp)
  805d5c:	10803f0c 	andi	r2,r2,252
  805d60:	100490fa 	slli	r2,r2,3
  805d64:	1007883a 	mov	r3,r2
  805d68:	e0bffc0b 	ldhu	r2,-16(fp)
  805d6c:	1885883a 	add	r2,r3,r2
  805d70:	e0bffc0d 	sth	r2,-16(fp)
	TEMP += (BLUE&0xf8)>>3;
  805d74:	e0bfff03 	ldbu	r2,-4(fp)
  805d78:	1004d0fa 	srli	r2,r2,3
  805d7c:	10c03fcc 	andi	r3,r2,255
  805d80:	e0bffc0b 	ldhu	r2,-16(fp)
  805d84:	1885883a 	add	r2,r3,r2
  805d88:	e0bffc0d 	sth	r2,-16(fp)
	return TEMP;
  805d8c:	e0bffc0b 	ldhu	r2,-16(fp)
}
  805d90:	e037883a 	mov	sp,fp
  805d94:	df000017 	ldw	fp,0(sp)
  805d98:	dec00104 	addi	sp,sp,4
  805d9c:	f800283a 	ret

00805da0 <glcd_Init>:

int glcd_Init(uint16_t color){
  805da0:	defffd04 	addi	sp,sp,-12
  805da4:	dfc00215 	stw	ra,8(sp)
  805da8:	df000115 	stw	fp,4(sp)
  805dac:	df000104 	addi	fp,sp,4
  805db0:	2005883a 	mov	r2,r4
  805db4:	e0bfff0d 	sth	r2,-4(fp)

	LoadFont();
  805db8:	08041ac0 	call	8041ac <LoadFont>
#ifdef SSD1331
	init_SSD1331();
	return 0;
#endif
#ifdef ILI9341
	init_9341(color);
  805dbc:	e0bfff0b 	ldhu	r2,-4(fp)
  805dc0:	10bfffcc 	andi	r2,r2,65535
  805dc4:	10a0001c 	xori	r2,r2,32768
  805dc8:	10a00004 	addi	r2,r2,-32768
  805dcc:	1009883a 	mov	r4,r2
  805dd0:	08045400 	call	804540 <init_9341>
	return 0;
  805dd4:	0005883a 	mov	r2,zero
#ifdef ILI9481
	init_ILI9481(color);
	return 0;
#endif
	return -2;
}
  805dd8:	e037883a 	mov	sp,fp
  805ddc:	dfc00117 	ldw	ra,4(sp)
  805de0:	df000017 	ldw	fp,0(sp)
  805de4:	dec00204 	addi	sp,sp,8
  805de8:	f800283a 	ret

00805dec <glcd_PointSet>:



int glcd_PointSet(uint16_t x,uint16_t y,uint16_t color){
  805dec:	defffb04 	addi	sp,sp,-20
  805df0:	dfc00415 	stw	ra,16(sp)
  805df4:	df000315 	stw	fp,12(sp)
  805df8:	df000304 	addi	fp,sp,12
  805dfc:	2807883a 	mov	r3,r5
  805e00:	3005883a 	mov	r2,r6
  805e04:	e13ffd0d 	sth	r4,-12(fp)
  805e08:	e0fffe0d 	sth	r3,-8(fp)
  805e0c:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	pset16_SSD1331((uint8_t) x, (uint8_t) y, color);
	return 0;
#endif
#ifdef ILI9341
	Pset_9341(x,y,color);
  805e10:	e0bffd0b 	ldhu	r2,-12(fp)
  805e14:	e0fffe0b 	ldhu	r3,-8(fp)
  805e18:	e13fff0b 	ldhu	r4,-4(fp)
  805e1c:	200d883a 	mov	r6,r4
  805e20:	180b883a 	mov	r5,r3
  805e24:	1009883a 	mov	r4,r2
  805e28:	0804e1c0 	call	804e1c <Pset_9341>
	return 0;
  805e2c:	0005883a 	mov	r2,zero
	PSET_ILI9481(x,y,color);
	return 0;
#endif
	return -2;

}
  805e30:	e037883a 	mov	sp,fp
  805e34:	dfc00117 	ldw	ra,4(sp)
  805e38:	df000017 	ldw	fp,0(sp)
  805e3c:	dec00204 	addi	sp,sp,8
  805e40:	f800283a 	ret

00805e44 <glcd_drawLine>:

int glcd_drawLine(uint16_t xs,uint16_t ys, uint16_t xe,uint16_t ye,uint16_t color){
  805e44:	defff804 	addi	sp,sp,-32
  805e48:	dfc00715 	stw	ra,28(sp)
  805e4c:	df000615 	stw	fp,24(sp)
  805e50:	df000604 	addi	fp,sp,24
  805e54:	2011883a 	mov	r8,r4
  805e58:	3009883a 	mov	r4,r6
  805e5c:	3807883a 	mov	r3,r7
  805e60:	e0800217 	ldw	r2,8(fp)
  805e64:	e23ffb0d 	sth	r8,-20(fp)
  805e68:	e17ffc0d 	sth	r5,-16(fp)
  805e6c:	e13ffd0d 	sth	r4,-12(fp)
  805e70:	e0fffe0d 	sth	r3,-8(fp)
  805e74:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	line16_SSD1331(	(uint8_t) xs,(uint8_t) ys,(uint8_t)xe,	(uint8_t)ye,color);
	return 0;
#endif
#ifdef ILI9341
	drawLine_9341(xs,ys,xe,ye,color);
  805e78:	e0fffb0b 	ldhu	r3,-20(fp)
  805e7c:	e13ffc0b 	ldhu	r4,-16(fp)
  805e80:	e17ffd0b 	ldhu	r5,-12(fp)
  805e84:	e1bffe0b 	ldhu	r6,-8(fp)
  805e88:	e0bfff0b 	ldhu	r2,-4(fp)
  805e8c:	d8800015 	stw	r2,0(sp)
  805e90:	300f883a 	mov	r7,r6
  805e94:	280d883a 	mov	r6,r5
  805e98:	200b883a 	mov	r5,r4
  805e9c:	1809883a 	mov	r4,r3
  805ea0:	080504c0 	call	80504c <drawLine_9341>
	return 0;
  805ea4:	0005883a 	mov	r2,zero
	LINE_ILI9481(xs,ys,xe,ye,color);
	return 0;
#endif

	return -2;
}
  805ea8:	e037883a 	mov	sp,fp
  805eac:	dfc00117 	ldw	ra,4(sp)
  805eb0:	df000017 	ldw	fp,0(sp)
  805eb4:	dec00204 	addi	sp,sp,8
  805eb8:	f800283a 	ret

00805ebc <glcd_drawHline>:


int glcd_drawHline(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
  805ebc:	defffa04 	addi	sp,sp,-24
  805ec0:	dfc00515 	stw	ra,20(sp)
  805ec4:	df000415 	stw	fp,16(sp)
  805ec8:	df000404 	addi	fp,sp,16
  805ecc:	2011883a 	mov	r8,r4
  805ed0:	2809883a 	mov	r4,r5
  805ed4:	3007883a 	mov	r3,r6
  805ed8:	3805883a 	mov	r2,r7
  805edc:	e23ffc0d 	sth	r8,-16(fp)
  805ee0:	e13ffd0d 	sth	r4,-12(fp)
  805ee4:	e0fffe0d 	sth	r3,-8(fp)
  805ee8:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	line16_SSD1331(	(uint8_t) x,(uint8_t) y,(uint8_t) length,	(uint8_t) y,color);
	return 0;
#endif
#ifdef ILI9341
	drawHline_9341(x,y,length,color);
  805eec:	e0bffc0b 	ldhu	r2,-16(fp)
  805ef0:	e0fffd0b 	ldhu	r3,-12(fp)
  805ef4:	e13ffe0b 	ldhu	r4,-8(fp)
  805ef8:	e17fff0b 	ldhu	r5,-4(fp)
  805efc:	280f883a 	mov	r7,r5
  805f00:	200d883a 	mov	r6,r4
  805f04:	180b883a 	mov	r5,r3
  805f08:	1009883a 	mov	r4,r2
  805f0c:	0804fb80 	call	804fb8 <drawHline_9341>
	return 0;
  805f10:	0005883a 	mov	r2,zero
#ifdef ILI9481
	HLINE_ILI9481(x,y,length,color);
	return 0;
#endif
	return -2;
}
  805f14:	e037883a 	mov	sp,fp
  805f18:	dfc00117 	ldw	ra,4(sp)
  805f1c:	df000017 	ldw	fp,0(sp)
  805f20:	dec00204 	addi	sp,sp,8
  805f24:	f800283a 	ret

00805f28 <glcd_drawVline>:

int glcd_drawVline(uint16_t x,uint16_t y,uint16_t length,uint16_t color){
  805f28:	defffa04 	addi	sp,sp,-24
  805f2c:	dfc00515 	stw	ra,20(sp)
  805f30:	df000415 	stw	fp,16(sp)
  805f34:	df000404 	addi	fp,sp,16
  805f38:	2011883a 	mov	r8,r4
  805f3c:	2809883a 	mov	r4,r5
  805f40:	3007883a 	mov	r3,r6
  805f44:	3805883a 	mov	r2,r7
  805f48:	e23ffc0d 	sth	r8,-16(fp)
  805f4c:	e13ffd0d 	sth	r4,-12(fp)
  805f50:	e0fffe0d 	sth	r3,-8(fp)
  805f54:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	line16_SSD1331(	(uint8_t) x,(uint8_t) y,(uint8_t) x,(uint8_t) length,color);
	return 0;
#endif
#ifdef ILI9341
	drawVline_9341(x,y,length,color);
  805f58:	e0bffc0b 	ldhu	r2,-16(fp)
  805f5c:	e0fffd0b 	ldhu	r3,-12(fp)
  805f60:	e13ffe0b 	ldhu	r4,-8(fp)
  805f64:	e17fff0b 	ldhu	r5,-4(fp)
  805f68:	280f883a 	mov	r7,r5
  805f6c:	200d883a 	mov	r6,r4
  805f70:	180b883a 	mov	r5,r3
  805f74:	1009883a 	mov	r4,r2
  805f78:	0804f240 	call	804f24 <drawVline_9341>
#endif
#ifdef ILI9481
	VLINE_ILI9481(x,y,length,color);
	return 0;
#endif
	return -2;
  805f7c:	00bfff84 	movi	r2,-2
}
  805f80:	e037883a 	mov	sp,fp
  805f84:	dfc00117 	ldw	ra,4(sp)
  805f88:	df000017 	ldw	fp,0(sp)
  805f8c:	dec00204 	addi	sp,sp,8
  805f90:	f800283a 	ret

00805f94 <glcd_drawRectangle>:

int glcd_drawRectangle(uint16_t xs,uint16_t ys, uint16_t xe,uint16_t ye,uint16_t color){
  805f94:	defff804 	addi	sp,sp,-32
  805f98:	dfc00715 	stw	ra,28(sp)
  805f9c:	df000615 	stw	fp,24(sp)
  805fa0:	df000604 	addi	fp,sp,24
  805fa4:	2011883a 	mov	r8,r4
  805fa8:	3009883a 	mov	r4,r6
  805fac:	3807883a 	mov	r3,r7
  805fb0:	e0800217 	ldw	r2,8(fp)
  805fb4:	e23ffb0d 	sth	r8,-20(fp)
  805fb8:	e17ffc0d 	sth	r5,-16(fp)
  805fbc:	e13ffd0d 	sth	r4,-12(fp)
  805fc0:	e0fffe0d 	sth	r3,-8(fp)
  805fc4:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	Rectangle16_SSD1331((uint8_t)xs,(uint8_t)ys,(uint8_t)xe,(uint8_t)ye, color	);
	return 0;
#endif
#ifdef ILI9341
	 Box_9341(xs,ys,xe,ye,color);
  805fc8:	e0fffb0b 	ldhu	r3,-20(fp)
  805fcc:	e13ffc0b 	ldhu	r4,-16(fp)
  805fd0:	e17ffd0b 	ldhu	r5,-12(fp)
  805fd4:	e1bffe0b 	ldhu	r6,-8(fp)
  805fd8:	e0bfff0b 	ldhu	r2,-4(fp)
  805fdc:	d8800015 	stw	r2,0(sp)
  805fe0:	300f883a 	mov	r7,r6
  805fe4:	280d883a 	mov	r6,r5
  805fe8:	200b883a 	mov	r5,r4
  805fec:	1809883a 	mov	r4,r3
  805ff0:	080578c0 	call	80578c <Box_9341>
	return 0;
  805ff4:	0005883a 	mov	r2,zero
#ifdef ILI9481
	Rectangle_ILI9481(xs,xe,ys,ye,color);
	return 0;
#endif
	return -2;
}
  805ff8:	e037883a 	mov	sp,fp
  805ffc:	dfc00117 	ldw	ra,4(sp)
  806000:	df000017 	ldw	fp,0(sp)
  806004:	dec00204 	addi	sp,sp,8
  806008:	f800283a 	ret

0080600c <glcd_drawRectangleFill>:

int glcd_drawRectangleFill(uint16_t xs,uint16_t ys, uint16_t xe,uint16_t ye,uint16_t line_color,uint16_t fill_color){
  80600c:	defff704 	addi	sp,sp,-36
  806010:	dfc00815 	stw	ra,32(sp)
  806014:	df000715 	stw	fp,28(sp)
  806018:	df000704 	addi	fp,sp,28
  80601c:	2013883a 	mov	r9,r4
  806020:	2811883a 	mov	r8,r5
  806024:	300b883a 	mov	r5,r6
  806028:	3809883a 	mov	r4,r7
  80602c:	e0c00217 	ldw	r3,8(fp)
  806030:	e0800317 	ldw	r2,12(fp)
  806034:	e27ffa0d 	sth	r9,-24(fp)
  806038:	e23ffb0d 	sth	r8,-20(fp)
  80603c:	e17ffc0d 	sth	r5,-16(fp)
  806040:	e13ffd0d 	sth	r4,-12(fp)
  806044:	e0fffe0d 	sth	r3,-8(fp)
  806048:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	RectangleFill16_SSD1331((uint8_t)xs,(uint8_t)ys,(uint8_t)xe,(uint8_t)ye, line_color,fill_color	);
	return 0;
#endif
#ifdef ILI9341
	Rectangle_9341(xs,xe,ys,ye,fill_color);
  80604c:	e0fffa0b 	ldhu	r3,-24(fp)
  806050:	e13ffc0b 	ldhu	r4,-16(fp)
  806054:	e17ffb0b 	ldhu	r5,-20(fp)
  806058:	e1bffd0b 	ldhu	r6,-12(fp)
  80605c:	e0bfff0b 	ldhu	r2,-4(fp)
  806060:	d8800015 	stw	r2,0(sp)
  806064:	300f883a 	mov	r7,r6
  806068:	280d883a 	mov	r6,r5
  80606c:	200b883a 	mov	r5,r4
  806070:	1809883a 	mov	r4,r3
  806074:	0804cc40 	call	804cc4 <Rectangle_9341>
	 Box_9341(xs,ys,xe,ye,line_color);
  806078:	e0fffa0b 	ldhu	r3,-24(fp)
  80607c:	e13ffb0b 	ldhu	r4,-20(fp)
  806080:	e17ffc0b 	ldhu	r5,-16(fp)
  806084:	e1bffd0b 	ldhu	r6,-12(fp)
  806088:	e0bffe0b 	ldhu	r2,-8(fp)
  80608c:	d8800015 	stw	r2,0(sp)
  806090:	300f883a 	mov	r7,r6
  806094:	280d883a 	mov	r6,r5
  806098:	200b883a 	mov	r5,r4
  80609c:	1809883a 	mov	r4,r3
  8060a0:	080578c0 	call	80578c <Box_9341>

#endif
	return -2;
  8060a4:	00bfff84 	movi	r2,-2
}
  8060a8:	e037883a 	mov	sp,fp
  8060ac:	dfc00117 	ldw	ra,4(sp)
  8060b0:	df000017 	ldw	fp,0(sp)
  8060b4:	dec00204 	addi	sp,sp,8
  8060b8:	f800283a 	ret

008060bc <glcd_BitBLT>:

int glcd_BitBLT(uint16_t xs,uint16_t ys, uint16_t xe,uint16_t ye,uint16_t *pSRC)
{
  8060bc:	defff904 	addi	sp,sp,-28
  8060c0:	dfc00615 	stw	ra,24(sp)
  8060c4:	df000515 	stw	fp,20(sp)
  8060c8:	df000504 	addi	fp,sp,20
  8060cc:	2011883a 	mov	r8,r4
  8060d0:	2809883a 	mov	r4,r5
  8060d4:	3007883a 	mov	r3,r6
  8060d8:	3805883a 	mov	r2,r7
  8060dc:	e23ffc0d 	sth	r8,-16(fp)
  8060e0:	e13ffd0d 	sth	r4,-12(fp)
  8060e4:	e0fffe0d 	sth	r3,-8(fp)
  8060e8:	e0bfff0d 	sth	r2,-4(fp)
#ifdef SSD1331
	BitBLT16_SSD1331((uint8_t) xs,(uint8_t) ys,	(uint8_t) xe,(uint8_t) ye,pSRC	);
	return 0;
#endif
#ifdef ILI9341
	BitBlt_9341(xs,xe,ys,ye,pSRC);
  8060ec:	e0fffc0b 	ldhu	r3,-16(fp)
  8060f0:	e13ffe0b 	ldhu	r4,-8(fp)
  8060f4:	e17ffd0b 	ldhu	r5,-12(fp)
  8060f8:	e1bfff0b 	ldhu	r6,-4(fp)
  8060fc:	e0800217 	ldw	r2,8(fp)
  806100:	d8800015 	stw	r2,0(sp)
  806104:	300f883a 	mov	r7,r6
  806108:	280d883a 	mov	r6,r5
  80610c:	200b883a 	mov	r5,r4
  806110:	1809883a 	mov	r4,r3
  806114:	08049c80 	call	8049c8 <BitBlt_9341>
	return 0;
  806118:	0005883a 	mov	r2,zero
#endif
#ifdef ILI9481
	BitBlt_ILI9481(xs,xe,ys,ye,pSRC);
#endif
	return -2;
}
  80611c:	e037883a 	mov	sp,fp
  806120:	dfc00117 	ldw	ra,4(sp)
  806124:	df000017 	ldw	fp,0(sp)
  806128:	dec00204 	addi	sp,sp,8
  80612c:	f800283a 	ret

00806130 <put_charPattern>:


int put_charPattern(char CharCode,uint16_t CHAR_COLOR,uint16_t xs,uint16_t ys,int FontSize)
{
  806130:	defff204 	addi	sp,sp,-56
  806134:	dfc00d15 	stw	ra,52(sp)
  806138:	df000c15 	stw	fp,48(sp)
  80613c:	df000c04 	addi	fp,sp,48
  806140:	2011883a 	mov	r8,r4
  806144:	2809883a 	mov	r4,r5
  806148:	3007883a 	mov	r3,r6
  80614c:	3805883a 	mov	r2,r7
  806150:	e23ffc05 	stb	r8,-16(fp)
  806154:	e13ffd0d 	sth	r4,-12(fp)
  806158:	e0fffe0d 	sth	r3,-8(fp)
  80615c:	e0bfff0d 	sth	r2,-4(fp)
	uint8_t *pFNT;
	uint32_t LINE_PATTERN;
	int x,y;
	int FontWidth,FontHeight,FontCap,byte_line;

	if ((CharCode>0x7e)||(CharCode<0x20))
  806160:	e0bffc07 	ldb	r2,-16(fp)
  806164:	10801fe0 	cmpeqi	r2,r2,127
  806168:	1000031e 	bne	r2,zero,806178 <put_charPattern+0x48>
  80616c:	e0bffc07 	ldb	r2,-16(fp)
  806170:	10800808 	cmpgei	r2,r2,32
  806174:	1000021e 	bne	r2,zero,806180 <put_charPattern+0x50>
		return -1;
  806178:	00bfffc4 	movi	r2,-1
  80617c:	00008906 	br	8063a4 <put_charPattern+0x274>

	//FontSTMCugp
	if(FontSize==FNT12){	//font12,w=7,h=12
  806180:	e0800217 	ldw	r2,8(fp)
  806184:	10000d1e 	bne	r2,zero,8061bc <put_charPattern+0x8c>
		FontWidth=Font12.Width;
  806188:	d0a0030b 	ldhu	r2,-32756(gp)
  80618c:	10bfffcc 	andi	r2,r2,65535
  806190:	e0bff815 	stw	r2,-32(fp)
		FontHeight=Font12.Height;
  806194:	d0a0038b 	ldhu	r2,-32754(gp)
  806198:	10bfffcc 	andi	r2,r2,65535
  80619c:	e0bff915 	stw	r2,-28(fp)
		pFNT=(uint8_t *)Font12.table;
  8061a0:	d0a00217 	ldw	r2,-32760(gp)
  8061a4:	e0bff415 	stw	r2,-48(fp)
		FontCap=12;
  8061a8:	00800304 	movi	r2,12
  8061ac:	e0bffa15 	stw	r2,-24(fp)
		byte_line=1;
  8061b0:	00800044 	movi	r2,1
  8061b4:	e0bffb15 	stw	r2,-20(fp)
  8061b8:	00003206 	br	806284 <put_charPattern+0x154>
	}
	else if(FontSize==FNT16){
  8061bc:	e0800217 	ldw	r2,8(fp)
  8061c0:	10800058 	cmpnei	r2,r2,1
  8061c4:	10000d1e 	bne	r2,zero,8061fc <put_charPattern+0xcc>
		FontWidth=Font16.Width;
  8061c8:	d0a0050b 	ldhu	r2,-32748(gp)
  8061cc:	10bfffcc 	andi	r2,r2,65535
  8061d0:	e0bff815 	stw	r2,-32(fp)
		FontHeight=Font16.Height;
  8061d4:	d0a0058b 	ldhu	r2,-32746(gp)
  8061d8:	10bfffcc 	andi	r2,r2,65535
  8061dc:	e0bff915 	stw	r2,-28(fp)
		pFNT=(uint8_t *)Font16.table;
  8061e0:	d0a00417 	ldw	r2,-32752(gp)
  8061e4:	e0bff415 	stw	r2,-48(fp)
		FontCap=32;
  8061e8:	00800804 	movi	r2,32
  8061ec:	e0bffa15 	stw	r2,-24(fp)
		byte_line=2;
  8061f0:	00800084 	movi	r2,2
  8061f4:	e0bffb15 	stw	r2,-20(fp)
  8061f8:	00002206 	br	806284 <put_charPattern+0x154>
	}
	else if(FontSize==FNT20){
  8061fc:	e0800217 	ldw	r2,8(fp)
  806200:	10800098 	cmpnei	r2,r2,2
  806204:	10000d1e 	bne	r2,zero,80623c <put_charPattern+0x10c>
		FontWidth=Font20.Width;
  806208:	d0a0070b 	ldhu	r2,-32740(gp)
  80620c:	10bfffcc 	andi	r2,r2,65535
  806210:	e0bff815 	stw	r2,-32(fp)
		FontHeight=Font20.Height;
  806214:	d0a0078b 	ldhu	r2,-32738(gp)
  806218:	10bfffcc 	andi	r2,r2,65535
  80621c:	e0bff915 	stw	r2,-28(fp)
		pFNT=(uint8_t *)Font20.table;
  806220:	d0a00617 	ldw	r2,-32744(gp)
  806224:	e0bff415 	stw	r2,-48(fp)
		FontCap=40;
  806228:	00800a04 	movi	r2,40
  80622c:	e0bffa15 	stw	r2,-24(fp)
		byte_line=2;
  806230:	00800084 	movi	r2,2
  806234:	e0bffb15 	stw	r2,-20(fp)
  806238:	00001206 	br	806284 <put_charPattern+0x154>
	}
	else if(FontSize==FNT24){
  80623c:	e0800217 	ldw	r2,8(fp)
  806240:	108000d8 	cmpnei	r2,r2,3
  806244:	10000d1e 	bne	r2,zero,80627c <put_charPattern+0x14c>
		FontWidth=Font24.Width;
  806248:	d0a0090b 	ldhu	r2,-32732(gp)
  80624c:	10bfffcc 	andi	r2,r2,65535
  806250:	e0bff815 	stw	r2,-32(fp)
		FontHeight=Font24.Height;
  806254:	d0a0098b 	ldhu	r2,-32730(gp)
  806258:	10bfffcc 	andi	r2,r2,65535
  80625c:	e0bff915 	stw	r2,-28(fp)
		pFNT=(uint8_t *)Font24.table;
  806260:	d0a00817 	ldw	r2,-32736(gp)
  806264:	e0bff415 	stw	r2,-48(fp)
		FontCap=72;
  806268:	00801204 	movi	r2,72
  80626c:	e0bffa15 	stw	r2,-24(fp)
		byte_line=3;
  806270:	008000c4 	movi	r2,3
  806274:	e0bffb15 	stw	r2,-20(fp)
  806278:	00000206 	br	806284 <put_charPattern+0x154>
	}else{
		return -1;
  80627c:	00bfffc4 	movi	r2,-1
  806280:	00004806 	br	8063a4 <put_charPattern+0x274>
	}

	pFNT += ((CharCode-' ')*FontCap);		//p^['Xy[X '(0x20)
  806284:	e0bffc07 	ldb	r2,-16(fp)
  806288:	10bff804 	addi	r2,r2,-32
  80628c:	e17ffa17 	ldw	r5,-24(fp)
  806290:	1009883a 	mov	r4,r2
  806294:	080b2480 	call	80b248 <__mulsi3>
  806298:	1007883a 	mov	r3,r2
  80629c:	e0bff417 	ldw	r2,-48(fp)
  8062a0:	10c5883a 	add	r2,r2,r3
  8062a4:	e0bff415 	stw	r2,-48(fp)
	for(y=ys;y<ys+FontHeight;y++){
  8062a8:	e0bfff0b 	ldhu	r2,-4(fp)
  8062ac:	e0bff715 	stw	r2,-36(fp)
  8062b0:	00003606 	br	80638c <put_charPattern+0x25c>

		LINE_PATTERN = (*pFNT) * 0x1000000 + *(pFNT+1) * 0x10000 + *(pFNT+2) * 0x100 + *(pFNT+3);
  8062b4:	e0bff417 	ldw	r2,-48(fp)
  8062b8:	10800003 	ldbu	r2,0(r2)
  8062bc:	10803fcc 	andi	r2,r2,255
  8062c0:	1006923a 	slli	r3,r2,8
  8062c4:	e0bff417 	ldw	r2,-48(fp)
  8062c8:	10800044 	addi	r2,r2,1
  8062cc:	10800003 	ldbu	r2,0(r2)
  8062d0:	10803fcc 	andi	r2,r2,255
  8062d4:	1885883a 	add	r2,r3,r2
  8062d8:	1006923a 	slli	r3,r2,8
  8062dc:	e0bff417 	ldw	r2,-48(fp)
  8062e0:	10800084 	addi	r2,r2,2
  8062e4:	10800003 	ldbu	r2,0(r2)
  8062e8:	10803fcc 	andi	r2,r2,255
  8062ec:	1885883a 	add	r2,r3,r2
  8062f0:	1006923a 	slli	r3,r2,8
  8062f4:	e0bff417 	ldw	r2,-48(fp)
  8062f8:	108000c4 	addi	r2,r2,3
  8062fc:	10800003 	ldbu	r2,0(r2)
  806300:	10803fcc 	andi	r2,r2,255
  806304:	1885883a 	add	r2,r3,r2
  806308:	e0bff515 	stw	r2,-44(fp)
		for(x=xs;x<FontWidth+xs;x++){
  80630c:	e0bffe0b 	ldhu	r2,-8(fp)
  806310:	e0bff615 	stw	r2,-40(fp)
  806314:	00001106 	br	80635c <put_charPattern+0x22c>
			if(LINE_PATTERN & 0x80000000){
  806318:	e0bff517 	ldw	r2,-44(fp)
  80631c:	1000090e 	bge	r2,zero,806344 <put_charPattern+0x214>
#ifdef SSD1331
				pset16_SSD1331((uint8_t)x, (uint8_t)y,CHAR_COLOR);
#endif
#ifdef ILI9341
				Pset_9341(x,y,CHAR_COLOR);
  806320:	e0bff617 	ldw	r2,-40(fp)
  806324:	10ffffcc 	andi	r3,r2,65535
  806328:	e0bff717 	ldw	r2,-36(fp)
  80632c:	10bfffcc 	andi	r2,r2,65535
  806330:	e13ffd0b 	ldhu	r4,-12(fp)
  806334:	200d883a 	mov	r6,r4
  806338:	100b883a 	mov	r5,r2
  80633c:	1809883a 	mov	r4,r3
  806340:	0804e1c0 	call	804e1c <Pset_9341>
#endif;
#ifdef ILI9481
				PSET_ILI9481(x,y,CHAR_COLOR);
#endif;
			}
			LINE_PATTERN=LINE_PATTERN<<1;
  806344:	e0bff517 	ldw	r2,-44(fp)
  806348:	1085883a 	add	r2,r2,r2
  80634c:	e0bff515 	stw	r2,-44(fp)

	pFNT += ((CharCode-' ')*FontCap);		//p^['Xy[X '(0x20)
	for(y=ys;y<ys+FontHeight;y++){

		LINE_PATTERN = (*pFNT) * 0x1000000 + *(pFNT+1) * 0x10000 + *(pFNT+2) * 0x100 + *(pFNT+3);
		for(x=xs;x<FontWidth+xs;x++){
  806350:	e0bff617 	ldw	r2,-40(fp)
  806354:	10800044 	addi	r2,r2,1
  806358:	e0bff615 	stw	r2,-40(fp)
  80635c:	e0fffe0b 	ldhu	r3,-8(fp)
  806360:	e0bff817 	ldw	r2,-32(fp)
  806364:	1885883a 	add	r2,r3,r2
  806368:	e0fff617 	ldw	r3,-40(fp)
  80636c:	18bfea16 	blt	r3,r2,806318 <__alt_data_end+0xfff06318>
				PSET_ILI9481(x,y,CHAR_COLOR);
#endif;
			}
			LINE_PATTERN=LINE_PATTERN<<1;
		}
		pFNT+=byte_line;
  806370:	e0bffb17 	ldw	r2,-20(fp)
  806374:	e0fff417 	ldw	r3,-48(fp)
  806378:	1885883a 	add	r2,r3,r2
  80637c:	e0bff415 	stw	r2,-48(fp)
	}else{
		return -1;
	}

	pFNT += ((CharCode-' ')*FontCap);		//p^['Xy[X '(0x20)
	for(y=ys;y<ys+FontHeight;y++){
  806380:	e0bff717 	ldw	r2,-36(fp)
  806384:	10800044 	addi	r2,r2,1
  806388:	e0bff715 	stw	r2,-36(fp)
  80638c:	e0ffff0b 	ldhu	r3,-4(fp)
  806390:	e0bff917 	ldw	r2,-28(fp)
  806394:	1885883a 	add	r2,r3,r2
  806398:	e0fff717 	ldw	r3,-36(fp)
  80639c:	18bfc516 	blt	r3,r2,8062b4 <__alt_data_end+0xfff062b4>
		}
		pFNT+=byte_line;
	}


	return 0;
  8063a0:	0005883a 	mov	r2,zero
}
  8063a4:	e037883a 	mov	sp,fp
  8063a8:	dfc00117 	ldw	ra,4(sp)
  8063ac:	df000017 	ldw	fp,0(sp)
  8063b0:	dec00204 	addi	sp,sp,8
  8063b4:	f800283a 	ret

008063b8 <glcd_put_string_fixed>:


int glcd_put_string_fixed(int x,int y,char *string,uint16_t CharColor,int FontSize)
{
  8063b8:	defff404 	addi	sp,sp,-48
  8063bc:	dfc00b15 	stw	ra,44(sp)
  8063c0:	df000a15 	stw	fp,40(sp)
  8063c4:	df000a04 	addi	fp,sp,40
  8063c8:	e13ffc15 	stw	r4,-16(fp)
  8063cc:	e17ffd15 	stw	r5,-12(fp)
  8063d0:	e1bffe15 	stw	r6,-8(fp)
  8063d4:	3805883a 	mov	r2,r7
  8063d8:	e0bfff0d 	sth	r2,-4(fp)
	char *STR;

	int FontWidth,FontHeight;

	//FontSTMCugp
	if(FontSize==FNT12){	//font12,w=7,h=12
  8063dc:	e0800217 	ldw	r2,8(fp)
  8063e0:	1000071e 	bne	r2,zero,806400 <glcd_put_string_fixed+0x48>
		FontWidth=Font12.Width;
  8063e4:	d0a0030b 	ldhu	r2,-32756(gp)
  8063e8:	10bfffcc 	andi	r2,r2,65535
  8063ec:	e0bffa15 	stw	r2,-24(fp)
		FontHeight=Font12.Height;
  8063f0:	d0a0038b 	ldhu	r2,-32754(gp)
  8063f4:	10bfffcc 	andi	r2,r2,65535
  8063f8:	e0bffb15 	stw	r2,-20(fp)
  8063fc:	00002006 	br	806480 <glcd_put_string_fixed+0xc8>
	}
	else if(FontSize==FNT16){
  806400:	e0800217 	ldw	r2,8(fp)
  806404:	10800058 	cmpnei	r2,r2,1
  806408:	1000071e 	bne	r2,zero,806428 <glcd_put_string_fixed+0x70>
		FontWidth=Font16.Width;
  80640c:	d0a0050b 	ldhu	r2,-32748(gp)
  806410:	10bfffcc 	andi	r2,r2,65535
  806414:	e0bffa15 	stw	r2,-24(fp)
		FontHeight=Font16.Height;
  806418:	d0a0058b 	ldhu	r2,-32746(gp)
  80641c:	10bfffcc 	andi	r2,r2,65535
  806420:	e0bffb15 	stw	r2,-20(fp)
  806424:	00001606 	br	806480 <glcd_put_string_fixed+0xc8>
	}
	else if(FontSize==FNT20){
  806428:	e0800217 	ldw	r2,8(fp)
  80642c:	10800098 	cmpnei	r2,r2,2
  806430:	1000071e 	bne	r2,zero,806450 <glcd_put_string_fixed+0x98>
		FontWidth=Font20.Width;
  806434:	d0a0070b 	ldhu	r2,-32740(gp)
  806438:	10bfffcc 	andi	r2,r2,65535
  80643c:	e0bffa15 	stw	r2,-24(fp)
		FontHeight=Font20.Height;
  806440:	d0a0078b 	ldhu	r2,-32738(gp)
  806444:	10bfffcc 	andi	r2,r2,65535
  806448:	e0bffb15 	stw	r2,-20(fp)
  80644c:	00000c06 	br	806480 <glcd_put_string_fixed+0xc8>
	}
	else if(FontSize==FNT24){
  806450:	e0800217 	ldw	r2,8(fp)
  806454:	108000d8 	cmpnei	r2,r2,3
  806458:	1000071e 	bne	r2,zero,806478 <glcd_put_string_fixed+0xc0>
		FontWidth=Font24.Width;
  80645c:	d0a0090b 	ldhu	r2,-32732(gp)
  806460:	10bfffcc 	andi	r2,r2,65535
  806464:	e0bffa15 	stw	r2,-24(fp)
		FontHeight=Font24.Height;
  806468:	d0a0098b 	ldhu	r2,-32730(gp)
  80646c:	10bfffcc 	andi	r2,r2,65535
  806470:	e0bffb15 	stw	r2,-20(fp)
  806474:	00000206 	br	806480 <glcd_put_string_fixed+0xc8>
	}
	else{
		return -1;
  806478:	00bfffc4 	movi	r2,-1
  80647c:	00004b06 	br	8065ac <glcd_put_string_fixed+0x1f4>
	}

	if((x<0) || (x + FontWidth>GLCD_IMG_WIDTH)){
  806480:	e0bffc17 	ldw	r2,-16(fp)
  806484:	10000516 	blt	r2,zero,80649c <glcd_put_string_fixed+0xe4>
  806488:	e0fffc17 	ldw	r3,-16(fp)
  80648c:	e0bffa17 	ldw	r2,-24(fp)
  806490:	1885883a 	add	r2,r3,r2
  806494:	10805050 	cmplti	r2,r2,321
  806498:	1000021e 	bne	r2,zero,8064a4 <glcd_put_string_fixed+0xec>
		return -1;
  80649c:	00bfffc4 	movi	r2,-1
  8064a0:	00004206 	br	8065ac <glcd_put_string_fixed+0x1f4>
	}
	if((y<0) ||(y+FontHeight>GLCD_IMG_HEIGHT)){
  8064a4:	e0bffd17 	ldw	r2,-12(fp)
  8064a8:	10000516 	blt	r2,zero,8064c0 <glcd_put_string_fixed+0x108>
  8064ac:	e0fffd17 	ldw	r3,-12(fp)
  8064b0:	e0bffb17 	ldw	r2,-20(fp)
  8064b4:	1885883a 	add	r2,r3,r2
  8064b8:	10803c50 	cmplti	r2,r2,241
  8064bc:	1000021e 	bne	r2,zero,8064c8 <glcd_put_string_fixed+0x110>
		return -1;
  8064c0:	00bfffc4 	movi	r2,-1
  8064c4:	00003906 	br	8065ac <glcd_put_string_fixed+0x1f4>
	}

	STR = (char *)string;
  8064c8:	e0bffe17 	ldw	r2,-8(fp)
  8064cc:	e0bff915 	stw	r2,-28(fp)

	for(i=0,j=x;;i++,j+=FontWidth,STR++){
  8064d0:	e03ff715 	stw	zero,-36(fp)
  8064d4:	e0bffc17 	ldw	r2,-16(fp)
  8064d8:	e0bff815 	stw	r2,-32(fp)
		if (j>GLCD_IMG_WIDTH-1- FontWidth){
  8064dc:	00c04fc4 	movi	r3,319
  8064e0:	e0bffa17 	ldw	r2,-24(fp)
  8064e4:	1887c83a 	sub	r3,r3,r2
  8064e8:	e0bff817 	ldw	r2,-32(fp)
  8064ec:	1880020e 	bge	r3,r2,8064f8 <glcd_put_string_fixed+0x140>
			return -1;
  8064f0:	00bfffc4 	movi	r2,-1
  8064f4:	00002d06 	br	8065ac <glcd_put_string_fixed+0x1f4>
		}
		if (*STR==0){
  8064f8:	e0bff917 	ldw	r2,-28(fp)
  8064fc:	10800003 	ldbu	r2,0(r2)
  806500:	10803fcc 	andi	r2,r2,255
  806504:	1080201c 	xori	r2,r2,128
  806508:	10bfe004 	addi	r2,r2,-128
  80650c:	1000021e 	bne	r2,zero,806518 <glcd_put_string_fixed+0x160>
			return 0;	//w
  806510:	0005883a 	mov	r2,zero
  806514:	00002506 	br	8065ac <glcd_put_string_fixed+0x1f4>
		}
		if ((*STR>0x7f)||(*STR<0x20)){
  806518:	e0bff917 	ldw	r2,-28(fp)
  80651c:	10800003 	ldbu	r2,0(r2)
  806520:	10803fcc 	andi	r2,r2,255
  806524:	1080201c 	xori	r2,r2,128
  806528:	10bfe004 	addi	r2,r2,-128
  80652c:	10800808 	cmpgei	r2,r2,32
  806530:	1000021e 	bne	r2,zero,80653c <glcd_put_string_fixed+0x184>
			return -2;
  806534:	00bfff84 	movi	r2,-2
  806538:	00001c06 	br	8065ac <glcd_put_string_fixed+0x1f4>
		}
		put_charPattern(*STR,CharColor,j,y,FontSize);
  80653c:	e0bff917 	ldw	r2,-28(fp)
  806540:	10800003 	ldbu	r2,0(r2)
  806544:	10c03fcc 	andi	r3,r2,255
  806548:	18c0201c 	xori	r3,r3,128
  80654c:	18ffe004 	addi	r3,r3,-128
  806550:	e13fff0b 	ldhu	r4,-4(fp)
  806554:	e0bff817 	ldw	r2,-32(fp)
  806558:	117fffcc 	andi	r5,r2,65535
  80655c:	e0bffd17 	ldw	r2,-12(fp)
  806560:	11bfffcc 	andi	r6,r2,65535
  806564:	e0800217 	ldw	r2,8(fp)
  806568:	d8800015 	stw	r2,0(sp)
  80656c:	300f883a 	mov	r7,r6
  806570:	280d883a 	mov	r6,r5
  806574:	200b883a 	mov	r5,r4
  806578:	1809883a 	mov	r4,r3
  80657c:	08061300 	call	806130 <put_charPattern>
		return -1;
	}

	STR = (char *)string;

	for(i=0,j=x;;i++,j+=FontWidth,STR++){
  806580:	e0bff717 	ldw	r2,-36(fp)
  806584:	10800044 	addi	r2,r2,1
  806588:	e0bff715 	stw	r2,-36(fp)
  80658c:	e0fff817 	ldw	r3,-32(fp)
  806590:	e0bffa17 	ldw	r2,-24(fp)
  806594:	1885883a 	add	r2,r3,r2
  806598:	e0bff815 	stw	r2,-32(fp)
  80659c:	e0bff917 	ldw	r2,-28(fp)
  8065a0:	10800044 	addi	r2,r2,1
  8065a4:	e0bff915 	stw	r2,-28(fp)
		}
		if ((*STR>0x7f)||(*STR<0x20)){
			return -2;
		}
		put_charPattern(*STR,CharColor,j,y,FontSize);
	}
  8065a8:	003fcc06 	br	8064dc <__alt_data_end+0xfff064dc>
	return 0;
}
  8065ac:	e037883a 	mov	sp,fp
  8065b0:	dfc00117 	ldw	ra,4(sp)
  8065b4:	df000017 	ldw	fp,0(sp)
  8065b8:	dec00204 	addi	sp,sp,8
  8065bc:	f800283a 	ret

008065c0 <put_charPattern_Adafruit>:

/*
 * Adafruit Font Library
 * */
int put_charPattern_Adafruit(char CharCode,uint16_t CHAR_COLOR,uint16_t xs,uint16_t ys,int FontSel)
{
  8065c0:	deffec04 	addi	sp,sp,-80
  8065c4:	dfc01315 	stw	ra,76(sp)
  8065c8:	df001215 	stw	fp,72(sp)
  8065cc:	dc401115 	stw	r17,68(sp)
  8065d0:	dc001015 	stw	r16,64(sp)
  8065d4:	df001204 	addi	fp,sp,72
  8065d8:	2011883a 	mov	r8,r4
  8065dc:	2809883a 	mov	r4,r5
  8065e0:	3007883a 	mov	r3,r6
  8065e4:	3805883a 	mov	r2,r7
  8065e8:	e23ffa05 	stb	r8,-24(fp)
  8065ec:	e13ffb0d 	sth	r4,-20(fp)
  8065f0:	e0fffc0d 	sth	r3,-16(fp)
  8065f4:	e0bffd0d 	sth	r2,-12(fp)
	int FontWidth,FontHeight,FontDotCap,bitCnt;
	int xOffset,yOffset;
	uint8_t LinePattern;
	int BitCount;

	FirstCode = FntList[FontSel].pFnt->first;
  8065f8:	040020f4 	movhi	r16,131
  8065fc:	842dae04 	addi	r16,r16,-18760
  806600:	e0800217 	ldw	r2,8(fp)
  806604:	01400504 	movi	r5,20
  806608:	1009883a 	mov	r4,r2
  80660c:	080b2480 	call	80b248 <__mulsi3>
  806610:	8085883a 	add	r2,r16,r2
  806614:	10800017 	ldw	r2,0(r2)
  806618:	10800203 	ldbu	r2,8(r2)
  80661c:	e0bff405 	stb	r2,-48(fp)
	if ((CharCode > FntList[FontSel].pFnt->last)||(CharCode < FirstCode)){
  806620:	e47ffa07 	ldb	r17,-24(fp)
  806624:	040020f4 	movhi	r16,131
  806628:	842dae04 	addi	r16,r16,-18760
  80662c:	e0800217 	ldw	r2,8(fp)
  806630:	01400504 	movi	r5,20
  806634:	1009883a 	mov	r4,r2
  806638:	080b2480 	call	80b248 <__mulsi3>
  80663c:	8085883a 	add	r2,r16,r2
  806640:	10800017 	ldw	r2,0(r2)
  806644:	10800243 	ldbu	r2,9(r2)
  806648:	10803fcc 	andi	r2,r2,255
  80664c:	14400316 	blt	r2,r17,80665c <put_charPattern_Adafruit+0x9c>
  806650:	e0fffa07 	ldb	r3,-24(fp)
  806654:	e0bff403 	ldbu	r2,-48(fp)
  806658:	1880020e 	bge	r3,r2,806664 <put_charPattern_Adafruit+0xa4>
		return -1;
  80665c:	00bfffc4 	movi	r2,-1
  806660:	0000b206 	br	80692c <put_charPattern_Adafruit+0x36c>
	}

	char_offset=(CharCode - FirstCode);
  806664:	e0fffa03 	ldbu	r3,-24(fp)
  806668:	e0bff403 	ldbu	r2,-48(fp)
  80666c:	1885c83a 	sub	r2,r3,r2
  806670:	e0bff445 	stb	r2,-47(fp)
	pFNT = FntList[FontSel].pFnt->bitmap;
  806674:	040020f4 	movhi	r16,131
  806678:	842dae04 	addi	r16,r16,-18760
  80667c:	e0800217 	ldw	r2,8(fp)
  806680:	01400504 	movi	r5,20
  806684:	1009883a 	mov	r4,r2
  806688:	080b2480 	call	80b248 <__mulsi3>
  80668c:	8085883a 	add	r2,r16,r2
  806690:	10800017 	ldw	r2,0(r2)
  806694:	10800017 	ldw	r2,0(r2)
  806698:	e0bfee15 	stw	r2,-72(fp)
	pFNT += FntList[FontSel].pFnt->glyph[char_offset].bitmapOffset;
  80669c:	040020f4 	movhi	r16,131
  8066a0:	842dae04 	addi	r16,r16,-18760
  8066a4:	e0800217 	ldw	r2,8(fp)
  8066a8:	01400504 	movi	r5,20
  8066ac:	1009883a 	mov	r4,r2
  8066b0:	080b2480 	call	80b248 <__mulsi3>
  8066b4:	8085883a 	add	r2,r16,r2
  8066b8:	10800017 	ldw	r2,0(r2)
  8066bc:	10c00117 	ldw	r3,4(r2)
  8066c0:	e0bff443 	ldbu	r2,-47(fp)
  8066c4:	100490fa 	slli	r2,r2,3
  8066c8:	1885883a 	add	r2,r3,r2
  8066cc:	1080000b 	ldhu	r2,0(r2)
  8066d0:	10bfffcc 	andi	r2,r2,65535
  8066d4:	e0ffee17 	ldw	r3,-72(fp)
  8066d8:	1885883a 	add	r2,r3,r2
  8066dc:	e0bfee15 	stw	r2,-72(fp)

	FontWidth = FntList[FontSel].pFnt->glyph[char_offset].width;
  8066e0:	040020f4 	movhi	r16,131
  8066e4:	842dae04 	addi	r16,r16,-18760
  8066e8:	e0800217 	ldw	r2,8(fp)
  8066ec:	01400504 	movi	r5,20
  8066f0:	1009883a 	mov	r4,r2
  8066f4:	080b2480 	call	80b248 <__mulsi3>
  8066f8:	8085883a 	add	r2,r16,r2
  8066fc:	10800017 	ldw	r2,0(r2)
  806700:	10c00117 	ldw	r3,4(r2)
  806704:	e0bff443 	ldbu	r2,-47(fp)
  806708:	100490fa 	slli	r2,r2,3
  80670c:	1885883a 	add	r2,r3,r2
  806710:	10800083 	ldbu	r2,2(r2)
  806714:	10803fcc 	andi	r2,r2,255
  806718:	e0bff515 	stw	r2,-44(fp)
	FontHeight = FntList[FontSel].pFnt->glyph[char_offset].height;
  80671c:	040020f4 	movhi	r16,131
  806720:	842dae04 	addi	r16,r16,-18760
  806724:	e0800217 	ldw	r2,8(fp)
  806728:	01400504 	movi	r5,20
  80672c:	1009883a 	mov	r4,r2
  806730:	080b2480 	call	80b248 <__mulsi3>
  806734:	8085883a 	add	r2,r16,r2
  806738:	10800017 	ldw	r2,0(r2)
  80673c:	10c00117 	ldw	r3,4(r2)
  806740:	e0bff443 	ldbu	r2,-47(fp)
  806744:	100490fa 	slli	r2,r2,3
  806748:	1885883a 	add	r2,r3,r2
  80674c:	108000c3 	ldbu	r2,3(r2)
  806750:	10803fcc 	andi	r2,r2,255
  806754:	e0bff615 	stw	r2,-40(fp)
	FontDotCap = FontWidth * FontHeight;
  806758:	e17ff617 	ldw	r5,-40(fp)
  80675c:	e13ff517 	ldw	r4,-44(fp)
  806760:	080b2480 	call	80b248 <__mulsi3>
  806764:	e0bff715 	stw	r2,-36(fp)

	xOffset = FntList[FontSel].pFnt->glyph[char_offset].xOffset;
  806768:	040020f4 	movhi	r16,131
  80676c:	842dae04 	addi	r16,r16,-18760
  806770:	e0800217 	ldw	r2,8(fp)
  806774:	01400504 	movi	r5,20
  806778:	1009883a 	mov	r4,r2
  80677c:	080b2480 	call	80b248 <__mulsi3>
  806780:	8085883a 	add	r2,r16,r2
  806784:	10800017 	ldw	r2,0(r2)
  806788:	10c00117 	ldw	r3,4(r2)
  80678c:	e0bff443 	ldbu	r2,-47(fp)
  806790:	100490fa 	slli	r2,r2,3
  806794:	1885883a 	add	r2,r3,r2
  806798:	10800143 	ldbu	r2,5(r2)
  80679c:	10803fcc 	andi	r2,r2,255
  8067a0:	1080201c 	xori	r2,r2,128
  8067a4:	10bfe004 	addi	r2,r2,-128
  8067a8:	e0bff815 	stw	r2,-32(fp)
	yOffset = FntList[FontSel].pFnt->glyph[char_offset].yOffset;
  8067ac:	040020f4 	movhi	r16,131
  8067b0:	842dae04 	addi	r16,r16,-18760
  8067b4:	e0800217 	ldw	r2,8(fp)
  8067b8:	01400504 	movi	r5,20
  8067bc:	1009883a 	mov	r4,r2
  8067c0:	080b2480 	call	80b248 <__mulsi3>
  8067c4:	8085883a 	add	r2,r16,r2
  8067c8:	10800017 	ldw	r2,0(r2)
  8067cc:	10c00117 	ldw	r3,4(r2)
  8067d0:	e0bff443 	ldbu	r2,-47(fp)
  8067d4:	100490fa 	slli	r2,r2,3
  8067d8:	1885883a 	add	r2,r3,r2
  8067dc:	10800183 	ldbu	r2,6(r2)
  8067e0:	10803fcc 	andi	r2,r2,255
  8067e4:	1080201c 	xori	r2,r2,128
  8067e8:	10bfe004 	addi	r2,r2,-128
  8067ec:	e0bff915 	stw	r2,-28(fp)

	x=0;
  8067f0:	e03fef15 	stw	zero,-68(fp)
	y=0;
  8067f4:	e03ff015 	stw	zero,-64(fp)
	BitCount=8;
  8067f8:	00800204 	movi	r2,8
  8067fc:	e0bff315 	stw	r2,-52(fp)

	for(bitCnt=0;bitCnt<FontDotCap;bitCnt++){
  806800:	e03ff115 	stw	zero,-60(fp)
  806804:	00003806 	br	8068e8 <put_charPattern_Adafruit+0x328>
		if (8==BitCount){
  806808:	e0bff317 	ldw	r2,-52(fp)
  80680c:	10800218 	cmpnei	r2,r2,8
  806810:	1000061e 	bne	r2,zero,80682c <put_charPattern_Adafruit+0x26c>
			LinePattern = *pFNT++;
  806814:	e0bfee17 	ldw	r2,-72(fp)
  806818:	10c00044 	addi	r3,r2,1
  80681c:	e0ffee15 	stw	r3,-72(fp)
  806820:	10800003 	ldbu	r2,0(r2)
  806824:	e0bff205 	stb	r2,-56(fp)
			BitCount=0;
  806828:	e03ff315 	stw	zero,-52(fp)
		}
		if((LinePattern & 0x80)!=0){
  80682c:	e0bff203 	ldbu	r2,-56(fp)
  806830:	10803fcc 	andi	r2,r2,255
  806834:	1080201c 	xori	r2,r2,128
  806838:	10bfe004 	addi	r2,r2,-128
  80683c:	1000150e 	bge	r2,zero,806894 <put_charPattern_Adafruit+0x2d4>
#ifdef ILI9341
			Pset_9341(x+xs+xOffset,y+ys+yOffset,CHAR_COLOR);
  806840:	e0bfef17 	ldw	r2,-68(fp)
  806844:	1007883a 	mov	r3,r2
  806848:	e0bffc0b 	ldhu	r2,-16(fp)
  80684c:	1885883a 	add	r2,r3,r2
  806850:	1007883a 	mov	r3,r2
  806854:	e0bff817 	ldw	r2,-32(fp)
  806858:	1885883a 	add	r2,r3,r2
  80685c:	10ffffcc 	andi	r3,r2,65535
  806860:	e0bff017 	ldw	r2,-64(fp)
  806864:	1009883a 	mov	r4,r2
  806868:	e0bffd0b 	ldhu	r2,-12(fp)
  80686c:	2085883a 	add	r2,r4,r2
  806870:	1009883a 	mov	r4,r2
  806874:	e0bff917 	ldw	r2,-28(fp)
  806878:	2085883a 	add	r2,r4,r2
  80687c:	10bfffcc 	andi	r2,r2,65535
  806880:	e13ffb0b 	ldhu	r4,-20(fp)
  806884:	200d883a 	mov	r6,r4
  806888:	100b883a 	mov	r5,r2
  80688c:	1809883a 	mov	r4,r3
  806890:	0804e1c0 	call	804e1c <Pset_9341>
#endif
		}else{
			 //back
		}

		LinePattern = LinePattern<<1;
  806894:	e0bff203 	ldbu	r2,-56(fp)
  806898:	1085883a 	add	r2,r2,r2
  80689c:	e0bff205 	stb	r2,-56(fp)

		if(x>=FontWidth-1){
  8068a0:	e0bff517 	ldw	r2,-44(fp)
  8068a4:	10bfffc4 	addi	r2,r2,-1
  8068a8:	e0ffef17 	ldw	r3,-68(fp)
  8068ac:	18800516 	blt	r3,r2,8068c4 <put_charPattern_Adafruit+0x304>
			x=0;	y++;
  8068b0:	e03fef15 	stw	zero,-68(fp)
  8068b4:	e0bff017 	ldw	r2,-64(fp)
  8068b8:	10800044 	addi	r2,r2,1
  8068bc:	e0bff015 	stw	r2,-64(fp)
  8068c0:	00000306 	br	8068d0 <put_charPattern_Adafruit+0x310>
		}else{
			x++;
  8068c4:	e0bfef17 	ldw	r2,-68(fp)
  8068c8:	10800044 	addi	r2,r2,1
  8068cc:	e0bfef15 	stw	r2,-68(fp)
		}
		BitCount++;
  8068d0:	e0bff317 	ldw	r2,-52(fp)
  8068d4:	10800044 	addi	r2,r2,1
  8068d8:	e0bff315 	stw	r2,-52(fp)

	x=0;
	y=0;
	BitCount=8;

	for(bitCnt=0;bitCnt<FontDotCap;bitCnt++){
  8068dc:	e0bff117 	ldw	r2,-60(fp)
  8068e0:	10800044 	addi	r2,r2,1
  8068e4:	e0bff115 	stw	r2,-60(fp)
  8068e8:	e0fff117 	ldw	r3,-60(fp)
  8068ec:	e0bff717 	ldw	r2,-36(fp)
  8068f0:	18bfc516 	blt	r3,r2,806808 <__alt_data_end+0xfff06808>
		}else{
			x++;
		}
		BitCount++;
	}
	return FntList[FontSel].pFnt->glyph[char_offset].xAdvance;
  8068f4:	040020f4 	movhi	r16,131
  8068f8:	842dae04 	addi	r16,r16,-18760
  8068fc:	e0800217 	ldw	r2,8(fp)
  806900:	01400504 	movi	r5,20
  806904:	1009883a 	mov	r4,r2
  806908:	080b2480 	call	80b248 <__mulsi3>
  80690c:	8085883a 	add	r2,r16,r2
  806910:	10800017 	ldw	r2,0(r2)
  806914:	10c00117 	ldw	r3,4(r2)
  806918:	e0bff443 	ldbu	r2,-47(fp)
  80691c:	100490fa 	slli	r2,r2,3
  806920:	1885883a 	add	r2,r3,r2
  806924:	10800103 	ldbu	r2,4(r2)
  806928:	10803fcc 	andi	r2,r2,255
}
  80692c:	e6fffe04 	addi	sp,fp,-8
  806930:	dfc00317 	ldw	ra,12(sp)
  806934:	df000217 	ldw	fp,8(sp)
  806938:	dc400117 	ldw	r17,4(sp)
  80693c:	dc000017 	ldw	r16,0(sp)
  806940:	dec00404 	addi	sp,sp,16
  806944:	f800283a 	ret

00806948 <glcd_put_string_Adafruit>:

int glcd_put_string_Adafruit(int x,int y,char *string,uint16_t CharColor,int FontSel)
{
  806948:	defff604 	addi	sp,sp,-40
  80694c:	dfc00915 	stw	ra,36(sp)
  806950:	df000815 	stw	fp,32(sp)
  806954:	df000804 	addi	fp,sp,32
  806958:	e13ffc15 	stw	r4,-16(fp)
  80695c:	e17ffd15 	stw	r5,-12(fp)
  806960:	e1bffe15 	stw	r6,-8(fp)
  806964:	3805883a 	mov	r2,r7
  806968:	e0bfff0d 	sth	r2,-4(fp)
	int i,j,k;
	char *STR;

	if((x<0) || (x > GLCD_IMG_WIDTH)){
  80696c:	e0bffc17 	ldw	r2,-16(fp)
  806970:	10000316 	blt	r2,zero,806980 <glcd_put_string_Adafruit+0x38>
  806974:	e0bffc17 	ldw	r2,-16(fp)
  806978:	10805050 	cmplti	r2,r2,321
  80697c:	1000021e 	bne	r2,zero,806988 <glcd_put_string_Adafruit+0x40>
		return -1;
  806980:	00bfffc4 	movi	r2,-1
  806984:	00003606 	br	806a60 <glcd_put_string_Adafruit+0x118>
	}
	if((y<0) ||(y > GLCD_IMG_HEIGHT)){
  806988:	e0bffd17 	ldw	r2,-12(fp)
  80698c:	10000316 	blt	r2,zero,80699c <glcd_put_string_Adafruit+0x54>
  806990:	e0bffd17 	ldw	r2,-12(fp)
  806994:	10803c50 	cmplti	r2,r2,241
  806998:	1000021e 	bne	r2,zero,8069a4 <glcd_put_string_Adafruit+0x5c>
		return -1;
  80699c:	00bfffc4 	movi	r2,-1
  8069a0:	00002f06 	br	806a60 <glcd_put_string_Adafruit+0x118>
	}

	STR = (char *)string;
  8069a4:	e0bffe17 	ldw	r2,-8(fp)
  8069a8:	e0bffa15 	stw	r2,-24(fp)

	for(j=x;;STR++){
  8069ac:	e0bffc17 	ldw	r2,-16(fp)
  8069b0:	e0bff915 	stw	r2,-28(fp)

		if (*STR==0){
  8069b4:	e0bffa17 	ldw	r2,-24(fp)
  8069b8:	10800003 	ldbu	r2,0(r2)
  8069bc:	10803fcc 	andi	r2,r2,255
  8069c0:	1080201c 	xori	r2,r2,128
  8069c4:	10bfe004 	addi	r2,r2,-128
  8069c8:	1000021e 	bne	r2,zero,8069d4 <glcd_put_string_Adafruit+0x8c>
			return 0;
  8069cc:	0005883a 	mov	r2,zero
  8069d0:	00002306 	br	806a60 <glcd_put_string_Adafruit+0x118>
		}
		if (j>GLCD_IMG_WIDTH){
  8069d4:	e0bff917 	ldw	r2,-28(fp)
  8069d8:	10805050 	cmplti	r2,r2,321
  8069dc:	1000021e 	bne	r2,zero,8069e8 <glcd_put_string_Adafruit+0xa0>
			return 0;
  8069e0:	0005883a 	mov	r2,zero
  8069e4:	00001e06 	br	806a60 <glcd_put_string_Adafruit+0x118>
		}

		k=put_charPattern_Adafruit(*STR,CharColor,j,y,FontSel);
  8069e8:	e0bffa17 	ldw	r2,-24(fp)
  8069ec:	10800003 	ldbu	r2,0(r2)
  8069f0:	10c03fcc 	andi	r3,r2,255
  8069f4:	18c0201c 	xori	r3,r3,128
  8069f8:	18ffe004 	addi	r3,r3,-128
  8069fc:	e13fff0b 	ldhu	r4,-4(fp)
  806a00:	e0bff917 	ldw	r2,-28(fp)
  806a04:	117fffcc 	andi	r5,r2,65535
  806a08:	e0bffd17 	ldw	r2,-12(fp)
  806a0c:	11bfffcc 	andi	r6,r2,65535
  806a10:	e0800217 	ldw	r2,8(fp)
  806a14:	d8800015 	stw	r2,0(sp)
  806a18:	300f883a 	mov	r7,r6
  806a1c:	280d883a 	mov	r6,r5
  806a20:	200b883a 	mov	r5,r4
  806a24:	1809883a 	mov	r4,r3
  806a28:	08065c00 	call	8065c0 <put_charPattern_Adafruit>
  806a2c:	e0bffb15 	stw	r2,-20(fp)
		if(k<0){
  806a30:	e0bffb17 	ldw	r2,-20(fp)
  806a34:	1000020e 	bge	r2,zero,806a40 <glcd_put_string_Adafruit+0xf8>
			return -2;
  806a38:	00bfff84 	movi	r2,-2
  806a3c:	00000806 	br	806a60 <glcd_put_string_Adafruit+0x118>
		}else{
			j=j+k;
  806a40:	e0fff917 	ldw	r3,-28(fp)
  806a44:	e0bffb17 	ldw	r2,-20(fp)
  806a48:	1885883a 	add	r2,r3,r2
  806a4c:	e0bff915 	stw	r2,-28(fp)
		return -1;
	}

	STR = (char *)string;

	for(j=x;;STR++){
  806a50:	e0bffa17 	ldw	r2,-24(fp)
  806a54:	10800044 	addi	r2,r2,1
  806a58:	e0bffa15 	stw	r2,-24(fp)
		if(k<0){
			return -2;
		}else{
			j=j+k;
		}
	}
  806a5c:	003fd506 	br	8069b4 <__alt_data_end+0xfff069b4>
	return 0;
}
  806a60:	e037883a 	mov	sp,fp
  806a64:	dfc00117 	ldw	ra,4(sp)
  806a68:	df000017 	ldw	fp,0(sp)
  806a6c:	dec00204 	addi	sp,sp,8
  806a70:	f800283a 	ret

00806a74 <main>:




int main()
{
  806a74:	defffc04 	addi	sp,sp,-16
  806a78:	dfc00315 	stw	ra,12(sp)
  806a7c:	df000215 	stw	fp,8(sp)
  806a80:	df000204 	addi	fp,sp,8
	//Queue
	SnsorQue = xQueueCreate(4,sizeof(int));
  806a84:	000d883a 	mov	r6,zero
  806a88:	01400104 	movi	r5,4
  806a8c:	01000104 	movi	r4,4
  806a90:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  806a94:	d0a03515 	stw	r2,-32556(gp)
	SendReqQue = xQueueCreate(4,sizeof(int));
  806a98:	000d883a 	mov	r6,zero
  806a9c:	01400104 	movi	r5,4
  806aa0:	01000104 	movi	r4,4
  806aa4:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  806aa8:	d0a03615 	stw	r2,-32552(gp)
	ButtonQue = xQueueCreate(4,sizeof(char));
  806aac:	000d883a 	mov	r6,zero
  806ab0:	01400044 	movi	r5,1
  806ab4:	01000104 	movi	r4,4
  806ab8:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  806abc:	d0a03715 	stw	r2,-32548(gp)
	GLCD_QUE = xQueueCreate(32,sizeof(GRAP_LCD_QUE));
  806ac0:	000d883a 	mov	r6,zero
  806ac4:	01400404 	movi	r5,16
  806ac8:	01000804 	movi	r4,32
  806acc:	0800e0c0 	call	800e0c <xQueueGenericCreate>
  806ad0:	d0a03415 	stw	r2,-32560(gp)

	//main only create 7 scheduling  TASK
	xTaskCreate( task_com, "TK_COM", configMINIMAL_STACK_SIZE, NULL, TK_COM_PRIORITY, NULL );
  806ad4:	d8000115 	stw	zero,4(sp)
  806ad8:	00800044 	movi	r2,1
  806adc:	d8800015 	stw	r2,0(sp)
  806ae0:	000f883a 	mov	r7,zero
  806ae4:	01820004 	movi	r6,2048
  806ae8:	014020b4 	movhi	r5,130
  806aec:	2966ab04 	addi	r5,r5,-25940
  806af0:	01002074 	movhi	r4,129
  806af4:	21220b04 	addi	r4,r4,-30676
  806af8:	0801dd00 	call	801dd0 <xTaskCreate>
	xTaskCreate( task_sns, "TK_SNS", configMINIMAL_STACK_SIZE, NULL, TK_SNS_PRIORITY, NULL );
  806afc:	d8000115 	stw	zero,4(sp)
  806b00:	00800044 	movi	r2,1
  806b04:	d8800015 	stw	r2,0(sp)
  806b08:	000f883a 	mov	r7,zero
  806b0c:	01820004 	movi	r6,2048
  806b10:	014020b4 	movhi	r5,130
  806b14:	2966ad04 	addi	r5,r5,-25932
  806b18:	01002074 	movhi	r4,129
  806b1c:	21241004 	addi	r4,r4,-28608
  806b20:	0801dd00 	call	801dd0 <xTaskCreate>
	xTaskCreate( task_button, "TK_BUTTON", configMINIMAL_STACK_SIZE, NULL, TK_MAIN_PRIORITY, NULL );
  806b24:	d8000115 	stw	zero,4(sp)
  806b28:	00800044 	movi	r2,1
  806b2c:	d8800015 	stw	r2,0(sp)
  806b30:	000f883a 	mov	r7,zero
  806b34:	01820004 	movi	r6,2048
  806b38:	014020b4 	movhi	r5,130
  806b3c:	2966af04 	addi	r5,r5,-25924
  806b40:	01002074 	movhi	r4,129
  806b44:	2121a604 	addi	r4,r4,-31080
  806b48:	0801dd00 	call	801dd0 <xTaskCreate>
	xTaskCreate( task_main, "TK_MAIN", configMINIMAL_STACK_SIZE, NULL, TK_MAIN_PRIORITY, NULL );
  806b4c:	d8000115 	stw	zero,4(sp)
  806b50:	00800044 	movi	r2,1
  806b54:	d8800015 	stw	r2,0(sp)
  806b58:	000f883a 	mov	r7,zero
  806b5c:	01820004 	movi	r6,2048
  806b60:	014020b4 	movhi	r5,130
  806b64:	2966b204 	addi	r5,r5,-25912
  806b68:	01002074 	movhi	r4,129
  806b6c:	2123b504 	addi	r4,r4,-28972
  806b70:	0801dd00 	call	801dd0 <xTaskCreate>
	xTaskCreate( task_disp, "TK_DISP", configMINIMAL_STACK_SIZE, NULL, TK_DISP_PRIORITY, NULL );
  806b74:	d8000115 	stw	zero,4(sp)
  806b78:	00800044 	movi	r2,1
  806b7c:	d8800015 	stw	r2,0(sp)
  806b80:	000f883a 	mov	r7,zero
  806b84:	01820004 	movi	r6,2048
  806b88:	014020b4 	movhi	r5,130
  806b8c:	2966b404 	addi	r5,r5,-25904
  806b90:	01002074 	movhi	r4,129
  806b94:	2122e904 	addi	r4,r4,-29788
  806b98:	0801dd00 	call	801dd0 <xTaskCreate>

	vTaskStartScheduler();
  806b9c:	08029740 	call	802974 <vTaskStartScheduler>
	while(1){}
  806ba0:	003fff06 	br	806ba0 <__alt_data_end+0xfff06ba0>

00806ba4 <conv_4bit_7segdata>:

extern xQueueHandle GLCD_QUE;
extern int SnsCtrlSTS;

char conv_4bit_7segdata(char data)
{
  806ba4:	defffe04 	addi	sp,sp,-8
  806ba8:	df000115 	stw	fp,4(sp)
  806bac:	df000104 	addi	fp,sp,4
  806bb0:	2005883a 	mov	r2,r4
  806bb4:	e0bfff05 	stb	r2,-4(fp)
	switch( data&0x0f){
  806bb8:	e0bfff03 	ldbu	r2,-4(fp)
  806bbc:	10803fcc 	andi	r2,r2,255
  806bc0:	108003cc 	andi	r2,r2,15
  806bc4:	10c00428 	cmpgeui	r3,r2,16
  806bc8:	1800361e 	bne	r3,zero,806ca4 <conv_4bit_7segdata+0x100>
  806bcc:	100690ba 	slli	r3,r2,2
  806bd0:	00802034 	movhi	r2,128
  806bd4:	109af904 	addi	r2,r2,27620
  806bd8:	1885883a 	add	r2,r3,r2
  806bdc:	10800017 	ldw	r2,0(r2)
  806be0:	1000683a 	jmp	r2
  806be4:	00806c24 	muli	r2,zero,432
  806be8:	00806c2c 	andhi	r2,zero,432
  806bec:	00806c34 	movhi	r2,432
  806bf0:	00806c3c 	xorhi	r2,zero,432
  806bf4:	00806c44 	movi	r2,433
  806bf8:	00806c4c 	andi	r2,zero,433
  806bfc:	00806c54 	movui	r2,433
  806c00:	00806c5c 	xori	r2,zero,433
  806c04:	00806c64 	muli	r2,zero,433
  806c08:	00806c6c 	andhi	r2,zero,433
  806c0c:	00806c74 	movhi	r2,433
  806c10:	00806c7c 	xorhi	r2,zero,433
  806c14:	00806c84 	movi	r2,434
  806c18:	00806c8c 	andi	r2,zero,434
  806c1c:	00806c94 	movui	r2,434
  806c20:	00806c9c 	xori	r2,zero,434
	case 0x00:	return 0xc0;
  806c24:	00bff004 	movi	r2,-64
  806c28:	00001f06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x01:	return 0xf9;
  806c2c:	00bffe44 	movi	r2,-7
  806c30:	00001d06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x02:	return 0xa4;
  806c34:	00bfe904 	movi	r2,-92
  806c38:	00001b06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x03:	return 0x70;
  806c3c:	00801c04 	movi	r2,112
  806c40:	00001906 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x04:	return 0x99;
  806c44:	00bfe644 	movi	r2,-103
  806c48:	00001706 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x05:	return 0x92;
  806c4c:	00bfe484 	movi	r2,-110
  806c50:	00001506 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x06:	return 0x82;
  806c54:	00bfe084 	movi	r2,-126
  806c58:	00001306 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x07:	return 0xf8;
  806c5c:	00bffe04 	movi	r2,-8
  806c60:	00001106 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x08:	return 0x80;
  806c64:	00bfe004 	movi	r2,-128
  806c68:	00000f06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x09:	return 0x90;
  806c6c:	00bfe404 	movi	r2,-112
  806c70:	00000d06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0a:	return 0x88;
  806c74:	00bfe204 	movi	r2,-120
  806c78:	00000b06 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0b:	return 0x83;
  806c7c:	00bfe0c4 	movi	r2,-125
  806c80:	00000906 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0c:	return 0xc6;
  806c84:	00bff184 	movi	r2,-58
  806c88:	00000706 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0d:	return 0xa1;
  806c8c:	00bfe844 	movi	r2,-95
  806c90:	00000506 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0e:	return 0x86;
  806c94:	00bfe184 	movi	r2,-122
  806c98:	00000306 	br	806ca8 <conv_4bit_7segdata+0x104>
	case 0x0f:	return 0x8e;
  806c9c:	00bfe384 	movi	r2,-114
  806ca0:	00000106 	br	806ca8 <conv_4bit_7segdata+0x104>
	default:	return 0xff;
  806ca4:	00bfffc4 	movi	r2,-1
	}
}
  806ca8:	e037883a 	mov	sp,fp
  806cac:	df000017 	ldw	fp,0(sp)
  806cb0:	dec00104 	addi	sp,sp,4
  806cb4:	f800283a 	ret

00806cb8 <debug_print>:

void debug_print(uint16_t color,char *str){
  806cb8:	defff804 	addi	sp,sp,-32
  806cbc:	dfc00715 	stw	ra,28(sp)
  806cc0:	df000615 	stw	fp,24(sp)
  806cc4:	df000604 	addi	fp,sp,24
  806cc8:	2005883a 	mov	r2,r4
  806ccc:	e17fff15 	stw	r5,-4(fp)
  806cd0:	e0bffe0d 	sth	r2,-8(fp)
	GRAP_LCD_QUE	QUE_GLCD_LOCAL;
	QUE_GLCD_LOCAL.DEBUG_LOG.CMD = GLCDCMD_DEBUGLOG;
  806cd4:	00a00004 	movi	r2,-32768
  806cd8:	e0bffa0d 	sth	r2,-24(fp)
	QUE_GLCD_LOCAL.DEBUG_LOG.COLOR=color;
  806cdc:	e0bffe0b 	ldhu	r2,-8(fp)
  806ce0:	e0bffa8d 	sth	r2,-22(fp)
	QUE_GLCD_LOCAL.DEBUG_LOG.pSTR=str;
  806ce4:	e0bfff17 	ldw	r2,-4(fp)
  806ce8:	e0bffb15 	stw	r2,-20(fp)
	xQueueSendToBack(GLCD_QUE,&QUE_GLCD_LOCAL,10);
  806cec:	d0a03417 	ldw	r2,-32560(gp)
  806cf0:	000f883a 	mov	r7,zero
  806cf4:	01800284 	movi	r6,10
  806cf8:	e17ffa04 	addi	r5,fp,-24
  806cfc:	1009883a 	mov	r4,r2
  806d00:	08011780 	call	801178 <xQueueGenericSend>

}
  806d04:	0001883a 	nop
  806d08:	e037883a 	mov	sp,fp
  806d0c:	dfc00117 	ldw	ra,4(sp)
  806d10:	df000017 	ldw	fp,0(sp)
  806d14:	dec00204 	addi	sp,sp,8
  806d18:	f800283a 	ret

00806d1c <InitCom>:

void InitCom(void)
{
  806d1c:	defffe04 	addi	sp,sp,-8
  806d20:	dfc00115 	stw	ra,4(sp)
  806d24:	df000015 	stw	fp,0(sp)
  806d28:	d839883a 	mov	fp,sp
	//FT245 B
	initFT245mod();
  806d2c:	08059600 	call	805960 <initFT245mod>
	FT245IRQregist();
  806d30:	0805a000 	call	805a00 <FT245IRQregist>
	FT245_EnableRxIrq();
  806d34:	0805a400 	call	805a40 <FT245_EnableRxIrq>

	Ft245Data.OverFlow=0;
  806d38:	008020f4 	movhi	r2,131
  806d3c:	10adc204 	addi	r2,r2,-18680
  806d40:	10000515 	stw	zero,20(r2)
	Ft245Data.RcvCnt=0;
  806d44:	008020f4 	movhi	r2,131
  806d48:	10adc204 	addi	r2,r2,-18680
  806d4c:	10000415 	stw	zero,16(r2)
	Ft245Data.RecvSeq=IDLE;
  806d50:	008020f4 	movhi	r2,131
  806d54:	10adc204 	addi	r2,r2,-18680
  806d58:	10000615 	stw	zero,24(r2)
}
  806d5c:	0001883a 	nop
  806d60:	e037883a 	mov	sp,fp
  806d64:	dfc00117 	ldw	ra,4(sp)
  806d68:	df000017 	ldw	fp,0(sp)
  806d6c:	dec00204 	addi	sp,sp,8
  806d70:	f800283a 	ret

00806d74 <AsciiHex2uint16>:

int AsciiHex2uint16( char *src,uint16_t *val)
{
  806d74:	defffb04 	addi	sp,sp,-20
  806d78:	df000415 	stw	fp,16(sp)
  806d7c:	df000404 	addi	fp,sp,16
  806d80:	e13ffe15 	stw	r4,-8(fp)
  806d84:	e17fff15 	stw	r5,-4(fp)
	int i;
	uint16_t temp=0;
  806d88:	e03ffd0d 	sth	zero,-12(fp)

	for(i=0;i<4;i++,src++){
  806d8c:	e03ffc15 	stw	zero,-16(fp)
  806d90:	00003b06 	br	806e80 <AsciiHex2uint16+0x10c>
		temp = temp<<4;
  806d94:	e0bffd0b 	ldhu	r2,-12(fp)
  806d98:	1004913a 	slli	r2,r2,4
  806d9c:	e0bffd0d 	sth	r2,-12(fp)
		if((*src>='0')&&(*src<='9')){
  806da0:	e0bffe17 	ldw	r2,-8(fp)
  806da4:	10800003 	ldbu	r2,0(r2)
  806da8:	10803fcc 	andi	r2,r2,255
  806dac:	1080201c 	xori	r2,r2,128
  806db0:	10bfe004 	addi	r2,r2,-128
  806db4:	10800c10 	cmplti	r2,r2,48
  806db8:	1000111e 	bne	r2,zero,806e00 <AsciiHex2uint16+0x8c>
  806dbc:	e0bffe17 	ldw	r2,-8(fp)
  806dc0:	10800003 	ldbu	r2,0(r2)
  806dc4:	10803fcc 	andi	r2,r2,255
  806dc8:	1080201c 	xori	r2,r2,128
  806dcc:	10bfe004 	addi	r2,r2,-128
  806dd0:	10800e88 	cmpgei	r2,r2,58
  806dd4:	10000a1e 	bne	r2,zero,806e00 <AsciiHex2uint16+0x8c>
			temp += (*src-'0');
  806dd8:	e0bffe17 	ldw	r2,-8(fp)
  806ddc:	10800003 	ldbu	r2,0(r2)
  806de0:	10c03fcc 	andi	r3,r2,255
  806de4:	18c0201c 	xori	r3,r3,128
  806de8:	18ffe004 	addi	r3,r3,-128
  806dec:	e0bffd0b 	ldhu	r2,-12(fp)
  806df0:	1885883a 	add	r2,r3,r2
  806df4:	10bff404 	addi	r2,r2,-48
  806df8:	e0bffd0d 	sth	r2,-12(fp)
  806dfc:	00001a06 	br	806e68 <AsciiHex2uint16+0xf4>
		}else if((*src>='A')&&(*src<='F')){
  806e00:	e0bffe17 	ldw	r2,-8(fp)
  806e04:	10800003 	ldbu	r2,0(r2)
  806e08:	10803fcc 	andi	r2,r2,255
  806e0c:	1080201c 	xori	r2,r2,128
  806e10:	10bfe004 	addi	r2,r2,-128
  806e14:	10801050 	cmplti	r2,r2,65
  806e18:	1000111e 	bne	r2,zero,806e60 <AsciiHex2uint16+0xec>
  806e1c:	e0bffe17 	ldw	r2,-8(fp)
  806e20:	10800003 	ldbu	r2,0(r2)
  806e24:	10803fcc 	andi	r2,r2,255
  806e28:	1080201c 	xori	r2,r2,128
  806e2c:	10bfe004 	addi	r2,r2,-128
  806e30:	108011c8 	cmpgei	r2,r2,71
  806e34:	10000a1e 	bne	r2,zero,806e60 <AsciiHex2uint16+0xec>
			temp += (*src-55);
  806e38:	e0bffe17 	ldw	r2,-8(fp)
  806e3c:	10800003 	ldbu	r2,0(r2)
  806e40:	10c03fcc 	andi	r3,r2,255
  806e44:	18c0201c 	xori	r3,r3,128
  806e48:	18ffe004 	addi	r3,r3,-128
  806e4c:	e0bffd0b 	ldhu	r2,-12(fp)
  806e50:	1885883a 	add	r2,r3,r2
  806e54:	10bff244 	addi	r2,r2,-55
  806e58:	e0bffd0d 	sth	r2,-12(fp)
  806e5c:	00000206 	br	806e68 <AsciiHex2uint16+0xf4>
		}else{
			return -1;
  806e60:	00bfffc4 	movi	r2,-1
  806e64:	00000d06 	br	806e9c <AsciiHex2uint16+0x128>
int AsciiHex2uint16( char *src,uint16_t *val)
{
	int i;
	uint16_t temp=0;

	for(i=0;i<4;i++,src++){
  806e68:	e0bffc17 	ldw	r2,-16(fp)
  806e6c:	10800044 	addi	r2,r2,1
  806e70:	e0bffc15 	stw	r2,-16(fp)
  806e74:	e0bffe17 	ldw	r2,-8(fp)
  806e78:	10800044 	addi	r2,r2,1
  806e7c:	e0bffe15 	stw	r2,-8(fp)
  806e80:	e0bffc17 	ldw	r2,-16(fp)
  806e84:	10800110 	cmplti	r2,r2,4
  806e88:	103fc21e 	bne	r2,zero,806d94 <__alt_data_end+0xfff06d94>
			temp += (*src-55);
		}else{
			return -1;
		}
	}
	*val=temp;
  806e8c:	e0bfff17 	ldw	r2,-4(fp)
  806e90:	e0fffd0b 	ldhu	r3,-12(fp)
  806e94:	10c0000d 	sth	r3,0(r2)
	return 0;
  806e98:	0005883a 	mov	r2,zero
}
  806e9c:	e037883a 	mov	sp,fp
  806ea0:	df000017 	ldw	fp,0(sp)
  806ea4:	dec00104 	addi	sp,sp,4
  806ea8:	f800283a 	ret

00806eac <uint16toAsciiHex>:

void uint16toAsciiHex( uint16_t val,char *dst)
{
  806eac:	defffa04 	addi	sp,sp,-24
  806eb0:	df000515 	stw	fp,20(sp)
  806eb4:	df000504 	addi	fp,sp,20
  806eb8:	2005883a 	mov	r2,r4
  806ebc:	e17fff15 	stw	r5,-4(fp)
  806ec0:	e0bffe0d 	sth	r2,-8(fp)
	uint16_t v;
	int i;
	char temp;

	v=val;
  806ec4:	e0bffe0b 	ldhu	r2,-8(fp)
  806ec8:	e0bffb0d 	sth	r2,-20(fp)
	for(i=3;i>=0;i--){
  806ecc:	008000c4 	movi	r2,3
  806ed0:	e0bffc15 	stw	r2,-16(fp)
  806ed4:	00001906 	br	806f3c <uint16toAsciiHex+0x90>
		temp = v & 0x0f;
  806ed8:	e0bffb0b 	ldhu	r2,-20(fp)
  806edc:	108003cc 	andi	r2,r2,15
  806ee0:	e0bffd05 	stb	r2,-12(fp)
		if (temp>9){
  806ee4:	e0bffd07 	ldb	r2,-12(fp)
  806ee8:	10800290 	cmplti	r2,r2,10
  806eec:	1000071e 	bne	r2,zero,806f0c <uint16toAsciiHex+0x60>
			*(dst+i)=(temp + 55);
  806ef0:	e0bffc17 	ldw	r2,-16(fp)
  806ef4:	e0ffff17 	ldw	r3,-4(fp)
  806ef8:	1885883a 	add	r2,r3,r2
  806efc:	e0fffd03 	ldbu	r3,-12(fp)
  806f00:	18c00dc4 	addi	r3,r3,55
  806f04:	10c00005 	stb	r3,0(r2)
  806f08:	00000606 	br	806f24 <uint16toAsciiHex+0x78>
		}else{
			*(dst+i)=(temp + '0');
  806f0c:	e0bffc17 	ldw	r2,-16(fp)
  806f10:	e0ffff17 	ldw	r3,-4(fp)
  806f14:	1885883a 	add	r2,r3,r2
  806f18:	e0fffd03 	ldbu	r3,-12(fp)
  806f1c:	18c00c04 	addi	r3,r3,48
  806f20:	10c00005 	stb	r3,0(r2)
		}
		v = v >>4;
  806f24:	e0bffb0b 	ldhu	r2,-20(fp)
  806f28:	1004d13a 	srli	r2,r2,4
  806f2c:	e0bffb0d 	sth	r2,-20(fp)
	uint16_t v;
	int i;
	char temp;

	v=val;
	for(i=3;i>=0;i--){
  806f30:	e0bffc17 	ldw	r2,-16(fp)
  806f34:	10bfffc4 	addi	r2,r2,-1
  806f38:	e0bffc15 	stw	r2,-16(fp)
  806f3c:	e0bffc17 	ldw	r2,-16(fp)
  806f40:	103fe50e 	bge	r2,zero,806ed8 <__alt_data_end+0xfff06ed8>
		}else{
			*(dst+i)=(temp + '0');
		}
		v = v >>4;
	}
	*(dst+4)=0;
  806f44:	e0bfff17 	ldw	r2,-4(fp)
  806f48:	10800104 	addi	r2,r2,4
  806f4c:	10000005 	stb	zero,0(r2)

}
  806f50:	0001883a 	nop
  806f54:	e037883a 	mov	sp,fp
  806f58:	df000017 	ldw	fp,0(sp)
  806f5c:	dec00104 	addi	sp,sp,4
  806f60:	f800283a 	ret

00806f64 <AsciiHex2char>:



int AsciiHex2char( char *src,uint8_t *val)
{
  806f64:	defffc04 	addi	sp,sp,-16
  806f68:	df000315 	stw	fp,12(sp)
  806f6c:	df000304 	addi	fp,sp,12
  806f70:	e13ffe15 	stw	r4,-8(fp)
  806f74:	e17fff15 	stw	r5,-4(fp)
	uint8_t temp=0;
  806f78:	e03ffd05 	stb	zero,-12(fp)
	if((*src>='0')&&(*src<='9')){
  806f7c:	e0bffe17 	ldw	r2,-8(fp)
  806f80:	10800003 	ldbu	r2,0(r2)
  806f84:	10803fcc 	andi	r2,r2,255
  806f88:	1080201c 	xori	r2,r2,128
  806f8c:	10bfe004 	addi	r2,r2,-128
  806f90:	10800c10 	cmplti	r2,r2,48
  806f94:	1000101e 	bne	r2,zero,806fd8 <AsciiHex2char+0x74>
  806f98:	e0bffe17 	ldw	r2,-8(fp)
  806f9c:	10800003 	ldbu	r2,0(r2)
  806fa0:	10803fcc 	andi	r2,r2,255
  806fa4:	1080201c 	xori	r2,r2,128
  806fa8:	10bfe004 	addi	r2,r2,-128
  806fac:	10800e88 	cmpgei	r2,r2,58
  806fb0:	1000091e 	bne	r2,zero,806fd8 <AsciiHex2char+0x74>
		temp=(*src-'0')*0x10;
  806fb4:	e0bffe17 	ldw	r2,-8(fp)
  806fb8:	10800003 	ldbu	r2,0(r2)
  806fbc:	10803fcc 	andi	r2,r2,255
  806fc0:	1080201c 	xori	r2,r2,128
  806fc4:	10bfe004 	addi	r2,r2,-128
  806fc8:	10bff404 	addi	r2,r2,-48
  806fcc:	1004913a 	slli	r2,r2,4
  806fd0:	e0bffd05 	stb	r2,-12(fp)
  806fd4:	00001906 	br	80703c <AsciiHex2char+0xd8>
	}else if((*src>='A')&&(*src<='F')){
  806fd8:	e0bffe17 	ldw	r2,-8(fp)
  806fdc:	10800003 	ldbu	r2,0(r2)
  806fe0:	10803fcc 	andi	r2,r2,255
  806fe4:	1080201c 	xori	r2,r2,128
  806fe8:	10bfe004 	addi	r2,r2,-128
  806fec:	10801050 	cmplti	r2,r2,65
  806ff0:	1000101e 	bne	r2,zero,807034 <AsciiHex2char+0xd0>
  806ff4:	e0bffe17 	ldw	r2,-8(fp)
  806ff8:	10800003 	ldbu	r2,0(r2)
  806ffc:	10803fcc 	andi	r2,r2,255
  807000:	1080201c 	xori	r2,r2,128
  807004:	10bfe004 	addi	r2,r2,-128
  807008:	108011c8 	cmpgei	r2,r2,71
  80700c:	1000091e 	bne	r2,zero,807034 <AsciiHex2char+0xd0>
		temp=(*src-55)*0x10;
  807010:	e0bffe17 	ldw	r2,-8(fp)
  807014:	10800003 	ldbu	r2,0(r2)
  807018:	10803fcc 	andi	r2,r2,255
  80701c:	1080201c 	xori	r2,r2,128
  807020:	10bfe004 	addi	r2,r2,-128
  807024:	10bff244 	addi	r2,r2,-55
  807028:	1004913a 	slli	r2,r2,4
  80702c:	e0bffd05 	stb	r2,-12(fp)
  807030:	00000206 	br	80703c <AsciiHex2char+0xd8>
	}else{
		return -1;
  807034:	00bfffc4 	movi	r2,-1
  807038:	00003806 	br	80711c <AsciiHex2char+0x1b8>
	}

	if((*(src+1)>='0')&&(*(src+1)<='9')){
  80703c:	e0bffe17 	ldw	r2,-8(fp)
  807040:	10800044 	addi	r2,r2,1
  807044:	10800003 	ldbu	r2,0(r2)
  807048:	10803fcc 	andi	r2,r2,255
  80704c:	1080201c 	xori	r2,r2,128
  807050:	10bfe004 	addi	r2,r2,-128
  807054:	10800c10 	cmplti	r2,r2,48
  807058:	1000111e 	bne	r2,zero,8070a0 <AsciiHex2char+0x13c>
  80705c:	e0bffe17 	ldw	r2,-8(fp)
  807060:	10800044 	addi	r2,r2,1
  807064:	10800003 	ldbu	r2,0(r2)
  807068:	10803fcc 	andi	r2,r2,255
  80706c:	1080201c 	xori	r2,r2,128
  807070:	10bfe004 	addi	r2,r2,-128
  807074:	10800e88 	cmpgei	r2,r2,58
  807078:	1000091e 	bne	r2,zero,8070a0 <AsciiHex2char+0x13c>
		temp+=(*(src+1)-'0');
  80707c:	e0bffe17 	ldw	r2,-8(fp)
  807080:	10800044 	addi	r2,r2,1
  807084:	10800003 	ldbu	r2,0(r2)
  807088:	1007883a 	mov	r3,r2
  80708c:	e0bffd03 	ldbu	r2,-12(fp)
  807090:	1885883a 	add	r2,r3,r2
  807094:	10bff404 	addi	r2,r2,-48
  807098:	e0bffd05 	stb	r2,-12(fp)
  80709c:	00001b06 	br	80710c <AsciiHex2char+0x1a8>
	}else if((*(src+1)>='A')&&(*(src+1)<='F')){
  8070a0:	e0bffe17 	ldw	r2,-8(fp)
  8070a4:	10800044 	addi	r2,r2,1
  8070a8:	10800003 	ldbu	r2,0(r2)
  8070ac:	10803fcc 	andi	r2,r2,255
  8070b0:	1080201c 	xori	r2,r2,128
  8070b4:	10bfe004 	addi	r2,r2,-128
  8070b8:	10801050 	cmplti	r2,r2,65
  8070bc:	1000111e 	bne	r2,zero,807104 <AsciiHex2char+0x1a0>
  8070c0:	e0bffe17 	ldw	r2,-8(fp)
  8070c4:	10800044 	addi	r2,r2,1
  8070c8:	10800003 	ldbu	r2,0(r2)
  8070cc:	10803fcc 	andi	r2,r2,255
  8070d0:	1080201c 	xori	r2,r2,128
  8070d4:	10bfe004 	addi	r2,r2,-128
  8070d8:	108011c8 	cmpgei	r2,r2,71
  8070dc:	1000091e 	bne	r2,zero,807104 <AsciiHex2char+0x1a0>
		temp+=(*(src+1)-55);
  8070e0:	e0bffe17 	ldw	r2,-8(fp)
  8070e4:	10800044 	addi	r2,r2,1
  8070e8:	10800003 	ldbu	r2,0(r2)
  8070ec:	1007883a 	mov	r3,r2
  8070f0:	e0bffd03 	ldbu	r2,-12(fp)
  8070f4:	1885883a 	add	r2,r3,r2
  8070f8:	10bff244 	addi	r2,r2,-55
  8070fc:	e0bffd05 	stb	r2,-12(fp)
  807100:	00000206 	br	80710c <AsciiHex2char+0x1a8>
	}else{
		return -1;
  807104:	00bfffc4 	movi	r2,-1
  807108:	00000406 	br	80711c <AsciiHex2char+0x1b8>
	}
	*val = temp;
  80710c:	e0bfff17 	ldw	r2,-4(fp)
  807110:	e0fffd03 	ldbu	r3,-12(fp)
  807114:	10c00005 	stb	r3,0(r2)
	return 0;
  807118:	0005883a 	mov	r2,zero
}
  80711c:	e037883a 	mov	sp,fp
  807120:	df000017 	ldw	fp,0(sp)
  807124:	dec00104 	addi	sp,sp,4
  807128:	f800283a 	ret

0080712c <char2AsciiHex>:


void char2AsciiHex( char val,char *dst)
{
  80712c:	defffc04 	addi	sp,sp,-16
  807130:	df000315 	stw	fp,12(sp)
  807134:	df000304 	addi	fp,sp,12
  807138:	2005883a 	mov	r2,r4
  80713c:	e17fff15 	stw	r5,-4(fp)
  807140:	e0bffe05 	stb	r2,-8(fp)
	char temp;

	temp=(val>>4)&0x0f;
  807144:	e0bffe03 	ldbu	r2,-8(fp)
  807148:	10803fcc 	andi	r2,r2,255
  80714c:	1004d13a 	srli	r2,r2,4
  807150:	e0bffd05 	stb	r2,-12(fp)
	if (temp>9){
  807154:	e0bffd07 	ldb	r2,-12(fp)
  807158:	10800290 	cmplti	r2,r2,10
  80715c:	1000061e 	bne	r2,zero,807178 <char2AsciiHex+0x4c>
		*dst=(temp + 55);
  807160:	e0bffd03 	ldbu	r2,-12(fp)
  807164:	10800dc4 	addi	r2,r2,55
  807168:	1007883a 	mov	r3,r2
  80716c:	e0bfff17 	ldw	r2,-4(fp)
  807170:	10c00005 	stb	r3,0(r2)
  807174:	00000506 	br	80718c <char2AsciiHex+0x60>
	}else{
		*dst=(temp + '0');
  807178:	e0bffd03 	ldbu	r2,-12(fp)
  80717c:	10800c04 	addi	r2,r2,48
  807180:	1007883a 	mov	r3,r2
  807184:	e0bfff17 	ldw	r2,-4(fp)
  807188:	10c00005 	stb	r3,0(r2)
	}

	temp=val&0x0f;
  80718c:	e0bffe03 	ldbu	r2,-8(fp)
  807190:	108003cc 	andi	r2,r2,15
  807194:	e0bffd05 	stb	r2,-12(fp)
	if (temp>9){
  807198:	e0bffd07 	ldb	r2,-12(fp)
  80719c:	10800290 	cmplti	r2,r2,10
  8071a0:	1000061e 	bne	r2,zero,8071bc <char2AsciiHex+0x90>
		*(dst+1)=(temp + 55);
  8071a4:	e0bfff17 	ldw	r2,-4(fp)
  8071a8:	10800044 	addi	r2,r2,1
  8071ac:	e0fffd03 	ldbu	r3,-12(fp)
  8071b0:	18c00dc4 	addi	r3,r3,55
  8071b4:	10c00005 	stb	r3,0(r2)
  8071b8:	00000506 	br	8071d0 <char2AsciiHex+0xa4>
	}else{
		*(dst+1)=(temp + '0');
  8071bc:	e0bfff17 	ldw	r2,-4(fp)
  8071c0:	10800044 	addi	r2,r2,1
  8071c4:	e0fffd03 	ldbu	r3,-12(fp)
  8071c8:	18c00c04 	addi	r3,r3,48
  8071cc:	10c00005 	stb	r3,0(r2)
	}
	*(dst+2)=0;
  8071d0:	e0bfff17 	ldw	r2,-4(fp)
  8071d4:	10800084 	addi	r2,r2,2
  8071d8:	10000005 	stb	zero,0(r2)
}
  8071dc:	0001883a 	nop
  8071e0:	e037883a 	mov	sp,fp
  8071e4:	df000017 	ldw	fp,0(sp)
  8071e8:	dec00104 	addi	sp,sp,4
  8071ec:	f800283a 	ret

008071f0 <CmndSeq>:



void CmndSeq(char recv_char){
  8071f0:	defffe04 	addi	sp,sp,-8
  8071f4:	df000115 	stw	fp,4(sp)
  8071f8:	df000104 	addi	fp,sp,4
  8071fc:	2005883a 	mov	r2,r4
  807200:	e0bfff05 	stb	r2,-4(fp)

	if (recv_char=='(') {	//IR}hMJn
  807204:	e0bfff07 	ldb	r2,-4(fp)
  807208:	10800a18 	cmpnei	r2,r2,40
  80720c:	1000081e 	bne	r2,zero,807230 <CmndSeq+0x40>
		Ft245Data.RcvCnt=0;
  807210:	008020f4 	movhi	r2,131
  807214:	10adc204 	addi	r2,r2,-18680
  807218:	10000415 	stw	zero,16(r2)
		Ft245Data.RecvSeq=CMND;
  80721c:	008020f4 	movhi	r2,131
  807220:	10adc204 	addi	r2,r2,-18680
  807224:	00c00044 	movi	r3,1
  807228:	10c00615 	stw	r3,24(r2)
	}else{
		Ft245Data.RecvBuf[Ft245Data.RcvCnt]=recv_char;
		Ft245Data.RcvCnt++;
	}

}
  80722c:	00005b06 	br	80739c <CmndSeq+0x1ac>

	if (recv_char=='(') {	//IR}hMJn
		Ft245Data.RcvCnt=0;
		Ft245Data.RecvSeq=CMND;
	}
	else if (recv_char==')') {
  807230:	e0bfff07 	ldb	r2,-4(fp)
  807234:	10800a58 	cmpnei	r2,r2,41
  807238:	10003f1e 	bne	r2,zero,807338 <CmndSeq+0x148>
		if (Ft245Data.RcvCnt==8){
  80723c:	008020f4 	movhi	r2,131
  807240:	10adc204 	addi	r2,r2,-18680
  807244:	10800417 	ldw	r2,16(r2)
  807248:	10800218 	cmpnei	r2,r2,8
  80724c:	1000351e 	bne	r2,zero,807324 <CmndSeq+0x134>
			Ft245Data.RecvSeq=COMPLETE;
  807250:	008020f4 	movhi	r2,131
  807254:	10adc204 	addi	r2,r2,-18680
  807258:	00c00084 	movi	r3,2
  80725c:	10c00615 	stw	r3,24(r2)
			CmdBuf.command		=Ft245Data.RecvBuf[0];
  807260:	008020f4 	movhi	r2,131
  807264:	10adc204 	addi	r2,r2,-18680
  807268:	10c00003 	ldbu	r3,0(r2)
  80726c:	008020f4 	movhi	r2,131
  807270:	10adc904 	addi	r2,r2,-18652
  807274:	10c00045 	stb	r3,1(r2)
			CmdBuf.sub_command	=Ft245Data.RecvBuf[1];
  807278:	008020f4 	movhi	r2,131
  80727c:	10adc204 	addi	r2,r2,-18680
  807280:	10c00043 	ldbu	r3,1(r2)
  807284:	008020f4 	movhi	r2,131
  807288:	10adc904 	addi	r2,r2,-18652
  80728c:	10c00085 	stb	r3,2(r2)
			CmdBuf.param[0]		=Ft245Data.RecvBuf[2];
  807290:	008020f4 	movhi	r2,131
  807294:	10adc204 	addi	r2,r2,-18680
  807298:	10c00083 	ldbu	r3,2(r2)
  80729c:	008020f4 	movhi	r2,131
  8072a0:	10adc904 	addi	r2,r2,-18652
  8072a4:	10c000c5 	stb	r3,3(r2)
			CmdBuf.param[1]		=Ft245Data.RecvBuf[3];
  8072a8:	008020f4 	movhi	r2,131
  8072ac:	10adc204 	addi	r2,r2,-18680
  8072b0:	10c000c3 	ldbu	r3,3(r2)
  8072b4:	008020f4 	movhi	r2,131
  8072b8:	10adc904 	addi	r2,r2,-18652
  8072bc:	10c00105 	stb	r3,4(r2)
			CmdBuf.param[2]		=Ft245Data.RecvBuf[4];
  8072c0:	008020f4 	movhi	r2,131
  8072c4:	10adc204 	addi	r2,r2,-18680
  8072c8:	10c00103 	ldbu	r3,4(r2)
  8072cc:	008020f4 	movhi	r2,131
  8072d0:	10adc904 	addi	r2,r2,-18652
  8072d4:	10c00145 	stb	r3,5(r2)
			CmdBuf.param[3]		=Ft245Data.RecvBuf[5];
  8072d8:	008020f4 	movhi	r2,131
  8072dc:	10adc204 	addi	r2,r2,-18680
  8072e0:	10c00143 	ldbu	r3,5(r2)
  8072e4:	008020f4 	movhi	r2,131
  8072e8:	10adc904 	addi	r2,r2,-18652
  8072ec:	10c00185 	stb	r3,6(r2)
			CmdBuf.param[4]		=Ft245Data.RecvBuf[6];
  8072f0:	008020f4 	movhi	r2,131
  8072f4:	10adc204 	addi	r2,r2,-18680
  8072f8:	10c00183 	ldbu	r3,6(r2)
  8072fc:	008020f4 	movhi	r2,131
  807300:	10adc904 	addi	r2,r2,-18652
  807304:	10c001c5 	stb	r3,7(r2)
			CmdBuf.param[5]		=Ft245Data.RecvBuf[7];
  807308:	008020f4 	movhi	r2,131
  80730c:	10adc204 	addi	r2,r2,-18680
  807310:	10c001c3 	ldbu	r3,7(r2)
  807314:	008020f4 	movhi	r2,131
  807318:	10adc904 	addi	r2,r2,-18652
  80731c:	10c00205 	stb	r3,8(r2)
	}else{
		Ft245Data.RecvBuf[Ft245Data.RcvCnt]=recv_char;
		Ft245Data.RcvCnt++;
	}

}
  807320:	00001e06 	br	80739c <CmndSeq+0x1ac>
			CmdBuf.param[3]		=Ft245Data.RecvBuf[5];
			CmdBuf.param[4]		=Ft245Data.RecvBuf[6];
			CmdBuf.param[5]		=Ft245Data.RecvBuf[7];
		}
		else{
			Ft245Data.RecvSeq=CMDERROR;
  807324:	008020f4 	movhi	r2,131
  807328:	10adc204 	addi	r2,r2,-18680
  80732c:	00c000c4 	movi	r3,3
  807330:	10c00615 	stw	r3,24(r2)
	}else{
		Ft245Data.RecvBuf[Ft245Data.RcvCnt]=recv_char;
		Ft245Data.RcvCnt++;
	}

}
  807334:	00001906 	br	80739c <CmndSeq+0x1ac>
			CmdBuf.param[5]		=Ft245Data.RecvBuf[7];
		}
		else{
			Ft245Data.RecvSeq=CMDERROR;
		}
	}else if (Ft245Data.RcvCnt>=8){
  807338:	008020f4 	movhi	r2,131
  80733c:	10adc204 	addi	r2,r2,-18680
  807340:	10800417 	ldw	r2,16(r2)
  807344:	10800210 	cmplti	r2,r2,8
  807348:	1000051e 	bne	r2,zero,807360 <CmndSeq+0x170>
		Ft245Data.RecvSeq=CMDERROR;
  80734c:	008020f4 	movhi	r2,131
  807350:	10adc204 	addi	r2,r2,-18680
  807354:	00c000c4 	movi	r3,3
  807358:	10c00615 	stw	r3,24(r2)
	}else{
		Ft245Data.RecvBuf[Ft245Data.RcvCnt]=recv_char;
		Ft245Data.RcvCnt++;
	}

}
  80735c:	00000f06 	br	80739c <CmndSeq+0x1ac>
			Ft245Data.RecvSeq=CMDERROR;
		}
	}else if (Ft245Data.RcvCnt>=8){
		Ft245Data.RecvSeq=CMDERROR;
	}else{
		Ft245Data.RecvBuf[Ft245Data.RcvCnt]=recv_char;
  807360:	008020f4 	movhi	r2,131
  807364:	10adc204 	addi	r2,r2,-18680
  807368:	10c00417 	ldw	r3,16(r2)
  80736c:	008020f4 	movhi	r2,131
  807370:	10adc204 	addi	r2,r2,-18680
  807374:	10c5883a 	add	r2,r2,r3
  807378:	e0ffff03 	ldbu	r3,-4(fp)
  80737c:	10c00005 	stb	r3,0(r2)
		Ft245Data.RcvCnt++;
  807380:	008020f4 	movhi	r2,131
  807384:	10adc204 	addi	r2,r2,-18680
  807388:	10800417 	ldw	r2,16(r2)
  80738c:	10c00044 	addi	r3,r2,1
  807390:	008020f4 	movhi	r2,131
  807394:	10adc204 	addi	r2,r2,-18680
  807398:	10c00415 	stw	r3,16(r2)
	}

}
  80739c:	0001883a 	nop
  8073a0:	e037883a 	mov	sp,fp
  8073a4:	df000017 	ldw	fp,0(sp)
  8073a8:	dec00104 	addi	sp,sp,4
  8073ac:	f800283a 	ret

008073b0 <HostStsChk>:


int HostStsChk(void)
{
  8073b0:	deffff04 	addi	sp,sp,-4
  8073b4:	df000015 	stw	fp,0(sp)
  8073b8:	d839883a 	mov	fp,sp
	if( Ft245Data.RecvSeq==COMPLETE	){
  8073bc:	008020f4 	movhi	r2,131
  8073c0:	10adc204 	addi	r2,r2,-18680
  8073c4:	10800617 	ldw	r2,24(r2)
  8073c8:	10800098 	cmpnei	r2,r2,2
  8073cc:	10000b1e 	bne	r2,zero,8073fc <HostStsChk+0x4c>
		//R}h
		Ft245Data.OverFlow=0;
  8073d0:	008020f4 	movhi	r2,131
  8073d4:	10adc204 	addi	r2,r2,-18680
  8073d8:	10000515 	stw	zero,20(r2)
		Ft245Data.RcvCnt=0;
  8073dc:	008020f4 	movhi	r2,131
  8073e0:	10adc204 	addi	r2,r2,-18680
  8073e4:	10000415 	stw	zero,16(r2)
		Ft245Data.RecvSeq=IDLE;
  8073e8:	008020f4 	movhi	r2,131
  8073ec:	10adc204 	addi	r2,r2,-18680
  8073f0:	10000615 	stw	zero,24(r2)
		return 1;
  8073f4:	00800044 	movi	r2,1
  8073f8:	00001806 	br	80745c <HostStsChk+0xac>
	}
	else if( Ft245Data.RecvSeq==CMDERROR	){
  8073fc:	008020f4 	movhi	r2,131
  807400:	10adc204 	addi	r2,r2,-18680
  807404:	10800617 	ldw	r2,24(r2)
  807408:	108000d8 	cmpnei	r2,r2,3
  80740c:	10000a1e 	bne	r2,zero,807438 <HostStsChk+0x88>
		Ft245Data.OverFlow=0;
  807410:	008020f4 	movhi	r2,131
  807414:	10adc204 	addi	r2,r2,-18680
  807418:	10000515 	stw	zero,20(r2)
		Ft245Data.RcvCnt=0;
  80741c:	008020f4 	movhi	r2,131
  807420:	10adc204 	addi	r2,r2,-18680
  807424:	10000415 	stw	zero,16(r2)
		Ft245Data.RecvSeq=IDLE;
  807428:	008020f4 	movhi	r2,131
  80742c:	10adc204 	addi	r2,r2,-18680
  807430:	10000615 	stw	zero,24(r2)
  807434:	00000806 	br	807458 <HostStsChk+0xa8>
		//MG[
	}
	else if( Ft245Data.RecvSeq==CMND	){
  807438:	008020f4 	movhi	r2,131
  80743c:	10adc204 	addi	r2,r2,-18680
  807440:	10800617 	ldw	r2,24(r2)
  807444:	10800060 	cmpeqi	r2,r2,1
  807448:	1000031e 	bne	r2,zero,807458 <HostStsChk+0xa8>
		//R}hM
	}
	else if( Ft245Data.RecvSeq==IDLE	){
  80744c:	008020f4 	movhi	r2,131
  807450:	10adc204 	addi	r2,r2,-18680
  807454:	10800617 	ldw	r2,24(r2)
	}
	return 0;
  807458:	0005883a 	mov	r2,zero
}
  80745c:	e037883a 	mov	sp,fp
  807460:	df000017 	ldw	fp,0(sp)
  807464:	dec00104 	addi	sp,sp,4
  807468:	f800283a 	ret

0080746c <CommandChk>:


int CommandChk(int *STS)
{
  80746c:	defff904 	addi	sp,sp,-28
  807470:	dfc00615 	stw	ra,24(sp)
  807474:	df000515 	stw	fp,20(sp)
  807478:	df000504 	addi	fp,sp,20
  80747c:	e13fff15 	stw	r4,-4(fp)
	volatile int CmfChkFlag,ParmChkFlag	;
	volatile int flag;
	uint8_t val;
	uint16_t	val16;

	CmfChkFlag =-1;
  807480:	00bfffc4 	movi	r2,-1
  807484:	e0bffb15 	stw	r2,-20(fp)
	ParmChkFlag=-2;
  807488:	00bfff84 	movi	r2,-2
  80748c:	e0bffc15 	stw	r2,-16(fp)
	//////////////
	//command check
	//////////////

	//STS=0 idle,STS!=0 Busy
	if (('I'==CmdBuf.command) &&('S'==CmdBuf.sub_command)){							//Initial sensor
  807490:	008020f4 	movhi	r2,131
  807494:	10adc904 	addi	r2,r2,-18652
  807498:	10800043 	ldbu	r2,1(r2)
  80749c:	10803fcc 	andi	r2,r2,255
  8074a0:	1080201c 	xori	r2,r2,128
  8074a4:	10bfe004 	addi	r2,r2,-128
  8074a8:	10801258 	cmpnei	r2,r2,73
  8074ac:	10000d1e 	bne	r2,zero,8074e4 <CommandChk+0x78>
  8074b0:	008020f4 	movhi	r2,131
  8074b4:	10adc904 	addi	r2,r2,-18652
  8074b8:	10800083 	ldbu	r2,2(r2)
  8074bc:	10803fcc 	andi	r2,r2,255
  8074c0:	1080201c 	xori	r2,r2,128
  8074c4:	10bfe004 	addi	r2,r2,-128
  8074c8:	108014d8 	cmpnei	r2,r2,83
  8074cc:	1000051e 	bne	r2,zero,8074e4 <CommandChk+0x78>
		CmfChkFlag=1;
  8074d0:	00800044 	movi	r2,1
  8074d4:	e0bffb15 	stw	r2,-20(fp)
		*STS=0;
  8074d8:	e0bfff17 	ldw	r2,-4(fp)
  8074dc:	10000015 	stw	zero,0(r2)
  8074e0:	00004106 	br	8075e8 <CommandChk+0x17c>
	}
	else if (('G'==CmdBuf.command) &&('W'==CmdBuf.sub_command) && (*STS==0)){		//get wave
  8074e4:	008020f4 	movhi	r2,131
  8074e8:	10adc904 	addi	r2,r2,-18652
  8074ec:	10800043 	ldbu	r2,1(r2)
  8074f0:	10803fcc 	andi	r2,r2,255
  8074f4:	1080201c 	xori	r2,r2,128
  8074f8:	10bfe004 	addi	r2,r2,-128
  8074fc:	108011d8 	cmpnei	r2,r2,71
  807500:	10000e1e 	bne	r2,zero,80753c <CommandChk+0xd0>
  807504:	008020f4 	movhi	r2,131
  807508:	10adc904 	addi	r2,r2,-18652
  80750c:	10800083 	ldbu	r2,2(r2)
  807510:	10803fcc 	andi	r2,r2,255
  807514:	1080201c 	xori	r2,r2,128
  807518:	10bfe004 	addi	r2,r2,-128
  80751c:	108015d8 	cmpnei	r2,r2,87
  807520:	1000061e 	bne	r2,zero,80753c <CommandChk+0xd0>
  807524:	e0bfff17 	ldw	r2,-4(fp)
  807528:	10800017 	ldw	r2,0(r2)
  80752c:	1000031e 	bne	r2,zero,80753c <CommandChk+0xd0>
		CmfChkFlag=1;
  807530:	00800044 	movi	r2,1
  807534:	e0bffb15 	stw	r2,-20(fp)
  807538:	00002b06 	br	8075e8 <CommandChk+0x17c>
	}
	else if (('S'==CmdBuf.command) &&('G'==CmdBuf.sub_command) && (*STS==0)){		//set gain
  80753c:	008020f4 	movhi	r2,131
  807540:	10adc904 	addi	r2,r2,-18652
  807544:	10800043 	ldbu	r2,1(r2)
  807548:	10803fcc 	andi	r2,r2,255
  80754c:	1080201c 	xori	r2,r2,128
  807550:	10bfe004 	addi	r2,r2,-128
  807554:	108014d8 	cmpnei	r2,r2,83
  807558:	10000e1e 	bne	r2,zero,807594 <CommandChk+0x128>
  80755c:	008020f4 	movhi	r2,131
  807560:	10adc904 	addi	r2,r2,-18652
  807564:	10800083 	ldbu	r2,2(r2)
  807568:	10803fcc 	andi	r2,r2,255
  80756c:	1080201c 	xori	r2,r2,128
  807570:	10bfe004 	addi	r2,r2,-128
  807574:	108011d8 	cmpnei	r2,r2,71
  807578:	1000061e 	bne	r2,zero,807594 <CommandChk+0x128>
  80757c:	e0bfff17 	ldw	r2,-4(fp)
  807580:	10800017 	ldw	r2,0(r2)
  807584:	1000031e 	bne	r2,zero,807594 <CommandChk+0x128>
		CmfChkFlag=1;
  807588:	00800044 	movi	r2,1
  80758c:	e0bffb15 	stw	r2,-20(fp)
  807590:	00001506 	br	8075e8 <CommandChk+0x17c>
	}
	else if (('S'==CmdBuf.command) &&('F'==CmdBuf.sub_command) && (*STS==0)){		//set Sample Frequency
  807594:	008020f4 	movhi	r2,131
  807598:	10adc904 	addi	r2,r2,-18652
  80759c:	10800043 	ldbu	r2,1(r2)
  8075a0:	10803fcc 	andi	r2,r2,255
  8075a4:	1080201c 	xori	r2,r2,128
  8075a8:	10bfe004 	addi	r2,r2,-128
  8075ac:	108014d8 	cmpnei	r2,r2,83
  8075b0:	10000d1e 	bne	r2,zero,8075e8 <CommandChk+0x17c>
  8075b4:	008020f4 	movhi	r2,131
  8075b8:	10adc904 	addi	r2,r2,-18652
  8075bc:	10800083 	ldbu	r2,2(r2)
  8075c0:	10803fcc 	andi	r2,r2,255
  8075c4:	1080201c 	xori	r2,r2,128
  8075c8:	10bfe004 	addi	r2,r2,-128
  8075cc:	10801198 	cmpnei	r2,r2,70
  8075d0:	1000051e 	bne	r2,zero,8075e8 <CommandChk+0x17c>
  8075d4:	e0bfff17 	ldw	r2,-4(fp)
  8075d8:	10800017 	ldw	r2,0(r2)
  8075dc:	1000021e 	bne	r2,zero,8075e8 <CommandChk+0x17c>
		CmfChkFlag=1;
  8075e0:	00800044 	movi	r2,1
  8075e4:	e0bffb15 	stw	r2,-20(fp)
	}

	if (1!=CmfChkFlag)	return CmfChkFlag;	//R}h`
  8075e8:	e0bffb17 	ldw	r2,-20(fp)
  8075ec:	10800060 	cmpeqi	r2,r2,1
  8075f0:	1000021e 	bne	r2,zero,8075fc <CommandChk+0x190>
  8075f4:	e0bffb17 	ldw	r2,-20(fp)
  8075f8:	00007b06 	br	8077e8 <CommandChk+0x37c>

	//////////////
	//parameter check
	//////////////
	if(('I'==CmdBuf.command)&&('S'==CmdBuf.sub_command))		//reset command
  8075fc:	008020f4 	movhi	r2,131
  807600:	10adc904 	addi	r2,r2,-18652
  807604:	10800043 	ldbu	r2,1(r2)
  807608:	10803fcc 	andi	r2,r2,255
  80760c:	1080201c 	xori	r2,r2,128
  807610:	10bfe004 	addi	r2,r2,-128
  807614:	10801258 	cmpnei	r2,r2,73
  807618:	10000c1e 	bne	r2,zero,80764c <CommandChk+0x1e0>
  80761c:	008020f4 	movhi	r2,131
  807620:	10adc904 	addi	r2,r2,-18652
  807624:	10800083 	ldbu	r2,2(r2)
  807628:	10803fcc 	andi	r2,r2,255
  80762c:	1080201c 	xori	r2,r2,128
  807630:	10bfe004 	addi	r2,r2,-128
  807634:	108014d8 	cmpnei	r2,r2,83
  807638:	1000041e 	bne	r2,zero,80764c <CommandChk+0x1e0>
	{
		//not need parameter
		//ignore parameter
		ParmChkFlag=1;
  80763c:	00800044 	movi	r2,1
  807640:	e0bffc15 	stw	r2,-16(fp)
		return 0;
  807644:	0005883a 	mov	r2,zero
  807648:	00006706 	br	8077e8 <CommandChk+0x37c>
	}
	else if(('G'==CmdBuf.command)&&('W'==CmdBuf.sub_command))		//GetWave command
  80764c:	008020f4 	movhi	r2,131
  807650:	10adc904 	addi	r2,r2,-18652
  807654:	10800043 	ldbu	r2,1(r2)
  807658:	10803fcc 	andi	r2,r2,255
  80765c:	1080201c 	xori	r2,r2,128
  807660:	10bfe004 	addi	r2,r2,-128
  807664:	108011d8 	cmpnei	r2,r2,71
  807668:	1000161e 	bne	r2,zero,8076c4 <CommandChk+0x258>
  80766c:	008020f4 	movhi	r2,131
  807670:	10adc904 	addi	r2,r2,-18652
  807674:	10800083 	ldbu	r2,2(r2)
  807678:	10803fcc 	andi	r2,r2,255
  80767c:	1080201c 	xori	r2,r2,128
  807680:	10bfe004 	addi	r2,r2,-128
  807684:	108015d8 	cmpnei	r2,r2,87
  807688:	10000e1e 	bne	r2,zero,8076c4 <CommandChk+0x258>
	{
		//"ab0000"	abubN@1bock=4kbyte=2k sample = 64ms@32kHz,128ms@16kHz
		flag=AsciiHex2char( (char *)&CmdBuf.param[0],(char *)&val);
  80768c:	e0bffe04 	addi	r2,fp,-8
  807690:	100b883a 	mov	r5,r2
  807694:	010020f4 	movhi	r4,131
  807698:	212dc9c4 	addi	r4,r4,-18649
  80769c:	0806f640 	call	806f64 <AsciiHex2char>
  8076a0:	e0bffd15 	stw	r2,-12(fp)
		if (flag!=0)				return ParmChkFlag;
  8076a4:	e0bffd17 	ldw	r2,-12(fp)
  8076a8:	10000226 	beq	r2,zero,8076b4 <CommandChk+0x248>
  8076ac:	e0bffc17 	ldw	r2,-16(fp)
  8076b0:	00004d06 	br	8077e8 <CommandChk+0x37c>

		ParmChkFlag=1;
  8076b4:	00800044 	movi	r2,1
  8076b8:	e0bffc15 	stw	r2,-16(fp)
		return 0;
  8076bc:	0005883a 	mov	r2,zero
  8076c0:	00004906 	br	8077e8 <CommandChk+0x37c>
	}
	else if(('S'==CmdBuf.command)&&('G'==CmdBuf.sub_command))		//GetWave command
  8076c4:	008020f4 	movhi	r2,131
  8076c8:	10adc904 	addi	r2,r2,-18652
  8076cc:	10800043 	ldbu	r2,1(r2)
  8076d0:	10803fcc 	andi	r2,r2,255
  8076d4:	1080201c 	xori	r2,r2,128
  8076d8:	10bfe004 	addi	r2,r2,-128
  8076dc:	108014d8 	cmpnei	r2,r2,83
  8076e0:	10001c1e 	bne	r2,zero,807754 <CommandChk+0x2e8>
  8076e4:	008020f4 	movhi	r2,131
  8076e8:	10adc904 	addi	r2,r2,-18652
  8076ec:	10800083 	ldbu	r2,2(r2)
  8076f0:	10803fcc 	andi	r2,r2,255
  8076f4:	1080201c 	xori	r2,r2,128
  8076f8:	10bfe004 	addi	r2,r2,-128
  8076fc:	108011d8 	cmpnei	r2,r2,71
  807700:	1000141e 	bne	r2,zero,807754 <CommandChk+0x2e8>
	{
		//"ab0000"	abQC@1L 00,01,02, .. 07
		flag=AsciiHex2char( (char *)&CmdBuf.param[0],(char *)&val);
  807704:	e0bffe04 	addi	r2,fp,-8
  807708:	100b883a 	mov	r5,r2
  80770c:	010020f4 	movhi	r4,131
  807710:	212dc9c4 	addi	r4,r4,-18649
  807714:	0806f640 	call	806f64 <AsciiHex2char>
  807718:	e0bffd15 	stw	r2,-12(fp)
		if (flag!=0)				return ParmChkFlag;
  80771c:	e0bffd17 	ldw	r2,-12(fp)
  807720:	10000226 	beq	r2,zero,80772c <CommandChk+0x2c0>
  807724:	e0bffc17 	ldw	r2,-16(fp)
  807728:	00002f06 	br	8077e8 <CommandChk+0x37c>
		if((val<0) || (val>0x7))	return ParmChkFlag;
  80772c:	e0bffe03 	ldbu	r2,-8(fp)
  807730:	10803fcc 	andi	r2,r2,255
  807734:	10800230 	cmpltui	r2,r2,8
  807738:	1000021e 	bne	r2,zero,807744 <CommandChk+0x2d8>
  80773c:	e0bffc17 	ldw	r2,-16(fp)
  807740:	00002906 	br	8077e8 <CommandChk+0x37c>

		ParmChkFlag=1;
  807744:	00800044 	movi	r2,1
  807748:	e0bffc15 	stw	r2,-16(fp)
		return 0;
  80774c:	0005883a 	mov	r2,zero
  807750:	00002506 	br	8077e8 <CommandChk+0x37c>
	}
	else if(('S'==CmdBuf.command)&&('F'==CmdBuf.sub_command))		//GetWave command
  807754:	008020f4 	movhi	r2,131
  807758:	10adc904 	addi	r2,r2,-18652
  80775c:	10800043 	ldbu	r2,1(r2)
  807760:	10803fcc 	andi	r2,r2,255
  807764:	1080201c 	xori	r2,r2,128
  807768:	10bfe004 	addi	r2,r2,-128
  80776c:	108014d8 	cmpnei	r2,r2,83
  807770:	10001c1e 	bne	r2,zero,8077e4 <CommandChk+0x378>
  807774:	008020f4 	movhi	r2,131
  807778:	10adc904 	addi	r2,r2,-18652
  80777c:	10800083 	ldbu	r2,2(r2)
  807780:	10803fcc 	andi	r2,r2,255
  807784:	1080201c 	xori	r2,r2,128
  807788:	10bfe004 	addi	r2,r2,-128
  80778c:	10801198 	cmpnei	r2,r2,70
  807790:	1000141e 	bne	r2,zero,8077e4 <CommandChk+0x378>
	{
		//"ab0000"	abTvg@00:32kHz@01:16kHz
		flag=AsciiHex2char( (char *)&CmdBuf.param[0],(char *)&val);
  807794:	e0bffe04 	addi	r2,fp,-8
  807798:	100b883a 	mov	r5,r2
  80779c:	010020f4 	movhi	r4,131
  8077a0:	212dc9c4 	addi	r4,r4,-18649
  8077a4:	0806f640 	call	806f64 <AsciiHex2char>
  8077a8:	e0bffd15 	stw	r2,-12(fp)
		if (flag!=0)				return ParmChkFlag;
  8077ac:	e0bffd17 	ldw	r2,-12(fp)
  8077b0:	10000226 	beq	r2,zero,8077bc <CommandChk+0x350>
  8077b4:	e0bffc17 	ldw	r2,-16(fp)
  8077b8:	00000b06 	br	8077e8 <CommandChk+0x37c>
		if((val<0) || (val>1))	return ParmChkFlag;
  8077bc:	e0bffe03 	ldbu	r2,-8(fp)
  8077c0:	10803fcc 	andi	r2,r2,255
  8077c4:	108000b0 	cmpltui	r2,r2,2
  8077c8:	1000021e 	bne	r2,zero,8077d4 <CommandChk+0x368>
  8077cc:	e0bffc17 	ldw	r2,-16(fp)
  8077d0:	00000506 	br	8077e8 <CommandChk+0x37c>

		ParmChkFlag=1;
  8077d4:	00800044 	movi	r2,1
  8077d8:	e0bffc15 	stw	r2,-16(fp)
		return 0;
  8077dc:	0005883a 	mov	r2,zero
  8077e0:	00000106 	br	8077e8 <CommandChk+0x37c>
	}

	return 0;//
  8077e4:	0005883a 	mov	r2,zero
#endif
}
  8077e8:	e037883a 	mov	sp,fp
  8077ec:	dfc00117 	ldw	ra,4(sp)
  8077f0:	df000017 	ldw	fp,0(sp)
  8077f4:	dec00204 	addi	sp,sp,8
  8077f8:	f800283a 	ret

008077fc <Execute>:

void Execute(void)
{
  8077fc:	defffa04 	addi	sp,sp,-24
  807800:	dfc00515 	stw	ra,20(sp)
  807804:	df000415 	stw	fp,16(sp)
  807808:	df000404 	addi	fp,sp,16
	uint16_t val;
	uint8_t val8;
	//////////////
	//execute command
	//////////////
	if(('I'==CmdBuf.command)&&('S'==CmdBuf.sub_command))		//reset command
  80780c:	008020f4 	movhi	r2,131
  807810:	10adc904 	addi	r2,r2,-18652
  807814:	10800043 	ldbu	r2,1(r2)
  807818:	10803fcc 	andi	r2,r2,255
  80781c:	1080201c 	xori	r2,r2,128
  807820:	10bfe004 	addi	r2,r2,-128
  807824:	10801258 	cmpnei	r2,r2,73
  807828:	10004c1e 	bne	r2,zero,80795c <Execute+0x160>
  80782c:	008020f4 	movhi	r2,131
  807830:	10adc904 	addi	r2,r2,-18652
  807834:	10800083 	ldbu	r2,2(r2)
  807838:	10803fcc 	andi	r2,r2,255
  80783c:	1080201c 	xori	r2,r2,128
  807840:	10bfe004 	addi	r2,r2,-128
  807844:	108014d8 	cmpnei	r2,r2,83
  807848:	1000441e 	bne	r2,zero,80795c <Execute+0x160>
	{
		RspBuf.command='I';
  80784c:	008020f4 	movhi	r2,131
  807850:	10adcb84 	addi	r2,r2,-18642
  807854:	00c01244 	movi	r3,73
  807858:	10c00045 	stb	r3,1(r2)
		RspBuf.sub_command='S';
  80785c:	008020f4 	movhi	r2,131
  807860:	10adcb84 	addi	r2,r2,-18642
  807864:	00c014c4 	movi	r3,83
  807868:	10c00085 	stb	r3,2(r2)
		RspBuf.param[0]='0';
  80786c:	008020f4 	movhi	r2,131
  807870:	10adcb84 	addi	r2,r2,-18642
  807874:	00c00c04 	movi	r3,48
  807878:	10c000c5 	stb	r3,3(r2)
		RspBuf.param[1]='0';
  80787c:	008020f4 	movhi	r2,131
  807880:	10adcb84 	addi	r2,r2,-18642
  807884:	00c00c04 	movi	r3,48
  807888:	10c00105 	stb	r3,4(r2)
		RspBuf.param[2]='0';
  80788c:	008020f4 	movhi	r2,131
  807890:	10adcb84 	addi	r2,r2,-18642
  807894:	00c00c04 	movi	r3,48
  807898:	10c00145 	stb	r3,5(r2)
		RspBuf.param[3]='0';
  80789c:	008020f4 	movhi	r2,131
  8078a0:	10adcb84 	addi	r2,r2,-18642
  8078a4:	00c00c04 	movi	r3,48
  8078a8:	10c00185 	stb	r3,6(r2)
		RspBuf.param[4]='0';
  8078ac:	008020f4 	movhi	r2,131
  8078b0:	10adcb84 	addi	r2,r2,-18642
  8078b4:	00c00c04 	movi	r3,48
  8078b8:	10c001c5 	stb	r3,7(r2)
		RspBuf.param[5]='0';
  8078bc:	008020f4 	movhi	r2,131
  8078c0:	10adcb84 	addi	r2,r2,-18642
  8078c4:	00c00c04 	movi	r3,48
  8078c8:	10c00205 	stb	r3,8(r2)

		QueSns=SnsQue_INIT;
  8078cc:	e03ffd15 	stw	zero,-12(fp)

		xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
  8078d0:	d0a03517 	ldw	r2,-32556(gp)
  8078d4:	e0fffd04 	addi	r3,fp,-12
  8078d8:	000f883a 	mov	r7,zero
  8078dc:	01bfffc4 	movi	r6,-1
  8078e0:	180b883a 	mov	r5,r3
  8078e4:	1009883a 	mov	r4,r2
  8078e8:	08011780 	call	801178 <xQueueGenericSend>
		vTaskDelay( 100/ portTICK_PERIOD_MS);
  8078ec:	01001904 	movi	r4,100
  8078f0:	08023680 	call	802368 <vTaskDelay>
		while(SnsCtrlSTS == SnsSTS_BUSY){
  8078f4:	00000206 	br	807900 <Execute+0x104>
			vTaskDelay( 1/ portTICK_PERIOD_MS);
  8078f8:	01000044 	movi	r4,1
  8078fc:	08023680 	call	802368 <vTaskDelay>

		QueSns=SnsQue_INIT;

		xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
		vTaskDelay( 100/ portTICK_PERIOD_MS);
		while(SnsCtrlSTS == SnsSTS_BUSY){
  807900:	d0a03c17 	ldw	r2,-32528(gp)
  807904:	10800060 	cmpeqi	r2,r2,1
  807908:	103ffb1e 	bne	r2,zero,8078f8 <__alt_data_end+0xfff078f8>
			vTaskDelay( 1/ portTICK_PERIOD_MS);
		}
		if(SnsCtrlSTS == SnsSTS_ERROR){
  80790c:	d0a03c17 	ldw	r2,-32528(gp)
  807910:	10800098 	cmpnei	r2,r2,2
  807914:	10000c1e 	bne	r2,zero,807948 <Execute+0x14c>
			RspBuf.param[0]='E';
  807918:	008020f4 	movhi	r2,131
  80791c:	10adcb84 	addi	r2,r2,-18642
  807920:	00c01144 	movi	r3,69
  807924:	10c000c5 	stb	r3,3(r2)
			RspBuf.param[1]='R';
  807928:	008020f4 	movhi	r2,131
  80792c:	10adcb84 	addi	r2,r2,-18642
  807930:	00c01484 	movi	r3,82
  807934:	10c00105 	stb	r3,4(r2)
			RspBuf.param[2]='R';
  807938:	008020f4 	movhi	r2,131
  80793c:	10adcb84 	addi	r2,r2,-18642
  807940:	00c01484 	movi	r3,82
  807944:	10c00145 	stb	r3,5(r2)
		}

		FT245_SendBlock((char *)&RspBuf,10);
  807948:	01400284 	movi	r5,10
  80794c:	010020f4 	movhi	r4,131
  807950:	212dcb84 	addi	r4,r4,-18642
  807954:	0805b580 	call	805b58 <FT245_SendBlock>
  807958:	00014306 	br	807e68 <Execute+0x66c>
	}
	else if(('G'==CmdBuf.command)&&('W'==CmdBuf.sub_command))		//read register command
  80795c:	008020f4 	movhi	r2,131
  807960:	10adc904 	addi	r2,r2,-18652
  807964:	10800043 	ldbu	r2,1(r2)
  807968:	10803fcc 	andi	r2,r2,255
  80796c:	1080201c 	xori	r2,r2,128
  807970:	10bfe004 	addi	r2,r2,-128
  807974:	108011d8 	cmpnei	r2,r2,71
  807978:	10006b1e 	bne	r2,zero,807b28 <Execute+0x32c>
  80797c:	008020f4 	movhi	r2,131
  807980:	10adc904 	addi	r2,r2,-18652
  807984:	10800083 	ldbu	r2,2(r2)
  807988:	10803fcc 	andi	r2,r2,255
  80798c:	1080201c 	xori	r2,r2,128
  807990:	10bfe004 	addi	r2,r2,-128
  807994:	108015d8 	cmpnei	r2,r2,87
  807998:	1000631e 	bne	r2,zero,807b28 <Execute+0x32c>
	{

		RspBuf.command='G';
  80799c:	008020f4 	movhi	r2,131
  8079a0:	10adcb84 	addi	r2,r2,-18642
  8079a4:	00c011c4 	movi	r3,71
  8079a8:	10c00045 	stb	r3,1(r2)
		RspBuf.sub_command='W';
  8079ac:	008020f4 	movhi	r2,131
  8079b0:	10adcb84 	addi	r2,r2,-18642
  8079b4:	00c015c4 	movi	r3,87
  8079b8:	10c00085 	stb	r3,2(r2)
		RspBuf.param[0]='0';
  8079bc:	008020f4 	movhi	r2,131
  8079c0:	10adcb84 	addi	r2,r2,-18642
  8079c4:	00c00c04 	movi	r3,48
  8079c8:	10c000c5 	stb	r3,3(r2)
		RspBuf.param[1]='0';
  8079cc:	008020f4 	movhi	r2,131
  8079d0:	10adcb84 	addi	r2,r2,-18642
  8079d4:	00c00c04 	movi	r3,48
  8079d8:	10c00105 	stb	r3,4(r2)
		RspBuf.param[2]='0';
  8079dc:	008020f4 	movhi	r2,131
  8079e0:	10adcb84 	addi	r2,r2,-18642
  8079e4:	00c00c04 	movi	r3,48
  8079e8:	10c00145 	stb	r3,5(r2)
		RspBuf.param[3]='0';
  8079ec:	008020f4 	movhi	r2,131
  8079f0:	10adcb84 	addi	r2,r2,-18642
  8079f4:	00c00c04 	movi	r3,48
  8079f8:	10c00185 	stb	r3,6(r2)
		RspBuf.param[4]='0';
  8079fc:	008020f4 	movhi	r2,131
  807a00:	10adcb84 	addi	r2,r2,-18642
  807a04:	00c00c04 	movi	r3,48
  807a08:	10c001c5 	stb	r3,7(r2)
		RspBuf.param[5]='0';
  807a0c:	008020f4 	movhi	r2,131
  807a10:	10adcb84 	addi	r2,r2,-18642
  807a14:	00c00c04 	movi	r3,48
  807a18:	10c00205 	stb	r3,8(r2)

		flag	= 	AsciiHex2uint16(&CmdBuf.param[0],&val);	//ubN
  807a1c:	e0bfff04 	addi	r2,fp,-4
  807a20:	100b883a 	mov	r5,r2
  807a24:	010020f4 	movhi	r4,131
  807a28:	212dc9c4 	addi	r4,r4,-18649
  807a2c:	0806d740 	call	806d74 <AsciiHex2uint16>
  807a30:	e0bffc15 	stw	r2,-16(fp)
		if (flag != 0){
  807a34:	e0bffc17 	ldw	r2,-16(fp)
  807a38:	10001526 	beq	r2,zero,807a90 <Execute+0x294>
			RspBuf.command='G';
  807a3c:	008020f4 	movhi	r2,131
  807a40:	10adcb84 	addi	r2,r2,-18642
  807a44:	00c011c4 	movi	r3,71
  807a48:	10c00045 	stb	r3,1(r2)
			RspBuf.sub_command='W';
  807a4c:	008020f4 	movhi	r2,131
  807a50:	10adcb84 	addi	r2,r2,-18642
  807a54:	00c015c4 	movi	r3,87
  807a58:	10c00085 	stb	r3,2(r2)
			RspBuf.param[0]='p';
  807a5c:	008020f4 	movhi	r2,131
  807a60:	10adcb84 	addi	r2,r2,-18642
  807a64:	00c01c04 	movi	r3,112
  807a68:	10c000c5 	stb	r3,3(r2)
			RspBuf.param[1]='e';
  807a6c:	008020f4 	movhi	r2,131
  807a70:	10adcb84 	addi	r2,r2,-18642
  807a74:	00c01944 	movi	r3,101
  807a78:	10c00105 	stb	r3,4(r2)
			FT245_SendBlock((char *)&RspBuf,10);
  807a7c:	01400284 	movi	r5,10
  807a80:	010020f4 	movhi	r4,131
  807a84:	212dcb84 	addi	r4,r4,-18642
  807a88:	0805b580 	call	805b58 <FT245_SendBlock>
			return;
  807a8c:	0000f606 	br	807e68 <Execute+0x66c>
		}
		else{
			QueCOM = val;
  807a90:	e0bfff0b 	ldhu	r2,-4(fp)
  807a94:	10bfffcc 	andi	r2,r2,65535
  807a98:	e0bffe15 	stw	r2,-8(fp)
			xQueueSendToBack(SendReqQue,&QueCOM,portMAX_DELAY);
  807a9c:	d0a03617 	ldw	r2,-32552(gp)
  807aa0:	e0fffe04 	addi	r3,fp,-8
  807aa4:	000f883a 	mov	r7,zero
  807aa8:	01bfffc4 	movi	r6,-1
  807aac:	180b883a 	mov	r5,r3
  807ab0:	1009883a 	mov	r4,r2
  807ab4:	08011780 	call	801178 <xQueueGenericSend>

//			QueSns=SnsQue_START;
//			xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
		}

		vTaskDelay( 100/ portTICK_PERIOD_MS);
  807ab8:	01001904 	movi	r4,100
  807abc:	08023680 	call	802368 <vTaskDelay>
		while(SnsCtrlSTS == SnsSTS_BUSY){
  807ac0:	00000206 	br	807acc <Execute+0x2d0>
			vTaskDelay( 1/ portTICK_PERIOD_MS);
  807ac4:	01000044 	movi	r4,1
  807ac8:	08023680 	call	802368 <vTaskDelay>
//			QueSns=SnsQue_START;
//			xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
		}

		vTaskDelay( 100/ portTICK_PERIOD_MS);
		while(SnsCtrlSTS == SnsSTS_BUSY){
  807acc:	d0a03c17 	ldw	r2,-32528(gp)
  807ad0:	10800060 	cmpeqi	r2,r2,1
  807ad4:	103ffb1e 	bne	r2,zero,807ac4 <__alt_data_end+0xfff07ac4>
			vTaskDelay( 1/ portTICK_PERIOD_MS);
		}
		if(SnsCtrlSTS == SnsSTS_ERROR){
  807ad8:	d0a03c17 	ldw	r2,-32528(gp)
  807adc:	10800098 	cmpnei	r2,r2,2
  807ae0:	10000c1e 	bne	r2,zero,807b14 <Execute+0x318>
			RspBuf.param[0]='E';
  807ae4:	008020f4 	movhi	r2,131
  807ae8:	10adcb84 	addi	r2,r2,-18642
  807aec:	00c01144 	movi	r3,69
  807af0:	10c000c5 	stb	r3,3(r2)
			RspBuf.param[1]='R';
  807af4:	008020f4 	movhi	r2,131
  807af8:	10adcb84 	addi	r2,r2,-18642
  807afc:	00c01484 	movi	r3,82
  807b00:	10c00105 	stb	r3,4(r2)
			RspBuf.param[2]='R';
  807b04:	008020f4 	movhi	r2,131
  807b08:	10adcb84 	addi	r2,r2,-18642
  807b0c:	00c01484 	movi	r3,82
  807b10:	10c00145 	stb	r3,5(r2)
		}

		FT245_SendBlock((char *)&RspBuf,10);
  807b14:	01400284 	movi	r5,10
  807b18:	010020f4 	movhi	r4,131
  807b1c:	212dcb84 	addi	r4,r4,-18642
  807b20:	0805b580 	call	805b58 <FT245_SendBlock>
  807b24:	0000d006 	br	807e68 <Execute+0x66c>

	}
	else if(('S'==CmdBuf.command)&&('G'==CmdBuf.sub_command))		//read register command
  807b28:	008020f4 	movhi	r2,131
  807b2c:	10adc904 	addi	r2,r2,-18652
  807b30:	10800043 	ldbu	r2,1(r2)
  807b34:	10803fcc 	andi	r2,r2,255
  807b38:	1080201c 	xori	r2,r2,128
  807b3c:	10bfe004 	addi	r2,r2,-128
  807b40:	108014d8 	cmpnei	r2,r2,83
  807b44:	10006b1e 	bne	r2,zero,807cf4 <Execute+0x4f8>
  807b48:	008020f4 	movhi	r2,131
  807b4c:	10adc904 	addi	r2,r2,-18652
  807b50:	10800083 	ldbu	r2,2(r2)
  807b54:	10803fcc 	andi	r2,r2,255
  807b58:	1080201c 	xori	r2,r2,128
  807b5c:	10bfe004 	addi	r2,r2,-128
  807b60:	108011d8 	cmpnei	r2,r2,71
  807b64:	1000631e 	bne	r2,zero,807cf4 <Execute+0x4f8>
	{

		RspBuf.command='S';
  807b68:	008020f4 	movhi	r2,131
  807b6c:	10adcb84 	addi	r2,r2,-18642
  807b70:	00c014c4 	movi	r3,83
  807b74:	10c00045 	stb	r3,1(r2)
		RspBuf.sub_command='G';
  807b78:	008020f4 	movhi	r2,131
  807b7c:	10adcb84 	addi	r2,r2,-18642
  807b80:	00c011c4 	movi	r3,71
  807b84:	10c00085 	stb	r3,2(r2)
		RspBuf.param[0]='0';
  807b88:	008020f4 	movhi	r2,131
  807b8c:	10adcb84 	addi	r2,r2,-18642
  807b90:	00c00c04 	movi	r3,48
  807b94:	10c000c5 	stb	r3,3(r2)
		RspBuf.param[1]='0';
  807b98:	008020f4 	movhi	r2,131
  807b9c:	10adcb84 	addi	r2,r2,-18642
  807ba0:	00c00c04 	movi	r3,48
  807ba4:	10c00105 	stb	r3,4(r2)
		RspBuf.param[2]='0';
  807ba8:	008020f4 	movhi	r2,131
  807bac:	10adcb84 	addi	r2,r2,-18642
  807bb0:	00c00c04 	movi	r3,48
  807bb4:	10c00145 	stb	r3,5(r2)
		RspBuf.param[3]='0';
  807bb8:	008020f4 	movhi	r2,131
  807bbc:	10adcb84 	addi	r2,r2,-18642
  807bc0:	00c00c04 	movi	r3,48
  807bc4:	10c00185 	stb	r3,6(r2)
		RspBuf.param[4]='0';
  807bc8:	008020f4 	movhi	r2,131
  807bcc:	10adcb84 	addi	r2,r2,-18642
  807bd0:	00c00c04 	movi	r3,48
  807bd4:	10c001c5 	stb	r3,7(r2)
		RspBuf.param[5]='0';
  807bd8:	008020f4 	movhi	r2,131
  807bdc:	10adcb84 	addi	r2,r2,-18642
  807be0:	00c00c04 	movi	r3,48
  807be4:	10c00205 	stb	r3,8(r2)

		flag	= 	AsciiHex2char(&CmdBuf.param[0],&val8);	//gain
  807be8:	e0bfff84 	addi	r2,fp,-2
  807bec:	100b883a 	mov	r5,r2
  807bf0:	010020f4 	movhi	r4,131
  807bf4:	212dc9c4 	addi	r4,r4,-18649
  807bf8:	0806f640 	call	806f64 <AsciiHex2char>
  807bfc:	e0bffc15 	stw	r2,-16(fp)
		if ((flag != 0) || val8>7){
  807c00:	e0bffc17 	ldw	r2,-16(fp)
  807c04:	1000041e 	bne	r2,zero,807c18 <Execute+0x41c>
  807c08:	e0bfff83 	ldbu	r2,-2(fp)
  807c0c:	10803fcc 	andi	r2,r2,255
  807c10:	10800230 	cmpltui	r2,r2,8
  807c14:	1000151e 	bne	r2,zero,807c6c <Execute+0x470>
			RspBuf.command='G';
  807c18:	008020f4 	movhi	r2,131
  807c1c:	10adcb84 	addi	r2,r2,-18642
  807c20:	00c011c4 	movi	r3,71
  807c24:	10c00045 	stb	r3,1(r2)
			RspBuf.sub_command='W';
  807c28:	008020f4 	movhi	r2,131
  807c2c:	10adcb84 	addi	r2,r2,-18642
  807c30:	00c015c4 	movi	r3,87
  807c34:	10c00085 	stb	r3,2(r2)
			RspBuf.param[0]='p';
  807c38:	008020f4 	movhi	r2,131
  807c3c:	10adcb84 	addi	r2,r2,-18642
  807c40:	00c01c04 	movi	r3,112
  807c44:	10c000c5 	stb	r3,3(r2)
			RspBuf.param[1]='e';
  807c48:	008020f4 	movhi	r2,131
  807c4c:	10adcb84 	addi	r2,r2,-18642
  807c50:	00c01944 	movi	r3,101
  807c54:	10c00105 	stb	r3,4(r2)
			FT245_SendBlock((char *)&RspBuf,10);
  807c58:	01400284 	movi	r5,10
  807c5c:	010020f4 	movhi	r4,131
  807c60:	212dcb84 	addi	r4,r4,-18642
  807c64:	0805b580 	call	805b58 <FT245_SendBlock>
			return;
  807c68:	00007f06 	br	807e68 <Execute+0x66c>
		}
		else{
			setMicGain(val8);	//default
  807c6c:	e0bfff83 	ldbu	r2,-2(fp)
  807c70:	10803fcc 	andi	r2,r2,255
  807c74:	1009883a 	mov	r4,r2
  807c78:	08085840 	call	808584 <setMicGain>
			flag = MicCarivration();
  807c7c:	08081d00 	call	8081d0 <MicCarivration>
  807c80:	e0bffc15 	stw	r2,-16(fp)
			if(0!=flag){
  807c84:	e0bffc17 	ldw	r2,-16(fp)
  807c88:	10001126 	beq	r2,zero,807cd0 <Execute+0x4d4>
				RspBuf.param[0]='E';
  807c8c:	008020f4 	movhi	r2,131
  807c90:	10adcb84 	addi	r2,r2,-18642
  807c94:	00c01144 	movi	r3,69
  807c98:	10c000c5 	stb	r3,3(r2)
				RspBuf.param[1]='R';
  807c9c:	008020f4 	movhi	r2,131
  807ca0:	10adcb84 	addi	r2,r2,-18642
  807ca4:	00c01484 	movi	r3,82
  807ca8:	10c00105 	stb	r3,4(r2)
				RspBuf.param[2]='R';
  807cac:	008020f4 	movhi	r2,131
  807cb0:	10adcb84 	addi	r2,r2,-18642
  807cb4:	00c01484 	movi	r3,82
  807cb8:	10c00145 	stb	r3,5(r2)
debug_print(RGB565_RED,"Gain Set Error");
  807cbc:	014020b4 	movhi	r5,130
  807cc0:	2966b604 	addi	r5,r5,-25896
  807cc4:	013e0014 	movui	r4,63488
  807cc8:	0806cb80 	call	806cb8 <debug_print>
  807ccc:	00000406 	br	807ce0 <Execute+0x4e4>
			}
			else{
debug_print(RGB565_GREEN,"Gain Set Successfully");
  807cd0:	014020b4 	movhi	r5,130
  807cd4:	2966ba04 	addi	r5,r5,-25880
  807cd8:	0101f804 	movi	r4,2016
  807cdc:	0806cb80 	call	806cb8 <debug_print>

			}

		}
		FT245_SendBlock((char *)&RspBuf,10);
  807ce0:	01400284 	movi	r5,10
  807ce4:	010020f4 	movhi	r4,131
  807ce8:	212dcb84 	addi	r4,r4,-18642
  807cec:	0805b580 	call	805b58 <FT245_SendBlock>
  807cf0:	00005d06 	br	807e68 <Execute+0x66c>

	}
	else if(('S'==CmdBuf.command)&&('F'==CmdBuf.sub_command))		//read register command
  807cf4:	008020f4 	movhi	r2,131
  807cf8:	10adc904 	addi	r2,r2,-18652
  807cfc:	10800043 	ldbu	r2,1(r2)
  807d00:	10803fcc 	andi	r2,r2,255
  807d04:	1080201c 	xori	r2,r2,128
  807d08:	10bfe004 	addi	r2,r2,-128
  807d0c:	108014d8 	cmpnei	r2,r2,83
  807d10:	1000551e 	bne	r2,zero,807e68 <Execute+0x66c>
  807d14:	008020f4 	movhi	r2,131
  807d18:	10adc904 	addi	r2,r2,-18652
  807d1c:	10800083 	ldbu	r2,2(r2)
  807d20:	10803fcc 	andi	r2,r2,255
  807d24:	1080201c 	xori	r2,r2,128
  807d28:	10bfe004 	addi	r2,r2,-128
  807d2c:	10801198 	cmpnei	r2,r2,70
  807d30:	10004d1e 	bne	r2,zero,807e68 <Execute+0x66c>
	{

		RspBuf.command='S';
  807d34:	008020f4 	movhi	r2,131
  807d38:	10adcb84 	addi	r2,r2,-18642
  807d3c:	00c014c4 	movi	r3,83
  807d40:	10c00045 	stb	r3,1(r2)
		RspBuf.sub_command='F';
  807d44:	008020f4 	movhi	r2,131
  807d48:	10adcb84 	addi	r2,r2,-18642
  807d4c:	00c01184 	movi	r3,70
  807d50:	10c00085 	stb	r3,2(r2)
		RspBuf.param[0]='0';
  807d54:	008020f4 	movhi	r2,131
  807d58:	10adcb84 	addi	r2,r2,-18642
  807d5c:	00c00c04 	movi	r3,48
  807d60:	10c000c5 	stb	r3,3(r2)
		RspBuf.param[1]='0';
  807d64:	008020f4 	movhi	r2,131
  807d68:	10adcb84 	addi	r2,r2,-18642
  807d6c:	00c00c04 	movi	r3,48
  807d70:	10c00105 	stb	r3,4(r2)
		RspBuf.param[2]='0';
  807d74:	008020f4 	movhi	r2,131
  807d78:	10adcb84 	addi	r2,r2,-18642
  807d7c:	00c00c04 	movi	r3,48
  807d80:	10c00145 	stb	r3,5(r2)
		RspBuf.param[3]='0';
  807d84:	008020f4 	movhi	r2,131
  807d88:	10adcb84 	addi	r2,r2,-18642
  807d8c:	00c00c04 	movi	r3,48
  807d90:	10c00185 	stb	r3,6(r2)
		RspBuf.param[4]='0';
  807d94:	008020f4 	movhi	r2,131
  807d98:	10adcb84 	addi	r2,r2,-18642
  807d9c:	00c00c04 	movi	r3,48
  807da0:	10c001c5 	stb	r3,7(r2)
		RspBuf.param[5]='0';
  807da4:	008020f4 	movhi	r2,131
  807da8:	10adcb84 	addi	r2,r2,-18642
  807dac:	00c00c04 	movi	r3,48
  807db0:	10c00205 	stb	r3,8(r2)

		flag	= 	AsciiHex2char(&CmdBuf.param[0],&val8);	//gain
  807db4:	e0bfff84 	addi	r2,fp,-2
  807db8:	100b883a 	mov	r5,r2
  807dbc:	010020f4 	movhi	r4,131
  807dc0:	212dc9c4 	addi	r4,r4,-18649
  807dc4:	0806f640 	call	806f64 <AsciiHex2char>
  807dc8:	e0bffc15 	stw	r2,-16(fp)
		if ((flag != 0) || (val8<0) || (val8>1)){
  807dcc:	e0bffc17 	ldw	r2,-16(fp)
  807dd0:	1000041e 	bne	r2,zero,807de4 <Execute+0x5e8>
  807dd4:	e0bfff83 	ldbu	r2,-2(fp)
  807dd8:	10803fcc 	andi	r2,r2,255
  807ddc:	108000b0 	cmpltui	r2,r2,2
  807de0:	1000151e 	bne	r2,zero,807e38 <Execute+0x63c>
			RspBuf.command='S';
  807de4:	008020f4 	movhi	r2,131
  807de8:	10adcb84 	addi	r2,r2,-18642
  807dec:	00c014c4 	movi	r3,83
  807df0:	10c00045 	stb	r3,1(r2)
			RspBuf.sub_command='F';
  807df4:	008020f4 	movhi	r2,131
  807df8:	10adcb84 	addi	r2,r2,-18642
  807dfc:	00c01184 	movi	r3,70
  807e00:	10c00085 	stb	r3,2(r2)
			RspBuf.param[0]='p';
  807e04:	008020f4 	movhi	r2,131
  807e08:	10adcb84 	addi	r2,r2,-18642
  807e0c:	00c01c04 	movi	r3,112
  807e10:	10c000c5 	stb	r3,3(r2)
			RspBuf.param[1]='e';
  807e14:	008020f4 	movhi	r2,131
  807e18:	10adcb84 	addi	r2,r2,-18642
  807e1c:	00c01944 	movi	r3,101
  807e20:	10c00105 	stb	r3,4(r2)
			FT245_SendBlock((char *)&RspBuf,10);
  807e24:	01400284 	movi	r5,10
  807e28:	010020f4 	movhi	r4,131
  807e2c:	212dcb84 	addi	r4,r4,-18642
  807e30:	0805b580 	call	805b58 <FT245_SendBlock>
			return;
  807e34:	00000c06 	br	807e68 <Execute+0x66c>
		}
		else{
			setSampleFreq(val8);	//default
  807e38:	e0bfff83 	ldbu	r2,-2(fp)
  807e3c:	10803fcc 	andi	r2,r2,255
  807e40:	1009883a 	mov	r4,r2
  807e44:	08086480 	call	808648 <setSampleFreq>
			debug_print(RGB565_GREEN,"Sample Frequency Set Successfully");
  807e48:	014020b4 	movhi	r5,130
  807e4c:	2966c004 	addi	r5,r5,-25856
  807e50:	0101f804 	movi	r4,2016
  807e54:	0806cb80 	call	806cb8 <debug_print>
		}
		FT245_SendBlock((char *)&RspBuf,10);
  807e58:	01400284 	movi	r5,10
  807e5c:	010020f4 	movhi	r4,131
  807e60:	212dcb84 	addi	r4,r4,-18642
  807e64:	0805b580 	call	805b58 <FT245_SendBlock>
	}
}
  807e68:	e037883a 	mov	sp,fp
  807e6c:	dfc00117 	ldw	ra,4(sp)
  807e70:	df000017 	ldw	fp,0(sp)
  807e74:	dec00204 	addi	sp,sp,8
  807e78:	f800283a 	ret

00807e7c <init_PDM>:
PDMMIC_MOD *pPDM=(PDMMIC_MOD *)PDM_BASE;
PDMMIC_DATA *pPDMDATA =(PDMMIC_DATA *)0x00c00000;	//SDRAM second half

static float	CoeffOfstCncl	;

void init_PDM(void){
  807e7c:	defffe04 	addi	sp,sp,-8
  807e80:	df000115 	stw	fp,4(sp)
  807e84:	df000104 	addi	fp,sp,4
	pPDM->CtrlReg = _b_PDMMIC_CLR;
  807e88:	d0a00e17 	ldw	r2,-32712(gp)
  807e8c:	00c00044 	movi	r3,1
  807e90:	10c20015 	stw	r3,2048(r2)

	for( int i=0;i<MIC_CH_MAX;i++){
  807e94:	e03fff15 	stw	zero,-4(fp)
  807e98:	00000a06 	br	807ec4 <init_PDM+0x48>
		pPDM->OffsetCansel[i]=DEFAULT_OFFST_CAN;
  807e9c:	d0e00e17 	ldw	r3,-32712(gp)
  807ea0:	e0bfff17 	ldw	r2,-4(fp)
  807ea4:	10808204 	addi	r2,r2,520
  807ea8:	1085883a 	add	r2,r2,r2
  807eac:	1085883a 	add	r2,r2,r2
  807eb0:	1885883a 	add	r2,r3,r2
  807eb4:	10000015 	stw	zero,0(r2)
static float	CoeffOfstCncl	;

void init_PDM(void){
	pPDM->CtrlReg = _b_PDMMIC_CLR;

	for( int i=0;i<MIC_CH_MAX;i++){
  807eb8:	e0bfff17 	ldw	r2,-4(fp)
  807ebc:	10800044 	addi	r2,r2,1
  807ec0:	e0bfff15 	stw	r2,-4(fp)
  807ec4:	e0bfff17 	ldw	r2,-4(fp)
  807ec8:	10800110 	cmplti	r2,r2,4
  807ecc:	103ff31e 	bne	r2,zero,807e9c <__alt_data_end+0xfff07e9c>
		pPDM->OffsetCansel[i]=DEFAULT_OFFST_CAN;
	}
}
  807ed0:	0001883a 	nop
  807ed4:	e037883a 	mov	sp,fp
  807ed8:	df000017 	ldw	fp,0(sp)
  807edc:	dec00104 	addi	sp,sp,4
  807ee0:	f800283a 	ret

00807ee4 <enable_PDM>:

void enable_PDM(void){
  807ee4:	deffff04 	addi	sp,sp,-4
  807ee8:	df000015 	stw	fp,0(sp)
  807eec:	d839883a 	mov	fp,sp
	pPDM->CtrlReg &= ~_b_PDMMIC_CLR;
  807ef0:	d0a00e17 	ldw	r2,-32712(gp)
  807ef4:	d0e00e17 	ldw	r3,-32712(gp)
  807ef8:	19020017 	ldw	r4,2048(r3)
  807efc:	00ffff84 	movi	r3,-2
  807f00:	20c6703a 	and	r3,r4,r3
  807f04:	10c20015 	stw	r3,2048(r2)

}
  807f08:	0001883a 	nop
  807f0c:	e037883a 	mov	sp,fp
  807f10:	df000017 	ldw	fp,0(sp)
  807f14:	dec00104 	addi	sp,sp,4
  807f18:	f800283a 	ret

00807f1c <disable_PDM>:

void disable_PDM(void){
  807f1c:	deffff04 	addi	sp,sp,-4
  807f20:	df000015 	stw	fp,0(sp)
  807f24:	d839883a 	mov	fp,sp
	pPDM->CtrlReg |= _b_PDMMIC_CLR;
  807f28:	d0a00e17 	ldw	r2,-32712(gp)
  807f2c:	d0e00e17 	ldw	r3,-32712(gp)
  807f30:	18c20017 	ldw	r3,2048(r3)
  807f34:	18c00054 	ori	r3,r3,1
  807f38:	10c20015 	stw	r3,2048(r2)

}
  807f3c:	0001883a 	nop
  807f40:	e037883a 	mov	sp,fp
  807f44:	df000017 	ldw	fp,0(sp)
  807f48:	dec00104 	addi	sp,sp,4
  807f4c:	f800283a 	ret

00807f50 <CansellOffset>:

int CansellOffset(int ch,int datacount){
  807f50:	defff604 	addi	sp,sp,-40
  807f54:	dfc00915 	stw	ra,36(sp)
  807f58:	df000815 	stw	fp,32(sp)
  807f5c:	dc000715 	stw	r16,28(sp)
  807f60:	df000804 	addi	fp,sp,32
  807f64:	e13ffd15 	stw	r4,-12(fp)
  807f68:	e17ffe15 	stw	r5,-8(fp)
	int16_t snsdata;
	int count;
	int sum;
	float avg;

	if(ch>=MIC_CH_MAX)
  807f6c:	e0bffd17 	ldw	r2,-12(fp)
  807f70:	10800110 	cmplti	r2,r2,4
  807f74:	1000021e 	bne	r2,zero,807f80 <CansellOffset+0x30>
		return -1;
  807f78:	00bfffc4 	movi	r2,-1
  807f7c:	00008e06 	br	8081b8 <CansellOffset+0x268>
	if(datacount>0x40000)
  807f80:	e0bffe17 	ldw	r2,-8(fp)
  807f84:	00c00134 	movhi	r3,4
  807f88:	1880020e 	bge	r3,r2,807f94 <CansellOffset+0x44>
		return -1;
  807f8c:	00bfffc4 	movi	r2,-1
  807f90:	00008906 	br	8081b8 <CansellOffset+0x268>

	disable_PDM();
  807f94:	0807f1c0 	call	807f1c <disable_PDM>
	enable_PDM();
  807f98:	0807ee40 	call	807ee4 <enable_PDM>

	count=pPDM->SmpleCountReg;
  807f9c:	d0a00e17 	ldw	r2,-32712(gp)
  807fa0:	10820217 	ldw	r2,2056(r2)
  807fa4:	e0bff815 	stw	r2,-32(fp)
	while(count<datacount){
  807fa8:	00000506 	br	807fc0 <CansellOffset+0x70>
		count=pPDM->SmpleCountReg;
  807fac:	d0a00e17 	ldw	r2,-32712(gp)
  807fb0:	10820217 	ldw	r2,2056(r2)
  807fb4:	e0bff815 	stw	r2,-32(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  807fb8:	01000044 	movi	r4,1
  807fbc:	08023680 	call	802368 <vTaskDelay>

	disable_PDM();
	enable_PDM();

	count=pPDM->SmpleCountReg;
	while(count<datacount){
  807fc0:	e0fff817 	ldw	r3,-32(fp)
  807fc4:	e0bffe17 	ldw	r2,-8(fp)
  807fc8:	18bff816 	blt	r3,r2,807fac <__alt_data_end+0xfff07fac>
		count=pPDM->SmpleCountReg;
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}
	disable_PDM();
  807fcc:	0807f1c0 	call	807f1c <disable_PDM>


	for(sum=0,count=0;count<datacount;count++){
  807fd0:	e03ff915 	stw	zero,-28(fp)
  807fd4:	e03ff815 	stw	zero,-32(fp)
  807fd8:	00001006 	br	80801c <CansellOffset+0xcc>
		snsdata = pPDMDATA->Data[ch][count];
  807fdc:	d0e00f17 	ldw	r3,-32708(gp)
  807fe0:	e0bffd17 	ldw	r2,-12(fp)
  807fe4:	100894ba 	slli	r4,r2,18
  807fe8:	e0bff817 	ldw	r2,-32(fp)
  807fec:	2085883a 	add	r2,r4,r2
  807ff0:	1085883a 	add	r2,r2,r2
  807ff4:	1885883a 	add	r2,r3,r2
  807ff8:	1080000b 	ldhu	r2,0(r2)
  807ffc:	e0bffa0d 	sth	r2,-24(fp)
		sum += snsdata;
  808000:	e0bffa0f 	ldh	r2,-24(fp)
  808004:	e0fff917 	ldw	r3,-28(fp)
  808008:	1885883a 	add	r2,r3,r2
  80800c:	e0bff915 	stw	r2,-28(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}
	disable_PDM();


	for(sum=0,count=0;count<datacount;count++){
  808010:	e0bff817 	ldw	r2,-32(fp)
  808014:	10800044 	addi	r2,r2,1
  808018:	e0bff815 	stw	r2,-32(fp)
  80801c:	e0fff817 	ldw	r3,-32(fp)
  808020:	e0bffe17 	ldw	r2,-8(fp)
  808024:	18bfed16 	blt	r3,r2,807fdc <__alt_data_end+0xfff07fdc>
		snsdata = pPDMDATA->Data[ch][count];
		sum += snsdata;
	}

	avg = (float)sum/datacount;
  808028:	e13ff917 	ldw	r4,-28(fp)
  80802c:	080c5b80 	call	80c5b8 <__floatsisf>
  808030:	1021883a 	mov	r16,r2
  808034:	e13ffe17 	ldw	r4,-8(fp)
  808038:	080c5b80 	call	80c5b8 <__floatsisf>
  80803c:	1007883a 	mov	r3,r2
  808040:	180b883a 	mov	r5,r3
  808044:	8009883a 	mov	r4,r16
  808048:	080b7380 	call	80b738 <__divsf3>
  80804c:	1007883a 	mov	r3,r2
  808050:	e0fffb15 	stw	r3,-20(fp)

	Setteichi = pPDM->OffsetCansel[ch];
  808054:	d0e00e17 	ldw	r3,-32712(gp)
  808058:	e0bffd17 	ldw	r2,-12(fp)
  80805c:	10808204 	addi	r2,r2,520
  808060:	1085883a 	add	r2,r2,r2
  808064:	1085883a 	add	r2,r2,r2
  808068:	1885883a 	add	r2,r3,r2
  80806c:	10800017 	ldw	r2,0(r2)
  808070:	e0bffc15 	stw	r2,-16(fp)

	Setteichi -= (int16_t)(avg/39.2);
  808074:	e13ffb17 	ldw	r4,-20(fp)
  808078:	080ef640 	call	80ef64 <__extendsfdf2>
  80807c:	1011883a 	mov	r8,r2
  808080:	1813883a 	mov	r9,r3
  808084:	01a666b4 	movhi	r6,39322
  808088:	31a66684 	addi	r6,r6,-26214
  80808c:	01d01134 	movhi	r7,16452
  808090:	39e66644 	addi	r7,r7,-26215
  808094:	4009883a 	mov	r4,r8
  808098:	480b883a 	mov	r5,r9
  80809c:	080d0780 	call	80d078 <__divdf3>
  8080a0:	1009883a 	mov	r4,r2
  8080a4:	180b883a 	mov	r5,r3
  8080a8:	2005883a 	mov	r2,r4
  8080ac:	2807883a 	mov	r3,r5
  8080b0:	1009883a 	mov	r4,r2
  8080b4:	180b883a 	mov	r5,r3
  8080b8:	080ee080 	call	80ee08 <__fixdfsi>
  8080bc:	10bfffcc 	andi	r2,r2,65535
  8080c0:	10a0001c 	xori	r2,r2,32768
  8080c4:	10a00004 	addi	r2,r2,-32768
  8080c8:	e0fffc17 	ldw	r3,-16(fp)
  8080cc:	1885c83a 	sub	r2,r3,r2
  8080d0:	e0bffc15 	stw	r2,-16(fp)
	pPDM->OffsetCansel[ch] = Setteichi;
  8080d4:	d1200e17 	ldw	r4,-32712(gp)
  8080d8:	e0fffc17 	ldw	r3,-16(fp)
  8080dc:	e0bffd17 	ldw	r2,-12(fp)
  8080e0:	10808204 	addi	r2,r2,520
  8080e4:	1085883a 	add	r2,r2,r2
  8080e8:	1085883a 	add	r2,r2,r2
  8080ec:	2085883a 	add	r2,r4,r2
  8080f0:	10c00015 	stw	r3,0(r2)

	enable_PDM();
  8080f4:	0807ee40 	call	807ee4 <enable_PDM>
	count=pPDM->SmpleCountReg;
  8080f8:	d0a00e17 	ldw	r2,-32712(gp)
  8080fc:	10820217 	ldw	r2,2056(r2)
  808100:	e0bff815 	stw	r2,-32(fp)
	while(count<datacount){
  808104:	00000506 	br	80811c <CansellOffset+0x1cc>
		count=pPDM->SmpleCountReg;
  808108:	d0a00e17 	ldw	r2,-32712(gp)
  80810c:	10820217 	ldw	r2,2056(r2)
  808110:	e0bff815 	stw	r2,-32(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  808114:	01000044 	movi	r4,1
  808118:	08023680 	call	802368 <vTaskDelay>
	Setteichi -= (int16_t)(avg/39.2);
	pPDM->OffsetCansel[ch] = Setteichi;

	enable_PDM();
	count=pPDM->SmpleCountReg;
	while(count<datacount){
  80811c:	e0fff817 	ldw	r3,-32(fp)
  808120:	e0bffe17 	ldw	r2,-8(fp)
  808124:	18bff816 	blt	r3,r2,808108 <__alt_data_end+0xfff08108>
		count=pPDM->SmpleCountReg;
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}
	disable_PDM();
  808128:	0807f1c0 	call	807f1c <disable_PDM>


	for(sum=0,count=0;count<datacount;count++){
  80812c:	e03ff915 	stw	zero,-28(fp)
  808130:	e03ff815 	stw	zero,-32(fp)
  808134:	00001006 	br	808178 <CansellOffset+0x228>
		snsdata = pPDMDATA->Data[ch][count];
  808138:	d0e00f17 	ldw	r3,-32708(gp)
  80813c:	e0bffd17 	ldw	r2,-12(fp)
  808140:	100894ba 	slli	r4,r2,18
  808144:	e0bff817 	ldw	r2,-32(fp)
  808148:	2085883a 	add	r2,r4,r2
  80814c:	1085883a 	add	r2,r2,r2
  808150:	1885883a 	add	r2,r3,r2
  808154:	1080000b 	ldhu	r2,0(r2)
  808158:	e0bffa0d 	sth	r2,-24(fp)
		sum += snsdata;
  80815c:	e0bffa0f 	ldh	r2,-24(fp)
  808160:	e0fff917 	ldw	r3,-28(fp)
  808164:	1885883a 	add	r2,r3,r2
  808168:	e0bff915 	stw	r2,-28(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}
	disable_PDM();


	for(sum=0,count=0;count<datacount;count++){
  80816c:	e0bff817 	ldw	r2,-32(fp)
  808170:	10800044 	addi	r2,r2,1
  808174:	e0bff815 	stw	r2,-32(fp)
  808178:	e0fff817 	ldw	r3,-32(fp)
  80817c:	e0bffe17 	ldw	r2,-8(fp)
  808180:	18bfed16 	blt	r3,r2,808138 <__alt_data_end+0xfff08138>
		snsdata = pPDMDATA->Data[ch][count];
		sum += snsdata;
	}

	avg = (float)sum/datacount;
  808184:	e13ff917 	ldw	r4,-28(fp)
  808188:	080c5b80 	call	80c5b8 <__floatsisf>
  80818c:	1021883a 	mov	r16,r2
  808190:	e13ffe17 	ldw	r4,-8(fp)
  808194:	080c5b80 	call	80c5b8 <__floatsisf>
  808198:	1007883a 	mov	r3,r2
  80819c:	180b883a 	mov	r5,r3
  8081a0:	8009883a 	mov	r4,r16
  8081a4:	080b7380 	call	80b738 <__divsf3>
  8081a8:	1007883a 	mov	r3,r2
  8081ac:	e0fffb15 	stw	r3,-20(fp)

	return (int)avg;
  8081b0:	e13ffb17 	ldw	r4,-20(fp)
  8081b4:	080c5480 	call	80c548 <__fixsfsi>
}
  8081b8:	e6ffff04 	addi	sp,fp,-4
  8081bc:	dfc00217 	ldw	ra,8(sp)
  8081c0:	df000117 	ldw	fp,4(sp)
  8081c4:	dc000017 	ldw	r16,0(sp)
  8081c8:	dec00304 	addi	sp,sp,12
  8081cc:	f800283a 	ret

008081d0 <MicCarivration>:

int MicCarivration(void){
  8081d0:	deffe604 	addi	sp,sp,-104
  8081d4:	dfc01915 	stw	ra,100(sp)
  8081d8:	df001815 	stw	fp,96(sp)
  8081dc:	df001804 	addi	fp,sp,96
	int Max[MIC_CH_MAX];
	int sum[MIC_CH_MAX];
	float avg[MIC_CH_MAX];
	int16_t temp16;

	char TryCount=0;
  8081e0:	e03feb05 	stb	zero,-84(fp)
	char str[20];

	pPDM->OffsetCansel[0] = 0;
  8081e4:	d0a00e17 	ldw	r2,-32712(gp)
  8081e8:	10020815 	stw	zero,2080(r2)
	pPDM->OffsetCansel[1] = 0;
  8081ec:	d0a00e17 	ldw	r2,-32712(gp)
  8081f0:	10020915 	stw	zero,2084(r2)
	pPDM->OffsetCansel[2] = 0;
  8081f4:	d0a00e17 	ldw	r2,-32712(gp)
  8081f8:	10020a15 	stw	zero,2088(r2)
	pPDM->OffsetCansel[3] = 0;
  8081fc:	d0a00e17 	ldw	r2,-32712(gp)
  808200:	10020b15 	stw	zero,2092(r2)

	while(TryCount<20){
  808204:	0000bc06 	br	8084f8 <MicCarivration+0x328>
		disable_PDM();
  808208:	0807f1c0 	call	807f1c <disable_PDM>
		enable_PDM();	//sample start
  80820c:	0807ee40 	call	807ee4 <enable_PDM>

		SampleCount = pPDM->SmpleCountReg;
  808210:	d0a00e17 	ldw	r2,-32712(gp)
  808214:	10820217 	ldw	r2,2056(r2)
  808218:	e0bfe815 	stw	r2,-96(fp)
		while(SampleCount<CaribSmplCount){
  80821c:	00000506 	br	808234 <MicCarivration+0x64>
			SampleCount=pPDM->SmpleCountReg;
  808220:	d0a00e17 	ldw	r2,-32712(gp)
  808224:	10820217 	ldw	r2,2056(r2)
  808228:	e0bfe815 	stw	r2,-96(fp)
			vTaskDelay( 1/portTICK_PERIOD_MS);
  80822c:	01000044 	movi	r4,1
  808230:	08023680 	call	802368 <vTaskDelay>
	while(TryCount<20){
		disable_PDM();
		enable_PDM();	//sample start

		SampleCount = pPDM->SmpleCountReg;
		while(SampleCount<CaribSmplCount){
  808234:	e0bfe817 	ldw	r2,-96(fp)
  808238:	10840010 	cmplti	r2,r2,4096
  80823c:	103ff81e 	bne	r2,zero,808220 <__alt_data_end+0xfff08220>
			SampleCount=pPDM->SmpleCountReg;
			vTaskDelay( 1/portTICK_PERIOD_MS);
		}
		disable_PDM();	//sample end
  808240:	0807f1c0 	call	807f1c <disable_PDM>




		//eCHlB
		for(ch=0;ch<MIC_CH_MAX;ch++){
  808244:	e03fe915 	stw	zero,-92(fp)
  808248:	00005e06 	br	8083c4 <MicCarivration+0x1f4>
				Max[ch]=0;
  80824c:	e0bfe917 	ldw	r2,-92(fp)
  808250:	1085883a 	add	r2,r2,r2
  808254:	1085883a 	add	r2,r2,r2
  808258:	e0ffe804 	addi	r3,fp,-96
  80825c:	1885883a 	add	r2,r3,r2
  808260:	10800704 	addi	r2,r2,28
  808264:	10000015 	stw	zero,0(r2)
				for(sum[ch]=0,SampleCount=0;SampleCount<CaribSmplCount;SampleCount++){
  808268:	e0bfe917 	ldw	r2,-92(fp)
  80826c:	1085883a 	add	r2,r2,r2
  808270:	1085883a 	add	r2,r2,r2
  808274:	e13fe804 	addi	r4,fp,-96
  808278:	2085883a 	add	r2,r4,r2
  80827c:	10800b04 	addi	r2,r2,44
  808280:	10000015 	stw	zero,0(r2)
  808284:	e03fe815 	stw	zero,-96(fp)
  808288:	00003206 	br	808354 <MicCarivration+0x184>
				snsdata = pPDMDATA->Data[ch][SampleCount];
  80828c:	d0e00f17 	ldw	r3,-32708(gp)
  808290:	e0bfe917 	ldw	r2,-92(fp)
  808294:	100894ba 	slli	r4,r2,18
  808298:	e0bfe817 	ldw	r2,-96(fp)
  80829c:	2085883a 	add	r2,r4,r2
  8082a0:	1085883a 	add	r2,r2,r2
  8082a4:	1885883a 	add	r2,r3,r2
  8082a8:	1080000b 	ldhu	r2,0(r2)
  8082ac:	e0bfeb8d 	sth	r2,-82(fp)
				if (Max[ch]<abs(snsdata)){
  8082b0:	e0bfe917 	ldw	r2,-92(fp)
  8082b4:	1085883a 	add	r2,r2,r2
  8082b8:	1085883a 	add	r2,r2,r2
  8082bc:	e0ffe804 	addi	r3,fp,-96
  8082c0:	1885883a 	add	r2,r3,r2
  8082c4:	10800704 	addi	r2,r2,28
  8082c8:	10c00017 	ldw	r3,0(r2)
  8082cc:	e0bfeb8f 	ldh	r2,-82(fp)
  8082d0:	1000010e 	bge	r2,zero,8082d8 <MicCarivration+0x108>
  8082d4:	0085c83a 	sub	r2,zero,r2
  8082d8:	18800b0e 	bge	r3,r2,808308 <MicCarivration+0x138>
					Max[ch]=abs(snsdata);
  8082dc:	e0bfeb8f 	ldh	r2,-82(fp)
  8082e0:	1000010e 	bge	r2,zero,8082e8 <MicCarivration+0x118>
  8082e4:	0085c83a 	sub	r2,zero,r2
  8082e8:	1007883a 	mov	r3,r2
  8082ec:	e0bfe917 	ldw	r2,-92(fp)
  8082f0:	1085883a 	add	r2,r2,r2
  8082f4:	1085883a 	add	r2,r2,r2
  8082f8:	e13fe804 	addi	r4,fp,-96
  8082fc:	2085883a 	add	r2,r4,r2
  808300:	10800704 	addi	r2,r2,28
  808304:	10c00015 	stw	r3,0(r2)
				}

				sum[ch] += snsdata;
  808308:	e0bfe917 	ldw	r2,-92(fp)
  80830c:	1085883a 	add	r2,r2,r2
  808310:	1085883a 	add	r2,r2,r2
  808314:	e0ffe804 	addi	r3,fp,-96
  808318:	1885883a 	add	r2,r3,r2
  80831c:	10800b04 	addi	r2,r2,44
  808320:	10c00017 	ldw	r3,0(r2)
  808324:	e0bfeb8f 	ldh	r2,-82(fp)
  808328:	1887883a 	add	r3,r3,r2
  80832c:	e0bfe917 	ldw	r2,-92(fp)
  808330:	1085883a 	add	r2,r2,r2
  808334:	1085883a 	add	r2,r2,r2
  808338:	e13fe804 	addi	r4,fp,-96
  80833c:	2085883a 	add	r2,r4,r2
  808340:	10800b04 	addi	r2,r2,44
  808344:	10c00015 	stw	r3,0(r2)


		//eCHlB
		for(ch=0;ch<MIC_CH_MAX;ch++){
				Max[ch]=0;
				for(sum[ch]=0,SampleCount=0;SampleCount<CaribSmplCount;SampleCount++){
  808348:	e0bfe817 	ldw	r2,-96(fp)
  80834c:	10800044 	addi	r2,r2,1
  808350:	e0bfe815 	stw	r2,-96(fp)
  808354:	e0bfe817 	ldw	r2,-96(fp)
  808358:	10840010 	cmplti	r2,r2,4096
  80835c:	103fcb1e 	bne	r2,zero,80828c <__alt_data_end+0xfff0828c>
					Max[ch]=abs(snsdata);
				}

				sum[ch] += snsdata;
			}
			avg[ch] = (float)sum[ch] / CaribSmplCount;
  808360:	e0bfe917 	ldw	r2,-92(fp)
  808364:	1085883a 	add	r2,r2,r2
  808368:	1085883a 	add	r2,r2,r2
  80836c:	e0ffe804 	addi	r3,fp,-96
  808370:	1885883a 	add	r2,r3,r2
  808374:	10800b04 	addi	r2,r2,44
  808378:	10800017 	ldw	r2,0(r2)
  80837c:	1009883a 	mov	r4,r2
  808380:	080c5b80 	call	80c5b8 <__floatsisf>
  808384:	1007883a 	mov	r3,r2
  808388:	01516034 	movhi	r5,17792
  80838c:	1809883a 	mov	r4,r3
  808390:	080b7380 	call	80b738 <__divsf3>
  808394:	1009883a 	mov	r4,r2
  808398:	2007883a 	mov	r3,r4
  80839c:	e0bfe917 	ldw	r2,-92(fp)
  8083a0:	1085883a 	add	r2,r2,r2
  8083a4:	1085883a 	add	r2,r2,r2
  8083a8:	e13fe804 	addi	r4,fp,-96
  8083ac:	2085883a 	add	r2,r4,r2
  8083b0:	10800f04 	addi	r2,r2,60
  8083b4:	10c00015 	stw	r3,0(r2)




		//eCHlB
		for(ch=0;ch<MIC_CH_MAX;ch++){
  8083b8:	e0bfe917 	ldw	r2,-92(fp)
  8083bc:	10800044 	addi	r2,r2,1
  8083c0:	e0bfe915 	stw	r2,-92(fp)
  8083c4:	e0bfe917 	ldw	r2,-92(fp)
  8083c8:	10800110 	cmplti	r2,r2,4
  8083cc:	103f9f1e 	bne	r2,zero,80824c <__alt_data_end+0xfff0824c>
				sum[ch] += snsdata;
			}
			avg[ch] = (float)sum[ch] / CaribSmplCount;
		}

		for(flag=0,ch=0;ch<MIC_CH_MAX;ch++){
  8083d0:	e03fea15 	stw	zero,-88(fp)
  8083d4:	e03fe915 	stw	zero,-92(fp)
  8083d8:	00003d06 	br	8084d0 <MicCarivration+0x300>
			average=avg[ch];
  8083dc:	e0bfe917 	ldw	r2,-92(fp)
  8083e0:	1085883a 	add	r2,r2,r2
  8083e4:	1085883a 	add	r2,r2,r2
  8083e8:	e0ffe804 	addi	r3,fp,-96
  8083ec:	1885883a 	add	r2,r3,r2
  8083f0:	10800f04 	addi	r2,r2,60
  8083f4:	10800017 	ldw	r2,0(r2)
  8083f8:	e0bfec15 	stw	r2,-80(fp)
			if(	fabsf(average) > OffsetMargin ){	//ItZbgl}[W
  8083fc:	e0ffec17 	ldw	r3,-80(fp)
  808400:	00a00034 	movhi	r2,32768
  808404:	10bfffc4 	addi	r2,r2,-1
  808408:	1884703a 	and	r2,r3,r2
  80840c:	0150b234 	movhi	r5,17096
  808410:	1009883a 	mov	r4,r2
  808414:	080bb780 	call	80bb78 <__gesf2>
  808418:	00802a0e 	bge	zero,r2,8084c4 <MicCarivration+0x2f4>
//				delta=(int16_t)(avg[ch]/79.78);
//				delta=(int16_t)(avg[ch]/9.97);
				delta=(int16_t)(avg[ch]/CoeffOfstCncl);
  80841c:	e0bfe917 	ldw	r2,-92(fp)
  808420:	1085883a 	add	r2,r2,r2
  808424:	1085883a 	add	r2,r2,r2
  808428:	e13fe804 	addi	r4,fp,-96
  80842c:	2085883a 	add	r2,r4,r2
  808430:	10800f04 	addi	r2,r2,60
  808434:	10c00017 	ldw	r3,0(r2)
  808438:	d0a03817 	ldw	r2,-32544(gp)
  80843c:	100b883a 	mov	r5,r2
  808440:	1809883a 	mov	r4,r3
  808444:	080b7380 	call	80b738 <__divsf3>
  808448:	1007883a 	mov	r3,r2
  80844c:	1805883a 	mov	r2,r3
  808450:	1009883a 	mov	r4,r2
  808454:	080c5480 	call	80c548 <__fixsfsi>
  808458:	10bfffcc 	andi	r2,r2,65535
  80845c:	10a0001c 	xori	r2,r2,32768
  808460:	10a00004 	addi	r2,r2,-32768
  808464:	e0bfed15 	stw	r2,-76(fp)
				Setteichi = pPDM->OffsetCansel[ch];
  808468:	d0e00e17 	ldw	r3,-32712(gp)
  80846c:	e0bfe917 	ldw	r2,-92(fp)
  808470:	10808204 	addi	r2,r2,520
  808474:	1085883a 	add	r2,r2,r2
  808478:	1085883a 	add	r2,r2,r2
  80847c:	1885883a 	add	r2,r3,r2
  808480:	10800017 	ldw	r2,0(r2)
  808484:	e0bfee15 	stw	r2,-72(fp)
				Setteichi -= delta;
  808488:	e0ffee17 	ldw	r3,-72(fp)
  80848c:	e0bfed17 	ldw	r2,-76(fp)
  808490:	1885c83a 	sub	r2,r3,r2
  808494:	e0bfee15 	stw	r2,-72(fp)
				pPDM->OffsetCansel[ch] = Setteichi;
  808498:	d1200e17 	ldw	r4,-32712(gp)
  80849c:	e0ffee17 	ldw	r3,-72(fp)
  8084a0:	e0bfe917 	ldw	r2,-92(fp)
  8084a4:	10808204 	addi	r2,r2,520
  8084a8:	1085883a 	add	r2,r2,r2
  8084ac:	1085883a 	add	r2,r2,r2
  8084b0:	2085883a 	add	r2,r4,r2
  8084b4:	10c00015 	stw	r3,0(r2)
				flag++;
  8084b8:	e0bfea17 	ldw	r2,-88(fp)
  8084bc:	10800044 	addi	r2,r2,1
  8084c0:	e0bfea15 	stw	r2,-88(fp)
				sum[ch] += snsdata;
			}
			avg[ch] = (float)sum[ch] / CaribSmplCount;
		}

		for(flag=0,ch=0;ch<MIC_CH_MAX;ch++){
  8084c4:	e0bfe917 	ldw	r2,-92(fp)
  8084c8:	10800044 	addi	r2,r2,1
  8084cc:	e0bfe915 	stw	r2,-92(fp)
  8084d0:	e0bfe917 	ldw	r2,-92(fp)
  8084d4:	10800110 	cmplti	r2,r2,4
  8084d8:	103fc01e 	bne	r2,zero,8083dc <__alt_data_end+0xfff083dc>
				Setteichi -= delta;
				pPDM->OffsetCansel[ch] = Setteichi;
				flag++;
			}
		}
		if (flag==0){
  8084dc:	e0bfea17 	ldw	r2,-88(fp)
  8084e0:	1000021e 	bne	r2,zero,8084ec <MicCarivration+0x31c>
			return 0;
  8084e4:	0005883a 	mov	r2,zero
  8084e8:	00000706 	br	808508 <MicCarivration+0x338>
		}
		else{
			TryCount++;
  8084ec:	e0bfeb03 	ldbu	r2,-84(fp)
  8084f0:	10800044 	addi	r2,r2,1
  8084f4:	e0bfeb05 	stb	r2,-84(fp)
	pPDM->OffsetCansel[0] = 0;
	pPDM->OffsetCansel[1] = 0;
	pPDM->OffsetCansel[2] = 0;
	pPDM->OffsetCansel[3] = 0;

	while(TryCount<20){
  8084f8:	e0bfeb07 	ldb	r2,-84(fp)
  8084fc:	10800510 	cmplti	r2,r2,20
  808500:	103f411e 	bne	r2,zero,808208 <__alt_data_end+0xfff08208>
		}
		else{
			TryCount++;
		}
	}
	return -1;
  808504:	00bfffc4 	movi	r2,-1
}
  808508:	e037883a 	mov	sp,fp
  80850c:	dfc00117 	ldw	ra,4(sp)
  808510:	df000017 	ldw	fp,0(sp)
  808514:	dec00204 	addi	sp,sp,8
  808518:	f800283a 	ret

0080851c <getMicData>:


void getMicData(int SampleCount){
  80851c:	defffc04 	addi	sp,sp,-16
  808520:	dfc00315 	stw	ra,12(sp)
  808524:	df000215 	stw	fp,8(sp)
  808528:	df000204 	addi	fp,sp,8
  80852c:	e13fff15 	stw	r4,-4(fp)
#define	CaribSmplCount	4096
#define	OffsetMargin	100.0

	volatile int Count;

	disable_PDM();
  808530:	0807f1c0 	call	807f1c <disable_PDM>
	enable_PDM();	//sample start
  808534:	0807ee40 	call	807ee4 <enable_PDM>

	Count = pPDM->SmpleCountReg;
  808538:	d0a00e17 	ldw	r2,-32712(gp)
  80853c:	10820217 	ldw	r2,2056(r2)
  808540:	e0bffe15 	stw	r2,-8(fp)
	while(Count<SampleCount){
  808544:	00000506 	br	80855c <getMicData+0x40>
		Count=pPDM->SmpleCountReg;
  808548:	d0a00e17 	ldw	r2,-32712(gp)
  80854c:	10820217 	ldw	r2,2056(r2)
  808550:	e0bffe15 	stw	r2,-8(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  808554:	01000044 	movi	r4,1
  808558:	08023680 	call	802368 <vTaskDelay>

	disable_PDM();
	enable_PDM();	//sample start

	Count = pPDM->SmpleCountReg;
	while(Count<SampleCount){
  80855c:	e0fffe17 	ldw	r3,-8(fp)
  808560:	e0bfff17 	ldw	r2,-4(fp)
  808564:	18bff816 	blt	r3,r2,808548 <__alt_data_end+0xfff08548>
		Count=pPDM->SmpleCountReg;
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}
	disable_PDM();	//sample end
  808568:	0807f1c0 	call	807f1c <disable_PDM>
}
  80856c:	0001883a 	nop
  808570:	e037883a 	mov	sp,fp
  808574:	dfc00117 	ldw	ra,4(sp)
  808578:	df000017 	ldw	fp,0(sp)
  80857c:	dec00204 	addi	sp,sp,8
  808580:	f800283a 	ret

00808584 <setMicGain>:

int setMicGain( uint8_t gain){
  808584:	defffd04 	addi	sp,sp,-12
  808588:	dfc00215 	stw	ra,8(sp)
  80858c:	df000115 	stw	fp,4(sp)
  808590:	df000104 	addi	fp,sp,4
  808594:	2005883a 	mov	r2,r4
  808598:	e0bfff05 	stb	r2,-4(fp)

	if (gain>=8){
  80859c:	e0bfff03 	ldbu	r2,-4(fp)
  8085a0:	10800230 	cmpltui	r2,r2,8
  8085a4:	1000021e 	bne	r2,zero,8085b0 <setMicGain+0x2c>
		return -1;
  8085a8:	00bfffc4 	movi	r2,-1
  8085ac:	00002106 	br	808634 <setMicGain+0xb0>
	}


	CoeffOfstCncl	= FIRGAIN/ pow(2,(12-gain));
  8085b0:	e0bfff03 	ldbu	r2,-4(fp)
  8085b4:	00c00304 	movi	r3,12
  8085b8:	1885c83a 	sub	r2,r3,r2
  8085bc:	1009883a 	mov	r4,r2
  8085c0:	080ee880 	call	80ee88 <__floatsidf>
  8085c4:	1009883a 	mov	r4,r2
  8085c8:	180b883a 	mov	r5,r3
  8085cc:	200d883a 	mov	r6,r4
  8085d0:	280f883a 	mov	r7,r5
  8085d4:	0009883a 	mov	r4,zero
  8085d8:	01500034 	movhi	r5,16384
  8085dc:	08095fc0 	call	8095fc <pow>
  8085e0:	1009883a 	mov	r4,r2
  8085e4:	180b883a 	mov	r5,r3
  8085e8:	200d883a 	mov	r6,r4
  8085ec:	280f883a 	mov	r7,r5
  8085f0:	0009883a 	mov	r4,zero
  8085f4:	01502934 	movhi	r5,16548
  8085f8:	297c8004 	addi	r5,r5,-3584
  8085fc:	080d0780 	call	80d078 <__divdf3>
  808600:	1009883a 	mov	r4,r2
  808604:	180b883a 	mov	r5,r3
  808608:	2005883a 	mov	r2,r4
  80860c:	2807883a 	mov	r3,r5
  808610:	1009883a 	mov	r4,r2
  808614:	180b883a 	mov	r5,r3
  808618:	080f0740 	call	80f074 <__truncdfsf2>
  80861c:	1007883a 	mov	r3,r2
  808620:	d0e03815 	stw	r3,-32544(gp)

	pPDM->GainReg=gain;
  808624:	d0a00e17 	ldw	r2,-32712(gp)
  808628:	e0ffff03 	ldbu	r3,-4(fp)
  80862c:	10c20315 	stw	r3,2060(r2)
	return 0;
  808630:	0005883a 	mov	r2,zero
}
  808634:	e037883a 	mov	sp,fp
  808638:	dfc00117 	ldw	ra,4(sp)
  80863c:	df000017 	ldw	fp,0(sp)
  808640:	dec00204 	addi	sp,sp,8
  808644:	f800283a 	ret

00808648 <setSampleFreq>:

int setSampleFreq( uint8_t Freq){
  808648:	defffe04 	addi	sp,sp,-8
  80864c:	df000115 	stw	fp,4(sp)
  808650:	df000104 	addi	fp,sp,4
  808654:	2005883a 	mov	r2,r4
  808658:	e0bfff05 	stb	r2,-4(fp)

	if ((Freq==0)||(Freq==1)){
  80865c:	e0bfff03 	ldbu	r2,-4(fp)
  808660:	10000326 	beq	r2,zero,808670 <setSampleFreq+0x28>
  808664:	e0bfff03 	ldbu	r2,-4(fp)
  808668:	10800058 	cmpnei	r2,r2,1
  80866c:	1000051e 	bne	r2,zero,808684 <setSampleFreq+0x3c>
		pPDM->ModeReg =(uint32_t)Freq;
  808670:	d0a00e17 	ldw	r2,-32712(gp)
  808674:	e0ffff03 	ldbu	r3,-4(fp)
  808678:	10c20415 	stw	r3,2064(r2)
		return 0;
  80867c:	0005883a 	mov	r2,zero
  808680:	00000106 	br	808688 <setSampleFreq+0x40>
	}
	return -1;
  808684:	00bfffc4 	movi	r2,-1
}
  808688:	e037883a 	mov	sp,fp
  80868c:	df000017 	ldw	fp,0(sp)
  808690:	dec00104 	addi	sp,sp,4
  808694:	f800283a 	ret

00808698 <task_button>:

extern xQueueHandle ButtonQue;


void task_button(void *pvParameters )
{
  808698:	defff704 	addi	sp,sp,-36
  80869c:	dfc00815 	stw	ra,32(sp)
  8086a0:	df000715 	stw	fp,28(sp)
  8086a4:	df000704 	addi	fp,sp,28
  8086a8:	e13fff15 	stw	r4,-4(fp)

#define	DEGLITCH_CNT	10

	char	BTN_STS=0x00;	//deGlitch{^Xe[^X
  8086ac:	e03ffe45 	stb	zero,-7(fp)

	unsigned char *pBTN =(unsigned char *)BUTTON_BASE;
  8086b0:	00841004 	movi	r2,4160
  8086b4:	e0bffd15 	stw	r2,-12(fp)
	uint8_t BtnREAD;

	int COUNT0 = 0;
  8086b8:	e03ff915 	stw	zero,-28(fp)
	int COUNT1 = 0;
  8086bc:	e03ffa15 	stw	zero,-24(fp)
	int COUNT2 = 0;
  8086c0:	e03ffb15 	stw	zero,-20(fp)
	int COUNT3 = 0;
  8086c4:	e03ffc15 	stw	zero,-16(fp)

	for(;;){
		BTN_STS=0x00;
  8086c8:	e03ffe45 	stb	zero,-7(fp)
		BtnREAD = (~(*pBTN))&0x0f;
  8086cc:	e0bffd17 	ldw	r2,-12(fp)
  8086d0:	10800003 	ldbu	r2,0(r2)
  8086d4:	0084303a 	nor	r2,zero,r2
  8086d8:	108003cc 	andi	r2,r2,15
  8086dc:	e0bffe05 	stb	r2,-8(fp)

		//button0
		if (BtnREAD & 0x1){//push
  8086e0:	e0bffe03 	ldbu	r2,-8(fp)
  8086e4:	1080004c 	andi	r2,r2,1
  8086e8:	10000726 	beq	r2,zero,808708 <task_button+0x70>
			if (COUNT0<DEGLITCH_CNT){
  8086ec:	e0bff917 	ldw	r2,-28(fp)
  8086f0:	10800288 	cmpgei	r2,r2,10
  8086f4:	10000b1e 	bne	r2,zero,808724 <task_button+0x8c>
				COUNT0++;
  8086f8:	e0bff917 	ldw	r2,-28(fp)
  8086fc:	10800044 	addi	r2,r2,1
  808700:	e0bff915 	stw	r2,-28(fp)
  808704:	00000706 	br	808724 <task_button+0x8c>
			}
		}
		else{	//release
			if (COUNT0==DEGLITCH_CNT){	//release after 100ms push
  808708:	e0bff917 	ldw	r2,-28(fp)
  80870c:	10800298 	cmpnei	r2,r2,10
  808710:	1000031e 	bne	r2,zero,808720 <task_button+0x88>
				BTN_STS += 0x01;
  808714:	e0bffe43 	ldbu	r2,-7(fp)
  808718:	10800044 	addi	r2,r2,1
  80871c:	e0bffe45 	stb	r2,-7(fp)
			}
			COUNT0=0;
  808720:	e03ff915 	stw	zero,-28(fp)
		}

		//button1
		if (BtnREAD & 0x2){//push
  808724:	e0bffe03 	ldbu	r2,-8(fp)
  808728:	1080008c 	andi	r2,r2,2
  80872c:	10000726 	beq	r2,zero,80874c <task_button+0xb4>
			if (COUNT1 < DEGLITCH_CNT){
  808730:	e0bffa17 	ldw	r2,-24(fp)
  808734:	10800288 	cmpgei	r2,r2,10
  808738:	10000b1e 	bne	r2,zero,808768 <task_button+0xd0>
				COUNT1++;
  80873c:	e0bffa17 	ldw	r2,-24(fp)
  808740:	10800044 	addi	r2,r2,1
  808744:	e0bffa15 	stw	r2,-24(fp)
  808748:	00000706 	br	808768 <task_button+0xd0>
			}
		}
		else{	//release
			if (COUNT1==DEGLITCH_CNT){	//release after 100ms push
  80874c:	e0bffa17 	ldw	r2,-24(fp)
  808750:	10800298 	cmpnei	r2,r2,10
  808754:	1000031e 	bne	r2,zero,808764 <task_button+0xcc>
				BTN_STS += 0x02;
  808758:	e0bffe43 	ldbu	r2,-7(fp)
  80875c:	10800084 	addi	r2,r2,2
  808760:	e0bffe45 	stb	r2,-7(fp)
			}
			COUNT1 = 0;
  808764:	e03ffa15 	stw	zero,-24(fp)
		}

		//button2
		if (BtnREAD & 0x4){//push
  808768:	e0bffe03 	ldbu	r2,-8(fp)
  80876c:	1080010c 	andi	r2,r2,4
  808770:	10000726 	beq	r2,zero,808790 <task_button+0xf8>
			if (COUNT2 < DEGLITCH_CNT){
  808774:	e0bffb17 	ldw	r2,-20(fp)
  808778:	10800288 	cmpgei	r2,r2,10
  80877c:	10000b1e 	bne	r2,zero,8087ac <task_button+0x114>
				COUNT2++;
  808780:	e0bffb17 	ldw	r2,-20(fp)
  808784:	10800044 	addi	r2,r2,1
  808788:	e0bffb15 	stw	r2,-20(fp)
  80878c:	00000706 	br	8087ac <task_button+0x114>
			}
		}
		else{	//release
			if (COUNT2==DEGLITCH_CNT){	//release after 100ms push
  808790:	e0bffb17 	ldw	r2,-20(fp)
  808794:	10800298 	cmpnei	r2,r2,10
  808798:	1000031e 	bne	r2,zero,8087a8 <task_button+0x110>
				BTN_STS += 0x04;
  80879c:	e0bffe43 	ldbu	r2,-7(fp)
  8087a0:	10800104 	addi	r2,r2,4
  8087a4:	e0bffe45 	stb	r2,-7(fp)
			}
			COUNT2 = 0;
  8087a8:	e03ffb15 	stw	zero,-20(fp)
		}

		//button3
		if (BtnREAD & 0x8){//push
  8087ac:	e0bffe03 	ldbu	r2,-8(fp)
  8087b0:	1080020c 	andi	r2,r2,8
  8087b4:	10000726 	beq	r2,zero,8087d4 <task_button+0x13c>
			if (COUNT3 < DEGLITCH_CNT){
  8087b8:	e0bffc17 	ldw	r2,-16(fp)
  8087bc:	10800288 	cmpgei	r2,r2,10
  8087c0:	10000b1e 	bne	r2,zero,8087f0 <task_button+0x158>
				COUNT3++;
  8087c4:	e0bffc17 	ldw	r2,-16(fp)
  8087c8:	10800044 	addi	r2,r2,1
  8087cc:	e0bffc15 	stw	r2,-16(fp)
  8087d0:	00000706 	br	8087f0 <task_button+0x158>
			}
		}
		else{	//release
			if (COUNT3==DEGLITCH_CNT){	//release after 100ms push
  8087d4:	e0bffc17 	ldw	r2,-16(fp)
  8087d8:	10800298 	cmpnei	r2,r2,10
  8087dc:	1000031e 	bne	r2,zero,8087ec <task_button+0x154>
				BTN_STS += 0x08;
  8087e0:	e0bffe43 	ldbu	r2,-7(fp)
  8087e4:	10800204 	addi	r2,r2,8
  8087e8:	e0bffe45 	stb	r2,-7(fp)
			}
			COUNT3 = 0;
  8087ec:	e03ffc15 	stw	zero,-16(fp)
		}


		if(BTN_STS!=0){
  8087f0:	e0bffe43 	ldbu	r2,-7(fp)
  8087f4:	10803fcc 	andi	r2,r2,255
  8087f8:	1080201c 	xori	r2,r2,128
  8087fc:	10bfe004 	addi	r2,r2,-128
  808800:	10000726 	beq	r2,zero,808820 <task_button+0x188>
			xQueueSendToBack(ButtonQue,&BTN_STS,portMAX_DELAY);
  808804:	d0a03717 	ldw	r2,-32548(gp)
  808808:	e0fffe44 	addi	r3,fp,-7
  80880c:	000f883a 	mov	r7,zero
  808810:	01bfffc4 	movi	r6,-1
  808814:	180b883a 	mov	r5,r3
  808818:	1009883a 	mov	r4,r2
  80881c:	08011780 	call	801178 <xQueueGenericSend>
		}

		vTaskDelay( 10/ portTICK_PERIOD_MS);
  808820:	01000284 	movi	r4,10
  808824:	08023680 	call	802368 <vTaskDelay>
	}
  808828:	003fa706 	br	8086c8 <__alt_data_end+0xfff086c8>

0080882c <task_com>:
extern xQueueHandle SnsorQue;
extern xQueueHandle SendReqQue;
extern volatile int sample_block;

void task_com(void *pvParameters )
{
  80882c:	defff004 	addi	sp,sp,-64
  808830:	dfc00f15 	stw	ra,60(sp)
  808834:	df000e15 	stw	fp,56(sp)
  808838:	df000e04 	addi	fp,sp,56
  80883c:	e13fff15 	stw	r4,-4(fp)
	FT245FIFOmod *pFT245 = (FT245FIFOmod *) FT245_BASE;
  808840:	008c0004 	movi	r2,12288
  808844:	e0bff515 	stw	r2,-44(fp)
	DMAMOD *pFT245_DMA =(DMAMOD *)DMA_BASE;
  808848:	00842004 	movi	r2,4224
  80884c:	e0bff615 	stw	r2,-40(fp)
	int *pLED = (int *)LED_BASE;
  808850:	00841804 	movi	r2,4192
  808854:	e0bff715 	stw	r2,-36(fp)




	int LocalQue=SEND_STOP;
  808858:	00800084 	movi	r2,2
  80885c:	e0bffa15 	stw	r2,-24(fp)
	int QueSns;
	int DataTxEn;

	char header[6];
	char footer[2];
	header[1]=0x80;	header[0]=0x00;
  808860:	00bfe004 	movi	r2,-128
  808864:	e0bffd45 	stb	r2,-11(fp)
  808868:	e03ffd05 	stb	zero,-12(fp)
	header[3]=0x00;	header[2]=0x01;
  80886c:	e03ffdc5 	stb	zero,-9(fp)
  808870:	00800044 	movi	r2,1
  808874:	e0bffd85 	stb	r2,-10(fp)
	footer[1]=0x7f;	footer[0]=0xff;
  808878:	00801fc4 	movi	r2,127
  80887c:	e0bffec5 	stb	r2,-5(fp)
  808880:	00bfffc4 	movi	r2,-1
  808884:	e0bffe85 	stb	r2,-6(fp)

	InitCom();		//FT245 initialize
  808888:	0806d1c0 	call	806d1c <InitCom>
	init_DMAMOD(pFT245_DMA);
  80888c:	e13ff617 	ldw	r4,-40(fp)
  808890:	08058880 	call	805888 <init_DMAMOD>
	send_block=0;
  808894:	e03ff215 	stw	zero,-56(fp)
	DataTxEn=0;
  808898:	e03ff415 	stw	zero,-48(fp)

	for(;;){
		result = xQueueReceive(SendReqQue,&LocalQue,1);
  80889c:	d0a03617 	ldw	r2,-32552(gp)
  8088a0:	e0fffa04 	addi	r3,fp,-24
  8088a4:	000f883a 	mov	r7,zero
  8088a8:	01800044 	movi	r6,1
  8088ac:	180b883a 	mov	r5,r3
  8088b0:	1009883a 	mov	r4,r2
  8088b4:	08014f00 	call	8014f0 <xQueueGenericReceive>
  8088b8:	e0bff815 	stw	r2,-32(fp)
		if (result==pdTRUE){
  8088bc:	e0bff817 	ldw	r2,-32(fp)
  8088c0:	10800058 	cmpnei	r2,r2,1
  8088c4:	10000e1e 	bne	r2,zero,808900 <task_com+0xd4>
			send_block_max=LocalQue;
  8088c8:	e0bffa17 	ldw	r2,-24(fp)
  8088cc:	e0bff315 	stw	r2,-52(fp)
			send_block=0;
  8088d0:	e03ff215 	stw	zero,-56(fp)
			DataTxEn=1;
  8088d4:	00800044 	movi	r2,1
  8088d8:	e0bff415 	stw	r2,-48(fp)


//			QueSns=SnsQue_STOP;
//			xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);

			QueSns=SnsQue_START;
  8088dc:	00800044 	movi	r2,1
  8088e0:	e0bffc15 	stw	r2,-16(fp)
			xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
  8088e4:	d0a03517 	ldw	r2,-32556(gp)
  8088e8:	e0fffc04 	addi	r3,fp,-16
  8088ec:	000f883a 	mov	r7,zero
  8088f0:	01bfffc4 	movi	r6,-1
  8088f4:	180b883a 	mov	r5,r3
  8088f8:	1009883a 	mov	r4,r2
  8088fc:	08011780 	call	801178 <xQueueGenericSend>

		}

		if(DataTxEn == 1){
  808900:	e0bff417 	ldw	r2,-48(fp)
  808904:	10800058 	cmpnei	r2,r2,1
  808908:	10007b1e 	bne	r2,zero,808af8 <task_com+0x2cc>
			if((sample_block>send_block) && (send_block<send_block_max)){
  80890c:	d0a03b17 	ldw	r2,-32532(gp)
  808910:	e0fff217 	ldw	r3,-56(fp)
  808914:	18806a0e 	bge	r3,r2,808ac0 <task_com+0x294>
  808918:	e0fff217 	ldw	r3,-56(fp)
  80891c:	e0bff317 	ldw	r2,-52(fp)
  808920:	1880670e 	bge	r3,r2,808ac0 <task_com+0x294>
				header[5] = (char)((send_block>>8) & 0xff);
  808924:	e0bff217 	ldw	r2,-56(fp)
  808928:	1005d23a 	srai	r2,r2,8
  80892c:	e0bffe45 	stb	r2,-7(fp)
				header[4] = (char)(send_block & 0xff);
  808930:	e0bff217 	ldw	r2,-56(fp)
  808934:	e0bffe05 	stb	r2,-8(fp)
//				FT245_SendBlock(header,6);

				//cH0
				DMA_SRC_ADDR = 0xc00000 + (send_block & 0x7f) * 0x1000;
  808938:	e0bff217 	ldw	r2,-56(fp)
  80893c:	10801fcc 	andi	r2,r2,127
  808940:	10830004 	addi	r2,r2,3072
  808944:	1004933a 	slli	r2,r2,12
  808948:	e0bff915 	stw	r2,-28(fp)
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);
  80894c:	e0bff517 	ldw	r2,-44(fp)
  808950:	10800404 	addi	r2,r2,16
  808954:	01c40004 	movi	r7,4096
  808958:	100d883a 	mov	r6,r2
  80895c:	e17ff917 	ldw	r5,-28(fp)
  808960:	e13ff617 	ldw	r4,-40(fp)
  808964:	08058cc0 	call	8058cc <startDMA>

				flag = getDMAsts(pFT245_DMA);
  808968:	e13ff617 	ldw	r4,-40(fp)
  80896c:	08059340 	call	805934 <getDMAsts>
  808970:	e0bffb15 	stw	r2,-20(fp)
				while(flag!=0){
  808974:	00000506 	br	80898c <task_com+0x160>
					flag = getDMAsts(pFT245_DMA);
  808978:	e13ff617 	ldw	r4,-40(fp)
  80897c:	08059340 	call	805934 <getDMAsts>
  808980:	e0bffb15 	stw	r2,-20(fp)
					vTaskDelay( 1/ portTICK_PERIOD_MS);
  808984:	01000044 	movi	r4,1
  808988:	08023680 	call	802368 <vTaskDelay>
				//cH0
				DMA_SRC_ADDR = 0xc00000 + (send_block & 0x7f) * 0x1000;
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);

				flag = getDMAsts(pFT245_DMA);
				while(flag!=0){
  80898c:	e0bffb17 	ldw	r2,-20(fp)
  808990:	103ff91e 	bne	r2,zero,808978 <__alt_data_end+0xfff08978>
					flag = getDMAsts(pFT245_DMA);
					vTaskDelay( 1/ portTICK_PERIOD_MS);
				}
#ifdef SEND_4CH
				//cH1
				DMA_SRC_ADDR = 0xc80000 + (send_block & 0x7f) * 0x1000;
  808994:	e0bff217 	ldw	r2,-56(fp)
  808998:	10801fcc 	andi	r2,r2,127
  80899c:	10832004 	addi	r2,r2,3200
  8089a0:	1004933a 	slli	r2,r2,12
  8089a4:	e0bff915 	stw	r2,-28(fp)
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);
  8089a8:	e0bff517 	ldw	r2,-44(fp)
  8089ac:	10800404 	addi	r2,r2,16
  8089b0:	01c40004 	movi	r7,4096
  8089b4:	100d883a 	mov	r6,r2
  8089b8:	e17ff917 	ldw	r5,-28(fp)
  8089bc:	e13ff617 	ldw	r4,-40(fp)
  8089c0:	08058cc0 	call	8058cc <startDMA>

				flag = getDMAsts(pFT245_DMA);
  8089c4:	e13ff617 	ldw	r4,-40(fp)
  8089c8:	08059340 	call	805934 <getDMAsts>
  8089cc:	e0bffb15 	stw	r2,-20(fp)
				while(flag!=0){
  8089d0:	00000506 	br	8089e8 <task_com+0x1bc>
					flag = getDMAsts(pFT245_DMA);
  8089d4:	e13ff617 	ldw	r4,-40(fp)
  8089d8:	08059340 	call	805934 <getDMAsts>
  8089dc:	e0bffb15 	stw	r2,-20(fp)
					vTaskDelay( 1/ portTICK_PERIOD_MS);
  8089e0:	01000044 	movi	r4,1
  8089e4:	08023680 	call	802368 <vTaskDelay>
				//cH1
				DMA_SRC_ADDR = 0xc80000 + (send_block & 0x7f) * 0x1000;
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);

				flag = getDMAsts(pFT245_DMA);
				while(flag!=0){
  8089e8:	e0bffb17 	ldw	r2,-20(fp)
  8089ec:	103ff91e 	bne	r2,zero,8089d4 <__alt_data_end+0xfff089d4>
					flag = getDMAsts(pFT245_DMA);
					vTaskDelay( 1/ portTICK_PERIOD_MS);
				}

				//cH2
				DMA_SRC_ADDR = 0xD00000 + (send_block & 0x7f) * 0x1000;
  8089f0:	e0bff217 	ldw	r2,-56(fp)
  8089f4:	10801fcc 	andi	r2,r2,127
  8089f8:	10834004 	addi	r2,r2,3328
  8089fc:	1004933a 	slli	r2,r2,12
  808a00:	e0bff915 	stw	r2,-28(fp)
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);
  808a04:	e0bff517 	ldw	r2,-44(fp)
  808a08:	10800404 	addi	r2,r2,16
  808a0c:	01c40004 	movi	r7,4096
  808a10:	100d883a 	mov	r6,r2
  808a14:	e17ff917 	ldw	r5,-28(fp)
  808a18:	e13ff617 	ldw	r4,-40(fp)
  808a1c:	08058cc0 	call	8058cc <startDMA>

				flag = getDMAsts(pFT245_DMA);
  808a20:	e13ff617 	ldw	r4,-40(fp)
  808a24:	08059340 	call	805934 <getDMAsts>
  808a28:	e0bffb15 	stw	r2,-20(fp)
				while(flag!=0){
  808a2c:	00000506 	br	808a44 <task_com+0x218>
					flag = getDMAsts(pFT245_DMA);
  808a30:	e13ff617 	ldw	r4,-40(fp)
  808a34:	08059340 	call	805934 <getDMAsts>
  808a38:	e0bffb15 	stw	r2,-20(fp)
					vTaskDelay( 1/ portTICK_PERIOD_MS);
  808a3c:	01000044 	movi	r4,1
  808a40:	08023680 	call	802368 <vTaskDelay>
				//cH2
				DMA_SRC_ADDR = 0xD00000 + (send_block & 0x7f) * 0x1000;
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);

				flag = getDMAsts(pFT245_DMA);
				while(flag!=0){
  808a44:	e0bffb17 	ldw	r2,-20(fp)
  808a48:	103ff91e 	bne	r2,zero,808a30 <__alt_data_end+0xfff08a30>
					flag = getDMAsts(pFT245_DMA);
					vTaskDelay( 1/ portTICK_PERIOD_MS);
				}
				//cH3
				DMA_SRC_ADDR = 0xD80000 + (send_block & 0x7f) * 0x1000;
  808a4c:	e0bff217 	ldw	r2,-56(fp)
  808a50:	10801fcc 	andi	r2,r2,127
  808a54:	10836004 	addi	r2,r2,3456
  808a58:	1004933a 	slli	r2,r2,12
  808a5c:	e0bff915 	stw	r2,-28(fp)
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);
  808a60:	e0bff517 	ldw	r2,-44(fp)
  808a64:	10800404 	addi	r2,r2,16
  808a68:	01c40004 	movi	r7,4096
  808a6c:	100d883a 	mov	r6,r2
  808a70:	e17ff917 	ldw	r5,-28(fp)
  808a74:	e13ff617 	ldw	r4,-40(fp)
  808a78:	08058cc0 	call	8058cc <startDMA>

				flag = getDMAsts(pFT245_DMA);
  808a7c:	e13ff617 	ldw	r4,-40(fp)
  808a80:	08059340 	call	805934 <getDMAsts>
  808a84:	e0bffb15 	stw	r2,-20(fp)
				while(flag!=0){
  808a88:	00000506 	br	808aa0 <task_com+0x274>
					flag = getDMAsts(pFT245_DMA);
  808a8c:	e13ff617 	ldw	r4,-40(fp)
  808a90:	08059340 	call	805934 <getDMAsts>
  808a94:	e0bffb15 	stw	r2,-20(fp)
					vTaskDelay( 1/ portTICK_PERIOD_MS);
  808a98:	01000044 	movi	r4,1
  808a9c:	08023680 	call	802368 <vTaskDelay>
				//cH3
				DMA_SRC_ADDR = 0xD80000 + (send_block & 0x7f) * 0x1000;
				startDMA ( pFT245_DMA, DMA_SRC_ADDR, (int)&pFT245->Fifo,0x1000);

				flag = getDMAsts(pFT245_DMA);
				while(flag!=0){
  808aa0:	e0bffb17 	ldw	r2,-20(fp)
  808aa4:	103ff91e 	bne	r2,zero,808a8c <__alt_data_end+0xfff08a8c>

#endif


//				FT245_SendBlock(footer,2);
				send_block++;
  808aa8:	e0bff217 	ldw	r2,-56(fp)
  808aac:	10800044 	addi	r2,r2,1
  808ab0:	e0bff215 	stw	r2,-56(fp)
				*pLED = send_block;
  808ab4:	e0bff717 	ldw	r2,-36(fp)
  808ab8:	e0fff217 	ldw	r3,-56(fp)
  808abc:	10c00015 	stw	r3,0(r2)
			}

			if(send_block>=send_block_max){
  808ac0:	e0fff217 	ldw	r3,-56(fp)
  808ac4:	e0bff317 	ldw	r2,-52(fp)
  808ac8:	18800b16 	blt	r3,r2,808af8 <task_com+0x2cc>
				send_block=0;
  808acc:	e03ff215 	stw	zero,-56(fp)
				DataTxEn=0;
  808ad0:	e03ff415 	stw	zero,-48(fp)
				QueSns=SnsQue_STOP;
  808ad4:	00800084 	movi	r2,2
  808ad8:	e0bffc15 	stw	r2,-16(fp)
				xQueueSendToBack(SnsorQue,&QueSns,portMAX_DELAY);
  808adc:	d0a03517 	ldw	r2,-32556(gp)
  808ae0:	e0fffc04 	addi	r3,fp,-16
  808ae4:	000f883a 	mov	r7,zero
  808ae8:	01bfffc4 	movi	r6,-1
  808aec:	180b883a 	mov	r5,r3
  808af0:	1009883a 	mov	r4,r2
  808af4:	08011780 	call	801178 <xQueueGenericSend>
			}
		}
		vTaskDelay( 1/ portTICK_PERIOD_MS);
  808af8:	01000044 	movi	r4,1
  808afc:	08023680 	call	802368 <vTaskDelay>
	}
  808b00:	003f6606 	br	80889c <__alt_data_end+0xfff0889c>

00808b04 <disp_debug_str>:
extern xQueueHandle GLCD_QUE;

GRAP_LCD_QUE	LocQue;
int debug_disp_raw=0;

void disp_debug_str(uint16_t color,uint8_t *str){
  808b04:	defffa04 	addi	sp,sp,-24
  808b08:	dfc00515 	stw	ra,20(sp)
  808b0c:	df000415 	stw	fp,16(sp)
  808b10:	df000404 	addi	fp,sp,16
  808b14:	2005883a 	mov	r2,r4
  808b18:	e17fff15 	stw	r5,-4(fp)
  808b1c:	e0bffe0d 	sth	r2,-8(fp)

	glcd_put_string_fixed(	8,debug_disp_raw,(char *)str,color,0);
  808b20:	d0a03917 	ldw	r2,-32540(gp)
  808b24:	e0fffe0b 	ldhu	r3,-8(fp)
  808b28:	d8000015 	stw	zero,0(sp)
  808b2c:	180f883a 	mov	r7,r3
  808b30:	e1bfff17 	ldw	r6,-4(fp)
  808b34:	100b883a 	mov	r5,r2
  808b38:	01000204 	movi	r4,8
  808b3c:	08063b80 	call	8063b8 <glcd_put_string_fixed>
	debug_disp_raw+=12;
  808b40:	d0a03917 	ldw	r2,-32540(gp)
  808b44:	10800304 	addi	r2,r2,12
  808b48:	d0a03915 	stw	r2,-32540(gp)
	if(debug_disp_raw>228){
  808b4c:	d0a03917 	ldw	r2,-32540(gp)
  808b50:	10803950 	cmplti	r2,r2,229
  808b54:	1000011e 	bne	r2,zero,808b5c <disp_debug_str+0x58>
		debug_disp_raw=0;
  808b58:	d0203915 	stw	zero,-32540(gp)
	}
	glcd_drawRectangleFill(	0,debug_disp_raw,319,debug_disp_raw+12,0,0);
  808b5c:	d0a03917 	ldw	r2,-32540(gp)
  808b60:	10bfffcc 	andi	r2,r2,65535
  808b64:	d0e03917 	ldw	r3,-32540(gp)
  808b68:	18c00304 	addi	r3,r3,12
  808b6c:	18ffffcc 	andi	r3,r3,65535
  808b70:	d8000115 	stw	zero,4(sp)
  808b74:	d8000015 	stw	zero,0(sp)
  808b78:	180f883a 	mov	r7,r3
  808b7c:	01804fc4 	movi	r6,319
  808b80:	100b883a 	mov	r5,r2
  808b84:	0009883a 	mov	r4,zero
  808b88:	080600c0 	call	80600c <glcd_drawRectangleFill>
}
  808b8c:	0001883a 	nop
  808b90:	e037883a 	mov	sp,fp
  808b94:	dfc00117 	ldw	ra,4(sp)
  808b98:	df000017 	ldw	fp,0(sp)
  808b9c:	dec00204 	addi	sp,sp,8
  808ba0:	f800283a 	ret

00808ba4 <task_disp>:

void task_disp(void *pvParameters )
{  /* USER CODE BEGIN tk_qvga */
  808ba4:	defff604 	addi	sp,sp,-40
  808ba8:	dfc00915 	stw	ra,36(sp)
  808bac:	df000815 	stw	fp,32(sp)
  808bb0:	df000804 	addi	fp,sp,32
  808bb4:	e13fff15 	stw	r4,-4(fp)

	portBASE_TYPE result;
	GRAP_LCD_QUE LocQue;

	glcd_Init(RGB565_BLACK);
  808bb8:	0009883a 	mov	r4,zero
  808bbc:	0805da00 	call	805da0 <glcd_Init>
	vTaskDelay( 10/portTICK_PERIOD_MS);
  808bc0:	01000284 	movi	r4,10
  808bc4:	08023680 	call	802368 <vTaskDelay>

	for(;;)
	{

		result = xQueueReceive(GLCD_QUE,&LocQue,0);
  808bc8:	d0a03417 	ldw	r2,-32560(gp)
  808bcc:	e0fffb04 	addi	r3,fp,-20
  808bd0:	000f883a 	mov	r7,zero
  808bd4:	000d883a 	mov	r6,zero
  808bd8:	180b883a 	mov	r5,r3
  808bdc:	1009883a 	mov	r4,r2
  808be0:	08014f00 	call	8014f0 <xQueueGenericReceive>
  808be4:	e0bffa15 	stw	r2,-24(fp)
#if 1
		if(result==pdTRUE){
  808be8:	e0bffa17 	ldw	r2,-24(fp)
  808bec:	10800058 	cmpnei	r2,r2,1
  808bf0:	1000b51e 	bne	r2,zero,808ec8 <task_disp+0x324>

			if(LocQue.data[0]==GLCDCMD_INIT){
  808bf4:	e0bffb0b 	ldhu	r2,-20(fp)
  808bf8:	10bfffcc 	andi	r2,r2,65535
  808bfc:	1000041e 	bne	r2,zero,808c10 <task_disp+0x6c>
				glcd_Init(LocQue.INIT.COLOR);
  808c00:	e0bffb8b 	ldhu	r2,-18(fp)
  808c04:	10bfffcc 	andi	r2,r2,65535
  808c08:	1009883a 	mov	r4,r2
  808c0c:	0805da00 	call	805da0 <glcd_Init>
			}
			if(LocQue.data[0]==GLCDCMD_PSET){
  808c10:	e0bffb0b 	ldhu	r2,-20(fp)
  808c14:	10bfffcc 	andi	r2,r2,65535
  808c18:	10804018 	cmpnei	r2,r2,256
  808c1c:	10000a1e 	bne	r2,zero,808c48 <task_disp+0xa4>
				glcd_PointSet( LocQue.PSET.XS,LocQue.PSET.YS,LocQue.PSET.COLOR);
  808c20:	e0bffc0b 	ldhu	r2,-16(fp)
  808c24:	10bfffcc 	andi	r2,r2,65535
  808c28:	e0fffc8b 	ldhu	r3,-14(fp)
  808c2c:	18ffffcc 	andi	r3,r3,65535
  808c30:	e13ffb8b 	ldhu	r4,-18(fp)
  808c34:	213fffcc 	andi	r4,r4,65535
  808c38:	200d883a 	mov	r6,r4
  808c3c:	180b883a 	mov	r5,r3
  808c40:	1009883a 	mov	r4,r2
  808c44:	0805dec0 	call	805dec <glcd_PointSet>
			}
			if(LocQue.data[0]==GLCDCMD_LINE){
  808c48:	e0bffb0b 	ldhu	r2,-20(fp)
  808c4c:	10bfffcc 	andi	r2,r2,65535
  808c50:	10840018 	cmpnei	r2,r2,4096
  808c54:	1000101e 	bne	r2,zero,808c98 <task_disp+0xf4>
				glcd_drawLine(LocQue.LINE.XS,LocQue.LINE.YS,LocQue.LINE.XE,LocQue.LINE.YE,LocQue.LINE.COLOR);
  808c58:	e0bffc0b 	ldhu	r2,-16(fp)
  808c5c:	10ffffcc 	andi	r3,r2,65535
  808c60:	e0bffc8b 	ldhu	r2,-14(fp)
  808c64:	113fffcc 	andi	r4,r2,65535
  808c68:	e0bffd0b 	ldhu	r2,-12(fp)
  808c6c:	117fffcc 	andi	r5,r2,65535
  808c70:	e0bffd8b 	ldhu	r2,-10(fp)
  808c74:	11bfffcc 	andi	r6,r2,65535
  808c78:	e0bffb8b 	ldhu	r2,-18(fp)
  808c7c:	10bfffcc 	andi	r2,r2,65535
  808c80:	d8800015 	stw	r2,0(sp)
  808c84:	300f883a 	mov	r7,r6
  808c88:	280d883a 	mov	r6,r5
  808c8c:	200b883a 	mov	r5,r4
  808c90:	1809883a 	mov	r4,r3
  808c94:	0805e440 	call	805e44 <glcd_drawLine>
			}
			if(LocQue.data[0]==GLCDCMD_VLINE){
  808c98:	e0bffb0b 	ldhu	r2,-20(fp)
  808c9c:	10bfffcc 	andi	r2,r2,65535
  808ca0:	10844018 	cmpnei	r2,r2,4352
  808ca4:	10000d1e 	bne	r2,zero,808cdc <task_disp+0x138>
				glcd_drawVline(LocQue.VLINE.XS,LocQue.VLINE.YS,LocQue.VLINE.LENGTH,LocQue.VLINE.COLOR);
  808ca8:	e0bffc0b 	ldhu	r2,-16(fp)
  808cac:	10bfffcc 	andi	r2,r2,65535
  808cb0:	e0fffc8b 	ldhu	r3,-14(fp)
  808cb4:	18ffffcc 	andi	r3,r3,65535
  808cb8:	e13ffd0b 	ldhu	r4,-12(fp)
  808cbc:	213fffcc 	andi	r4,r4,65535
  808cc0:	e17ffb8b 	ldhu	r5,-18(fp)
  808cc4:	297fffcc 	andi	r5,r5,65535
  808cc8:	280f883a 	mov	r7,r5
  808ccc:	200d883a 	mov	r6,r4
  808cd0:	180b883a 	mov	r5,r3
  808cd4:	1009883a 	mov	r4,r2
  808cd8:	0805f280 	call	805f28 <glcd_drawVline>
			}
			if(LocQue.data[0]==GLCDCMD_HLINE){
  808cdc:	e0bffb0b 	ldhu	r2,-20(fp)
  808ce0:	10bfffcc 	andi	r2,r2,65535
  808ce4:	10848018 	cmpnei	r2,r2,4608
  808ce8:	10000d1e 	bne	r2,zero,808d20 <task_disp+0x17c>
				glcd_drawHline(LocQue.HLINE.XS,LocQue.HLINE.YS,LocQue.HLINE.LENGTH,LocQue.HLINE.COLOR);
  808cec:	e0bffc0b 	ldhu	r2,-16(fp)
  808cf0:	10bfffcc 	andi	r2,r2,65535
  808cf4:	e0fffc8b 	ldhu	r3,-14(fp)
  808cf8:	18ffffcc 	andi	r3,r3,65535
  808cfc:	e13ffd0b 	ldhu	r4,-12(fp)
  808d00:	213fffcc 	andi	r4,r4,65535
  808d04:	e17ffb8b 	ldhu	r5,-18(fp)
  808d08:	297fffcc 	andi	r5,r5,65535
  808d0c:	280f883a 	mov	r7,r5
  808d10:	200d883a 	mov	r6,r4
  808d14:	180b883a 	mov	r5,r3
  808d18:	1009883a 	mov	r4,r2
  808d1c:	0805ebc0 	call	805ebc <glcd_drawHline>
			}
			if(LocQue.data[0]==GLCDCMD_RECT){
  808d20:	e0bffb0b 	ldhu	r2,-20(fp)
  808d24:	10bfffcc 	andi	r2,r2,65535
  808d28:	10880018 	cmpnei	r2,r2,8192
  808d2c:	1000101e 	bne	r2,zero,808d70 <task_disp+0x1cc>
				glcd_drawRectangle(LocQue.RECT.XS,LocQue.RECT.YS,LocQue.RECT.XE,LocQue.RECT.YE,LocQue.RECT.COLOR);
  808d30:	e0bffc0b 	ldhu	r2,-16(fp)
  808d34:	10ffffcc 	andi	r3,r2,65535
  808d38:	e0bffc8b 	ldhu	r2,-14(fp)
  808d3c:	113fffcc 	andi	r4,r2,65535
  808d40:	e0bffd0b 	ldhu	r2,-12(fp)
  808d44:	117fffcc 	andi	r5,r2,65535
  808d48:	e0bffd8b 	ldhu	r2,-10(fp)
  808d4c:	11bfffcc 	andi	r6,r2,65535
  808d50:	e0bffb8b 	ldhu	r2,-18(fp)
  808d54:	10bfffcc 	andi	r2,r2,65535
  808d58:	d8800015 	stw	r2,0(sp)
  808d5c:	300f883a 	mov	r7,r6
  808d60:	280d883a 	mov	r6,r5
  808d64:	200b883a 	mov	r5,r4
  808d68:	1809883a 	mov	r4,r3
  808d6c:	0805f940 	call	805f94 <glcd_drawRectangle>
			}
			if(LocQue.data[0]==GLCDCMD_RECT_FILL){
  808d70:	e0bffb0b 	ldhu	r2,-20(fp)
  808d74:	10bfffcc 	andi	r2,r2,65535
  808d78:	10884018 	cmpnei	r2,r2,8448
  808d7c:	10000f1e 	bne	r2,zero,808dbc <task_disp+0x218>
				glcd_drawRectangleFill(LocQue.RECT_FILL.XS,LocQue.RECT_FILL.YS,LocQue.RECT_FILL.XE,LocQue.RECT_FILL.YE,
  808d80:	e0bffc8b 	ldhu	r2,-14(fp)
  808d84:	113fffcc 	andi	r4,r2,65535
  808d88:	e0bffd0b 	ldhu	r2,-12(fp)
  808d8c:	117fffcc 	andi	r5,r2,65535
  808d90:	e0bffd8b 	ldhu	r2,-10(fp)
  808d94:	11bfffcc 	andi	r6,r2,65535
  808d98:	e0bffe0b 	ldhu	r2,-8(fp)
  808d9c:	11ffffcc 	andi	r7,r2,65535
						LocQue.RECT_FILL.LINE_COLOR,LocQue.RECT_FILL.FILL_COLOR);
  808da0:	e0bffb8b 	ldhu	r2,-18(fp)
			}
			if(LocQue.data[0]==GLCDCMD_RECT){
				glcd_drawRectangle(LocQue.RECT.XS,LocQue.RECT.YS,LocQue.RECT.XE,LocQue.RECT.YE,LocQue.RECT.COLOR);
			}
			if(LocQue.data[0]==GLCDCMD_RECT_FILL){
				glcd_drawRectangleFill(LocQue.RECT_FILL.XS,LocQue.RECT_FILL.YS,LocQue.RECT_FILL.XE,LocQue.RECT_FILL.YE,
  808da4:	10bfffcc 	andi	r2,r2,65535
						LocQue.RECT_FILL.LINE_COLOR,LocQue.RECT_FILL.FILL_COLOR);
  808da8:	e0fffc0b 	ldhu	r3,-16(fp)
			}
			if(LocQue.data[0]==GLCDCMD_RECT){
				glcd_drawRectangle(LocQue.RECT.XS,LocQue.RECT.YS,LocQue.RECT.XE,LocQue.RECT.YE,LocQue.RECT.COLOR);
			}
			if(LocQue.data[0]==GLCDCMD_RECT_FILL){
				glcd_drawRectangleFill(LocQue.RECT_FILL.XS,LocQue.RECT_FILL.YS,LocQue.RECT_FILL.XE,LocQue.RECT_FILL.YE,
  808dac:	18ffffcc 	andi	r3,r3,65535
  808db0:	d8c00115 	stw	r3,4(sp)
  808db4:	d8800015 	stw	r2,0(sp)
  808db8:	080600c0 	call	80600c <glcd_drawRectangleFill>
						LocQue.RECT_FILL.LINE_COLOR,LocQue.RECT_FILL.FILL_COLOR);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING){
  808dbc:	e0bffb0b 	ldhu	r2,-20(fp)
  808dc0:	10bfffcc 	andi	r2,r2,65535
  808dc4:	10900018 	cmpnei	r2,r2,16384
  808dc8:	10000f1e 	bne	r2,zero,808e08 <task_disp+0x264>
				glcd_put_string_fixed(LocQue.PRINT_STRING.XS,LocQue.PRINT_STRING.YS,LocQue.PRINT_STRING.str,
  808dcc:	e0bffc8b 	ldhu	r2,-14(fp)
  808dd0:	10ffffcc 	andi	r3,r2,65535
  808dd4:	e0bffd0b 	ldhu	r2,-12(fp)
  808dd8:	113fffcc 	andi	r4,r2,65535
  808ddc:	e17ffe17 	ldw	r5,-8(fp)
						LocQue.PRINT_STRING.COLOR,LocQue.PRINT_STRING.FONT_SIZE);
  808de0:	e0bffb8b 	ldhu	r2,-18(fp)
			if(LocQue.data[0]==GLCDCMD_RECT_FILL){
				glcd_drawRectangleFill(LocQue.RECT_FILL.XS,LocQue.RECT_FILL.YS,LocQue.RECT_FILL.XE,LocQue.RECT_FILL.YE,
						LocQue.RECT_FILL.LINE_COLOR,LocQue.RECT_FILL.FILL_COLOR);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING){
				glcd_put_string_fixed(LocQue.PRINT_STRING.XS,LocQue.PRINT_STRING.YS,LocQue.PRINT_STRING.str,
  808de4:	11bfffcc 	andi	r6,r2,65535
						LocQue.PRINT_STRING.COLOR,LocQue.PRINT_STRING.FONT_SIZE);
  808de8:	e0bffd8b 	ldhu	r2,-10(fp)
			if(LocQue.data[0]==GLCDCMD_RECT_FILL){
				glcd_drawRectangleFill(LocQue.RECT_FILL.XS,LocQue.RECT_FILL.YS,LocQue.RECT_FILL.XE,LocQue.RECT_FILL.YE,
						LocQue.RECT_FILL.LINE_COLOR,LocQue.RECT_FILL.FILL_COLOR);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING){
				glcd_put_string_fixed(LocQue.PRINT_STRING.XS,LocQue.PRINT_STRING.YS,LocQue.PRINT_STRING.str,
  808dec:	10bfffcc 	andi	r2,r2,65535
  808df0:	d8800015 	stw	r2,0(sp)
  808df4:	300f883a 	mov	r7,r6
  808df8:	280d883a 	mov	r6,r5
  808dfc:	200b883a 	mov	r5,r4
  808e00:	1809883a 	mov	r4,r3
  808e04:	08063b80 	call	8063b8 <glcd_put_string_fixed>
						LocQue.PRINT_STRING.COLOR,LocQue.PRINT_STRING.FONT_SIZE);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING_ADA){
  808e08:	e0bffb0b 	ldhu	r2,-20(fp)
  808e0c:	10bfffcc 	andi	r2,r2,65535
  808e10:	10904018 	cmpnei	r2,r2,16640
  808e14:	10000f1e 	bne	r2,zero,808e54 <task_disp+0x2b0>
				glcd_put_string_Adafruit(LocQue.PRINT_STRING_ADA.XS,LocQue.PRINT_STRING_ADA.YS,LocQue.PRINT_STRING_ADA.str,
  808e18:	e0bffc8b 	ldhu	r2,-14(fp)
  808e1c:	10ffffcc 	andi	r3,r2,65535
  808e20:	e0bffd0b 	ldhu	r2,-12(fp)
  808e24:	113fffcc 	andi	r4,r2,65535
  808e28:	e17ffe17 	ldw	r5,-8(fp)
												LocQue.PRINT_STRING_ADA.COLOR,LocQue.PRINT_STRING_ADA.FONT_SEL);
  808e2c:	e0bffb8b 	ldhu	r2,-18(fp)
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING){
				glcd_put_string_fixed(LocQue.PRINT_STRING.XS,LocQue.PRINT_STRING.YS,LocQue.PRINT_STRING.str,
						LocQue.PRINT_STRING.COLOR,LocQue.PRINT_STRING.FONT_SIZE);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING_ADA){
				glcd_put_string_Adafruit(LocQue.PRINT_STRING_ADA.XS,LocQue.PRINT_STRING_ADA.YS,LocQue.PRINT_STRING_ADA.str,
  808e30:	11bfffcc 	andi	r6,r2,65535
												LocQue.PRINT_STRING_ADA.COLOR,LocQue.PRINT_STRING_ADA.FONT_SEL);
  808e34:	e0bffd8b 	ldhu	r2,-10(fp)
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING){
				glcd_put_string_fixed(LocQue.PRINT_STRING.XS,LocQue.PRINT_STRING.YS,LocQue.PRINT_STRING.str,
						LocQue.PRINT_STRING.COLOR,LocQue.PRINT_STRING.FONT_SIZE);
			}
			if(LocQue.data[0]==GLCDCMD_PRINT_STRING_ADA){
				glcd_put_string_Adafruit(LocQue.PRINT_STRING_ADA.XS,LocQue.PRINT_STRING_ADA.YS,LocQue.PRINT_STRING_ADA.str,
  808e38:	10bfffcc 	andi	r2,r2,65535
  808e3c:	d8800015 	stw	r2,0(sp)
  808e40:	300f883a 	mov	r7,r6
  808e44:	280d883a 	mov	r6,r5
  808e48:	200b883a 	mov	r5,r4
  808e4c:	1809883a 	mov	r4,r3
  808e50:	08069480 	call	806948 <glcd_put_string_Adafruit>
												LocQue.PRINT_STRING_ADA.COLOR,LocQue.PRINT_STRING_ADA.FONT_SEL);

			}
			if(LocQue.data[0]==GLCDCMD_BITBLT){
  808e54:	e0bffb0b 	ldhu	r2,-20(fp)
  808e58:	10bfffcc 	andi	r2,r2,65535
  808e5c:	108c0018 	cmpnei	r2,r2,12288
  808e60:	10000f1e 	bne	r2,zero,808ea0 <task_disp+0x2fc>
				glcd_BitBLT(LocQue.BITBLT.XS,LocQue.BITBLT.YS, LocQue.BITBLT.XE,LocQue.BITBLT.YE,LocQue.BITBLT.src);
  808e64:	e0bffb8b 	ldhu	r2,-18(fp)
  808e68:	10ffffcc 	andi	r3,r2,65535
  808e6c:	e0bffc0b 	ldhu	r2,-16(fp)
  808e70:	113fffcc 	andi	r4,r2,65535
  808e74:	e0bffc8b 	ldhu	r2,-14(fp)
  808e78:	117fffcc 	andi	r5,r2,65535
  808e7c:	e0bffd0b 	ldhu	r2,-12(fp)
  808e80:	11bfffcc 	andi	r6,r2,65535
  808e84:	e0bffe17 	ldw	r2,-8(fp)
  808e88:	d8800015 	stw	r2,0(sp)
  808e8c:	300f883a 	mov	r7,r6
  808e90:	280d883a 	mov	r6,r5
  808e94:	200b883a 	mov	r5,r4
  808e98:	1809883a 	mov	r4,r3
  808e9c:	08060bc0 	call	8060bc <glcd_BitBLT>
			}
			if(	LocQue.data[0]==GLCDCMD_DEBUGLOG){	//
  808ea0:	e0bffb0b 	ldhu	r2,-20(fp)
  808ea4:	10ffffcc 	andi	r3,r2,65535
  808ea8:	00a00014 	movui	r2,32768
  808eac:	1880061e 	bne	r3,r2,808ec8 <task_disp+0x324>
				disp_debug_str( LocQue.DEBUG_LOG.COLOR,LocQue.DEBUG_LOG.pSTR);
  808eb0:	e0bffb8b 	ldhu	r2,-18(fp)
  808eb4:	10bfffcc 	andi	r2,r2,65535
  808eb8:	e0fffc17 	ldw	r3,-16(fp)
  808ebc:	180b883a 	mov	r5,r3
  808ec0:	1009883a 	mov	r4,r2
  808ec4:	0808b040 	call	808b04 <disp_debug_str>
			}
		}
#endif


	vTaskDelay( 1/portTICK_PERIOD_MS);
  808ec8:	01000044 	movi	r4,1
  808ecc:	08023680 	call	802368 <vTaskDelay>
  }
  808ed0:	003f3d06 	br	808bc8 <__alt_data_end+0xfff08bc8>

00808ed4 <task_main>:
volatile int IFSTS;
GRAP_LCD_QUE	QUE_GLCD_LOCAL;


void task_main(void *pvParameters )
{
  808ed4:	defffc04 	addi	sp,sp,-16
  808ed8:	dfc00315 	stw	ra,12(sp)
  808edc:	df000215 	stw	fp,8(sp)
  808ee0:	df000204 	addi	fp,sp,8
  808ee4:	e13fff15 	stw	r4,-4(fp)
	char BUTTON_STS;
	int flag;
	portBASE_TYPE result;

	RspBuf.stx='(';
  808ee8:	008020f4 	movhi	r2,131
  808eec:	10adcb84 	addi	r2,r2,-18642
  808ef0:	00c00a04 	movi	r3,40
  808ef4:	10c00005 	stb	r3,0(r2)
	RspBuf.etx=')';
  808ef8:	008020f4 	movhi	r2,131
  808efc:	10adcb84 	addi	r2,r2,-18642
  808f00:	00c00a44 	movi	r3,41
  808f04:	10c00245 	stb	r3,9(r2)
//		if (result==pdTRUE){
//			debug_print(RGB565_WHITE,"button pushed");
//		}
		//R}h`FbN

		flag = HostStsChk();
  808f08:	08073b00 	call	8073b0 <HostStsChk>
  808f0c:	e0bffe15 	stw	r2,-8(fp)
		if(flag!=0){
  808f10:	e0bffe17 	ldw	r2,-8(fp)
  808f14:	10004726 	beq	r2,zero,809034 <task_main+0x160>
			flag = CommandChk(&IFSTS);
  808f18:	d1203a04 	addi	r4,gp,-32536
  808f1c:	080746c0 	call	80746c <CommandChk>
  808f20:	e0bffe15 	stw	r2,-8(fp)
			if(flag==0){	//LR}h
  808f24:	e0bffe17 	ldw	r2,-8(fp)
  808f28:	1000021e 	bne	r2,zero,808f34 <task_main+0x60>
				Execute();
  808f2c:	08077fc0 	call	8077fc <Execute>
  808f30:	00004006 	br	809034 <task_main+0x160>
			}
			else{	//LR}h
				RspBuf.command=CmdBuf.command;
  808f34:	008020f4 	movhi	r2,131
  808f38:	10adc904 	addi	r2,r2,-18652
  808f3c:	10c00043 	ldbu	r3,1(r2)
  808f40:	008020f4 	movhi	r2,131
  808f44:	10adcb84 	addi	r2,r2,-18642
  808f48:	10c00045 	stb	r3,1(r2)
				RspBuf.sub_command=CmdBuf.sub_command;
  808f4c:	008020f4 	movhi	r2,131
  808f50:	10adc904 	addi	r2,r2,-18652
  808f54:	10c00083 	ldbu	r3,2(r2)
  808f58:	008020f4 	movhi	r2,131
  808f5c:	10adcb84 	addi	r2,r2,-18642
  808f60:	10c00085 	stb	r3,2(r2)


				if (flag==-1){
  808f64:	e0bffe17 	ldw	r2,-8(fp)
  808f68:	10bfffd8 	cmpnei	r2,r2,-1
  808f6c:	1000091e 	bne	r2,zero,808f94 <task_main+0xc0>
					RspBuf.param[0]='c';
  808f70:	008020f4 	movhi	r2,131
  808f74:	10adcb84 	addi	r2,r2,-18642
  808f78:	00c018c4 	movi	r3,99
  808f7c:	10c000c5 	stb	r3,3(r2)
					RspBuf.param[1]='e';
  808f80:	008020f4 	movhi	r2,131
  808f84:	10adcb84 	addi	r2,r2,-18642
  808f88:	00c01944 	movi	r3,101
  808f8c:	10c00105 	stb	r3,4(r2)
  808f90:	00001406 	br	808fe4 <task_main+0x110>
				}
				else if (flag==-2){
  808f94:	e0bffe17 	ldw	r2,-8(fp)
  808f98:	10bfff98 	cmpnei	r2,r2,-2
  808f9c:	1000091e 	bne	r2,zero,808fc4 <task_main+0xf0>
					RspBuf.param[0]='p';
  808fa0:	008020f4 	movhi	r2,131
  808fa4:	10adcb84 	addi	r2,r2,-18642
  808fa8:	00c01c04 	movi	r3,112
  808fac:	10c000c5 	stb	r3,3(r2)
					RspBuf.param[1]='e';
  808fb0:	008020f4 	movhi	r2,131
  808fb4:	10adcb84 	addi	r2,r2,-18642
  808fb8:	00c01944 	movi	r3,101
  808fbc:	10c00105 	stb	r3,4(r2)
  808fc0:	00000806 	br	808fe4 <task_main+0x110>
				}
				else{
					RspBuf.param[0]='?';
  808fc4:	008020f4 	movhi	r2,131
  808fc8:	10adcb84 	addi	r2,r2,-18642
  808fcc:	00c00fc4 	movi	r3,63
  808fd0:	10c000c5 	stb	r3,3(r2)
					RspBuf.param[1]='?';
  808fd4:	008020f4 	movhi	r2,131
  808fd8:	10adcb84 	addi	r2,r2,-18642
  808fdc:	00c00fc4 	movi	r3,63
  808fe0:	10c00105 	stb	r3,4(r2)
				}
				RspBuf.param[2]='0';
  808fe4:	008020f4 	movhi	r2,131
  808fe8:	10adcb84 	addi	r2,r2,-18642
  808fec:	00c00c04 	movi	r3,48
  808ff0:	10c00145 	stb	r3,5(r2)
				RspBuf.param[3]='0';
  808ff4:	008020f4 	movhi	r2,131
  808ff8:	10adcb84 	addi	r2,r2,-18642
  808ffc:	00c00c04 	movi	r3,48
  809000:	10c00185 	stb	r3,6(r2)
				RspBuf.param[4]='0';
  809004:	008020f4 	movhi	r2,131
  809008:	10adcb84 	addi	r2,r2,-18642
  80900c:	00c00c04 	movi	r3,48
  809010:	10c001c5 	stb	r3,7(r2)
				RspBuf.param[5]='0';
  809014:	008020f4 	movhi	r2,131
  809018:	10adcb84 	addi	r2,r2,-18642
  80901c:	00c00c04 	movi	r3,48
  809020:	10c00205 	stb	r3,8(r2)
				FT245_SendBlock((char *)&RspBuf,10);
  809024:	01400284 	movi	r5,10
  809028:	010020f4 	movhi	r4,131
  80902c:	212dcb84 	addi	r4,r4,-18642
  809030:	0805b580 	call	805b58 <FT245_SendBlock>
			}
		}
		vTaskDelay( 1/ portTICK_PERIOD_MS);
  809034:	01000044 	movi	r4,1
  809038:	08023680 	call	802368 <vTaskDelay>
	}
  80903c:	003fb206 	br	808f08 <__alt_data_end+0xfff08f08>

00809040 <task_sns>:
volatile int sample_block;

int SnsCtrlSTS;


void task_sns(void *pvParameters ){
  809040:	defff704 	addi	sp,sp,-36
  809044:	dfc00815 	stw	ra,32(sp)
  809048:	df000715 	stw	fp,28(sp)
  80904c:	df000704 	addi	fp,sp,28
  809050:	e13fff15 	stw	r4,-4(fp)

	PDMMIC_MOD *pPDM =(PDMMIC_MOD *)PDM_BASE;
  809054:	00900004 	movi	r2,16384
  809058:	e0bffa15 	stw	r2,-24(fp)
	int flag;
	portBASE_TYPE result;
	int localSnsQue;


	vTaskDelay( 1000/portTICK_PERIOD_MS);
  80905c:	0100fa04 	movi	r4,1000
  809060:	08023680 	call	802368 <vTaskDelay>

	init_PDM();
  809064:	0807e7c0 	call	807e7c <init_PDM>
	setMicGain(5);	//default
  809068:	01000144 	movi	r4,5
  80906c:	08085840 	call	808584 <setMicGain>

debug_print(RGB565_CYAN,"Mic caribration start");
  809070:	014020b4 	movhi	r5,130
  809074:	2966c904 	addi	r5,r5,-25820
  809078:	0101ffc4 	movi	r4,2047
  80907c:	0806cb80 	call	806cb8 <debug_print>


	flag = MicCarivration();	//cansel Mic offset level
  809080:	08081d00 	call	8081d0 <MicCarivration>
  809084:	e0bffb15 	stw	r2,-20(fp)
	if (flag==0){
  809088:	e0bffb17 	ldw	r2,-20(fp)
  80908c:	1000051e 	bne	r2,zero,8090a4 <task_sns+0x64>
		debug_print(RGB565_CYAN,"Mic caribration end");
  809090:	014020b4 	movhi	r5,130
  809094:	2966cf04 	addi	r5,r5,-25796
  809098:	0101ffc4 	movi	r4,2047
  80909c:	0806cb80 	call	806cb8 <debug_print>
  8090a0:	00000406 	br	8090b4 <task_sns+0x74>
	}else{
		debug_print(RGB565_CYAN,"Mic caribration ERROR");
  8090a4:	014020b4 	movhi	r5,130
  8090a8:	2966d404 	addi	r5,r5,-25776
  8090ac:	0101ffc4 	movi	r4,2047
  8090b0:	0806cb80 	call	806cb8 <debug_print>
	}

	sample_count = 0;
  8090b4:	e03ffc15 	stw	zero,-16(fp)
	sample_block = 0;
  8090b8:	d0203b15 	stw	zero,-32532(gp)
	acq_flag = 0;
  8090bc:	e03ff915 	stw	zero,-28(fp)

	for(;;){
		//button push? (start/stop)
		result = xQueueReceive(SnsorQue,&localSnsQue,1);
  8090c0:	d0a03517 	ldw	r2,-32556(gp)
  8090c4:	e0fffe04 	addi	r3,fp,-8
  8090c8:	000f883a 	mov	r7,zero
  8090cc:	01800044 	movi	r6,1
  8090d0:	180b883a 	mov	r5,r3
  8090d4:	1009883a 	mov	r4,r2
  8090d8:	08014f00 	call	8014f0 <xQueueGenericReceive>
  8090dc:	e0bffd15 	stw	r2,-12(fp)
		if(result==pdTRUE){
  8090e0:	e0bffd17 	ldw	r2,-12(fp)
  8090e4:	10800058 	cmpnei	r2,r2,1
  8090e8:	1000381e 	bne	r2,zero,8091cc <task_sns+0x18c>
			if (localSnsQue == SnsQue_INIT){
  8090ec:	e0bffe17 	ldw	r2,-8(fp)
  8090f0:	10001b1e 	bne	r2,zero,809160 <task_sns+0x120>
				sample_count = 0;
  8090f4:	e03ffc15 	stw	zero,-16(fp)
				sample_block = 0;
  8090f8:	d0203b15 	stw	zero,-32532(gp)
				acq_flag = 0;
  8090fc:	e03ff915 	stw	zero,-28(fp)

				SnsCtrlSTS = SnsSTS_BUSY;
  809100:	00800044 	movi	r2,1
  809104:	d0a03c15 	stw	r2,-32528(gp)
				init_PDM();
  809108:	0807e7c0 	call	807e7c <init_PDM>
debug_print(RGB565_CYAN,"Mic caribration start");
  80910c:	014020b4 	movhi	r5,130
  809110:	2966c904 	addi	r5,r5,-25820
  809114:	0101ffc4 	movi	r4,2047
  809118:	0806cb80 	call	806cb8 <debug_print>
				flag = MicCarivration();	//cansel Mic offset level
  80911c:	08081d00 	call	8081d0 <MicCarivration>
  809120:	e0bffb15 	stw	r2,-20(fp)
				if (flag== 0){
  809124:	e0bffb17 	ldw	r2,-20(fp)
  809128:	1000061e 	bne	r2,zero,809144 <task_sns+0x104>
debug_print(RGB565_CYAN,"Mic caribration end");
  80912c:	014020b4 	movhi	r5,130
  809130:	2966cf04 	addi	r5,r5,-25796
  809134:	0101ffc4 	movi	r4,2047
  809138:	0806cb80 	call	806cb8 <debug_print>
					SnsCtrlSTS = SnsSTS_IDLE;
  80913c:	d0203c15 	stw	zero,-32528(gp)
  809140:	00002206 	br	8091cc <task_sns+0x18c>
				}
				else{
					SnsCtrlSTS = SnsSTS_ERROR;
  809144:	00800084 	movi	r2,2
  809148:	d0a03c15 	stw	r2,-32528(gp)
debug_print(RGB565_RED,"Mic caribration err");
  80914c:	014020b4 	movhi	r5,130
  809150:	2966da04 	addi	r5,r5,-25752
  809154:	013e0014 	movui	r4,63488
  809158:	0806cb80 	call	806cb8 <debug_print>
  80915c:	00001b06 	br	8091cc <task_sns+0x18c>
				}
			}
			else if (localSnsQue == SnsQue_START){
  809160:	e0bffe17 	ldw	r2,-8(fp)
  809164:	10800058 	cmpnei	r2,r2,1
  809168:	10000c1e 	bne	r2,zero,80919c <task_sns+0x15c>
				sample_count = 0;
  80916c:	e03ffc15 	stw	zero,-16(fp)
				sample_block = 0;
  809170:	d0203b15 	stw	zero,-32532(gp)
				acq_flag = 1;
  809174:	00800044 	movi	r2,1
  809178:	e0bff915 	stw	r2,-28(fp)
				SnsCtrlSTS= SnsSTS_BUSY;
  80917c:	00800044 	movi	r2,1
  809180:	d0a03c15 	stw	r2,-32528(gp)
debug_print(RGB565_YELLOW,"Record start");
  809184:	014020b4 	movhi	r5,130
  809188:	2966df04 	addi	r5,r5,-25732
  80918c:	013ff814 	movui	r4,65504
  809190:	0806cb80 	call	806cb8 <debug_print>
				enable_PDM();	//sample start
  809194:	0807ee40 	call	807ee4 <enable_PDM>
  809198:	00000c06 	br	8091cc <task_sns+0x18c>

			}
			else if (localSnsQue == SnsQue_STOP){
  80919c:	e0bffe17 	ldw	r2,-8(fp)
  8091a0:	10800098 	cmpnei	r2,r2,2
  8091a4:	1000091e 	bne	r2,zero,8091cc <task_sns+0x18c>
debug_print(RGB565_YELLOW,"Record end");
  8091a8:	014020b4 	movhi	r5,130
  8091ac:	2966e304 	addi	r5,r5,-25716
  8091b0:	013ff814 	movui	r4,65504
  8091b4:	0806cb80 	call	806cb8 <debug_print>
				disable_PDM();	//sample stop
  8091b8:	0807f1c0 	call	807f1c <disable_PDM>
				SnsCtrlSTS= SnsSTS_IDLE;
  8091bc:	d0203c15 	stw	zero,-32528(gp)
				sample_count = 0;
  8091c0:	e03ffc15 	stw	zero,-16(fp)
				sample_block = 0;
  8091c4:	d0203b15 	stw	zero,-32532(gp)
				acq_flag=0;
  8091c8:	e03ff915 	stw	zero,-28(fp)
			}else{
			}
		}

		if(acq_flag==1){	// in acquision
  8091cc:	e0bff917 	ldw	r2,-28(fp)
  8091d0:	10800058 	cmpnei	r2,r2,1
  8091d4:	1000081e 	bne	r2,zero,8091f8 <task_sns+0x1b8>
			sample_count = pPDM->SmpleCountReg;
  8091d8:	e0bffa17 	ldw	r2,-24(fp)
  8091dc:	10820217 	ldw	r2,2056(r2)
  8091e0:	e0bffc15 	stw	r2,-16(fp)
			sample_block = sample_count/COM_BLK_SIZE;
  8091e4:	e0bffc17 	ldw	r2,-16(fp)
  8091e8:	1000010e 	bge	r2,zero,8091f0 <task_sns+0x1b0>
  8091ec:	1081ffc4 	addi	r2,r2,2047
  8091f0:	1005d2fa 	srai	r2,r2,11
  8091f4:	d0a03b15 	stw	r2,-32532(gp)
		}
		vTaskDelay( 1/portTICK_PERIOD_MS);
  8091f8:	01000044 	movi	r4,1
  8091fc:	08023680 	call	802368 <vTaskDelay>
	}
  809200:	003faf06 	br	8090c0 <__alt_data_end+0xfff090c0>

00809204 <plotPoint>:
//         3: CH3
//         4: CH4
//
//
//
int plotPoint(DISP_BUF *pDISPBUF,int x,int y,uint16_t color){
  809204:	defffb04 	addi	sp,sp,-20
  809208:	df000415 	stw	fp,16(sp)
  80920c:	df000404 	addi	fp,sp,16
  809210:	e13ffc15 	stw	r4,-16(fp)
  809214:	e17ffd15 	stw	r5,-12(fp)
  809218:	e1bffe15 	stw	r6,-8(fp)
  80921c:	3805883a 	mov	r2,r7
  809220:	e0bfff0d 	sth	r2,-4(fp)

	if( (x>=0) && (x<=256) && (y>=0) && (y<=199)){
  809224:	e0bffd17 	ldw	r2,-12(fp)
  809228:	10001316 	blt	r2,zero,809278 <plotPoint+0x74>
  80922c:	e0bffd17 	ldw	r2,-12(fp)
  809230:	10804048 	cmpgei	r2,r2,257
  809234:	1000101e 	bne	r2,zero,809278 <plotPoint+0x74>
  809238:	e0bffe17 	ldw	r2,-8(fp)
  80923c:	10000e16 	blt	r2,zero,809278 <plotPoint+0x74>
  809240:	e0bffe17 	ldw	r2,-8(fp)
  809244:	10803208 	cmpgei	r2,r2,200
  809248:	10000b1e 	bne	r2,zero,809278 <plotPoint+0x74>
		pDISPBUF->BMP[y][x] = color;
  80924c:	e0fffc17 	ldw	r3,-16(fp)
  809250:	e0bffe17 	ldw	r2,-8(fp)
  809254:	1008923a 	slli	r4,r2,8
  809258:	e0bffd17 	ldw	r2,-12(fp)
  80925c:	2085883a 	add	r2,r4,r2
  809260:	1085883a 	add	r2,r2,r2
  809264:	1885883a 	add	r2,r3,r2
  809268:	e0ffff0b 	ldhu	r3,-4(fp)
  80926c:	10c0000d 	sth	r3,0(r2)
		return 0;
  809270:	0005883a 	mov	r2,zero
  809274:	00000106 	br	80927c <plotPoint+0x78>
	}
	return -1;
  809278:	00bfffc4 	movi	r2,-1
}
  80927c:	e037883a 	mov	sp,fp
  809280:	df000017 	ldw	fp,0(sp)
  809284:	dec00104 	addi	sp,sp,4
  809288:	f800283a 	ret

0080928c <DispWaveImg>:



int DispWaveImg(DISP_BUF *pDISPBUF,int mode,int Vscale,int Hscale){
  80928c:	deffec04 	addi	sp,sp,-80
  809290:	dfc01315 	stw	ra,76(sp)
  809294:	df001215 	stw	fp,72(sp)
  809298:	df001204 	addi	fp,sp,72
  80929c:	e13ffc15 	stw	r4,-16(fp)
  8092a0:	e17ffd15 	stw	r5,-12(fp)
  8092a4:	e1bffe15 	stw	r6,-8(fp)
  8092a8:	e1ffff15 	stw	r7,-4(fp)

	int ch;
	volatile int flag;
	uint16_t back_color=RGB565_BLACK;
  8092ac:	e03ffb0d 	sth	zero,-20(fp)
	uint16_t scale_color=RGB565_RED;
  8092b0:	00be0004 	movi	r2,-2048
  8092b4:	e0bffb8d 	sth	r2,-18(fp)
	int HMAX=0;
  8092b8:	e03fef15 	stw	zero,-68(fp)


	int ypos;

	//clear display buffer
	start_LCD_DMA_BufferFill(&back_color,pDISPBUF,200*256*2);
  8092bc:	e0bffb04 	addi	r2,fp,-20
  8092c0:	e0fffc17 	ldw	r3,-16(fp)
  8092c4:	018000b4 	movhi	r6,2
  8092c8:	31a40004 	addi	r6,r6,-28672
  8092cc:	180b883a 	mov	r5,r3
  8092d0:	1009883a 	mov	r4,r2
  8092d4:	08044980 	call	804498 <start_LCD_DMA_BufferFill>
	flag = get_LCD_DMA_sts();
  8092d8:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  8092dc:	e0bffa15 	stw	r2,-24(fp)
	while(flag!=0){
  8092e0:	00000406 	br	8092f4 <DispWaveImg+0x68>
		flag = get_LCD_DMA_sts();
  8092e4:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  8092e8:	e0bffa15 	stw	r2,-24(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  8092ec:	01000044 	movi	r4,1
  8092f0:	08023680 	call	802368 <vTaskDelay>
	int ypos;

	//clear display buffer
	start_LCD_DMA_BufferFill(&back_color,pDISPBUF,200*256*2);
	flag = get_LCD_DMA_sts();
	while(flag!=0){
  8092f4:	e0bffa17 	ldw	r2,-24(fp)
  8092f8:	103ffa1e 	bne	r2,zero,8092e4 <__alt_data_end+0xfff092e4>
		flag = get_LCD_DMA_sts();
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}

	//set Hscale
	HMAX=0;
  8092fc:	e03fef15 	stw	zero,-68(fp)
	switch(Hscale){
  809300:	e0bfff17 	ldw	r2,-4(fp)
  809304:	10800168 	cmpgeui	r2,r2,5
  809308:	10001b1e 	bne	r2,zero,809378 <DispWaveImg+0xec>
  80930c:	e0bfff17 	ldw	r2,-4(fp)
  809310:	100690ba 	slli	r3,r2,2
  809314:	00802074 	movhi	r2,129
  809318:	10a4ca04 	addi	r2,r2,-27864
  80931c:	1885883a 	add	r2,r3,r2
  809320:	10800017 	ldw	r2,0(r2)
  809324:	1000683a 	jmp	r2
  809328:	0080933c 	xorhi	r2,zero,588
  80932c:	00809348 	cmpgei	r2,zero,589
  809330:	00809354 	movui	r2,589
  809334:	00809360 	cmpeqi	r2,zero,589
  809338:	0080936c 	andhi	r2,zero,589
	case 0:	HMAX=4096;	break;
  80933c:	00840004 	movi	r2,4096
  809340:	e0bfef15 	stw	r2,-68(fp)
  809344:	00000d06 	br	80937c <DispWaveImg+0xf0>
	case 1:	HMAX=2048;	break;
  809348:	00820004 	movi	r2,2048
  80934c:	e0bfef15 	stw	r2,-68(fp)
  809350:	00000a06 	br	80937c <DispWaveImg+0xf0>
	case 2:	HMAX=1024;	break;
  809354:	00810004 	movi	r2,1024
  809358:	e0bfef15 	stw	r2,-68(fp)
  80935c:	00000706 	br	80937c <DispWaveImg+0xf0>
	case 3:	HMAX=512;	break;
  809360:	00808004 	movi	r2,512
  809364:	e0bfef15 	stw	r2,-68(fp)
  809368:	00000406 	br	80937c <DispWaveImg+0xf0>
	case 4:	HMAX=256;	break;
  80936c:	00804004 	movi	r2,256
  809370:	e0bfef15 	stw	r2,-68(fp)
  809374:	00000106 	br	80937c <DispWaveImg+0xf0>
	default:			break;
  809378:	0001883a 	nop
	}//end  switch(Hscale)
	if(HMAX==0){
  80937c:	e0bfef17 	ldw	r2,-68(fp)
  809380:	1000021e 	bne	r2,zero,80938c <DispWaveImg+0x100>
		return -1;
  809384:	00bfffc4 	movi	r2,-1
  809388:	00009706 	br	8095e8 <DispWaveImg+0x35c>
	}
	tstep=HMAX/256;
  80938c:	e0bfef17 	ldw	r2,-68(fp)
  809390:	1000010e 	bge	r2,zero,809398 <DispWaveImg+0x10c>
  809394:	10803fc4 	addi	r2,r2,255
  809398:	1005d23a 	srai	r2,r2,8
  80939c:	e0bff715 	stw	r2,-36(fp)


	//set Vscale
	Vshift=0;
  8093a0:	e03ff015 	stw	zero,-64(fp)
	switch(Vscale){
  8093a4:	e0bffe17 	ldw	r2,-8(fp)
  8093a8:	10800168 	cmpgeui	r2,r2,5
  8093ac:	10001b1e 	bne	r2,zero,80941c <DispWaveImg+0x190>
  8093b0:	e0bffe17 	ldw	r2,-8(fp)
  8093b4:	100690ba 	slli	r3,r2,2
  8093b8:	00802074 	movhi	r2,129
  8093bc:	10a4f304 	addi	r2,r2,-27700
  8093c0:	1885883a 	add	r2,r3,r2
  8093c4:	10800017 	ldw	r2,0(r2)
  8093c8:	1000683a 	jmp	r2
  8093cc:	008093e0 	cmpeqi	r2,zero,591
  8093d0:	008093ec 	andhi	r2,zero,591
  8093d4:	008093f8 	rdprs	r2,zero,591
  8093d8:	00809404 	movi	r2,592
  8093dc:	00809410 	cmplti	r2,zero,592
	case 0:	Vshift=8;	break;
  8093e0:	00800204 	movi	r2,8
  8093e4:	e0bff015 	stw	r2,-64(fp)
  8093e8:	00000d06 	br	809420 <DispWaveImg+0x194>
	case 1:	Vshift=7;	break;
  8093ec:	008001c4 	movi	r2,7
  8093f0:	e0bff015 	stw	r2,-64(fp)
  8093f4:	00000a06 	br	809420 <DispWaveImg+0x194>
	case 2:	Vshift=6;	break;
  8093f8:	00800184 	movi	r2,6
  8093fc:	e0bff015 	stw	r2,-64(fp)
  809400:	00000706 	br	809420 <DispWaveImg+0x194>
	case 3:	Vshift=5;	break;
  809404:	00800144 	movi	r2,5
  809408:	e0bff015 	stw	r2,-64(fp)
  80940c:	00000406 	br	809420 <DispWaveImg+0x194>
	case 4:	Vshift=4;	break;
  809410:	00800104 	movi	r2,4
  809414:	e0bff015 	stw	r2,-64(fp)
  809418:	00000106 	br	809420 <DispWaveImg+0x194>
	default:			break;
  80941c:	0001883a 	nop
	}//end  switch(Hscale)

	if(Vshift==0){
  809420:	e0bff017 	ldw	r2,-64(fp)
  809424:	1000021e 	bne	r2,zero,809430 <DispWaveImg+0x1a4>
		return -1;
  809428:	00bfffc4 	movi	r2,-1
  80942c:	00006e06 	br	8095e8 <DispWaveImg+0x35c>
	}

	//scale v=0
	start_LCD_DMA_BufferFill( &scale_color, &pDISPBUF->BMP[100][0], 256*2 );
  809430:	e13ffb84 	addi	r4,fp,-18
  809434:	e0fffc17 	ldw	r3,-16(fp)
  809438:	00b20014 	movui	r2,51200
  80943c:	1885883a 	add	r2,r3,r2
  809440:	01808004 	movi	r6,512
  809444:	100b883a 	mov	r5,r2
  809448:	08044980 	call	804498 <start_LCD_DMA_BufferFill>
	flag = get_LCD_DMA_sts();
  80944c:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  809450:	e0bffa15 	stw	r2,-24(fp)
	while(flag!=0){
  809454:	00000406 	br	809468 <DispWaveImg+0x1dc>
		flag = get_LCD_DMA_sts();
  809458:	08042e40 	call	8042e4 <get_LCD_DMA_sts>
  80945c:	e0bffa15 	stw	r2,-24(fp)
		vTaskDelay( 1/portTICK_PERIOD_MS);
  809460:	01000044 	movi	r4,1
  809464:	08023680 	call	802368 <vTaskDelay>
	}

	//scale v=0
	start_LCD_DMA_BufferFill( &scale_color, &pDISPBUF->BMP[100][0], 256*2 );
	flag = get_LCD_DMA_sts();
	while(flag!=0){
  809468:	e0bffa17 	ldw	r2,-24(fp)
  80946c:	103ffa1e 	bne	r2,zero,809458 <__alt_data_end+0xfff09458>
		vTaskDelay( 1/portTICK_PERIOD_MS);
	}

	//plot mic data

	if( 4 == mode){
  809470:	e0bffd17 	ldw	r2,-12(fp)
  809474:	10800118 	cmpnei	r2,r2,4
  809478:	1000041e 	bne	r2,zero,80948c <DispWaveImg+0x200>
		StrtCh=0;
  80947c:	e03ff215 	stw	zero,-56(fp)
		EndCh=4;
  809480:	00800104 	movi	r2,4
  809484:	e0bff315 	stw	r2,-52(fp)
  809488:	00000506 	br	8094a0 <DispWaveImg+0x214>
	}
	else{
		StrtCh=mode;
  80948c:	e0bffd17 	ldw	r2,-12(fp)
  809490:	e0bff215 	stw	r2,-56(fp)
		EndCh=mode+1;
  809494:	e0bffd17 	ldw	r2,-12(fp)
  809498:	10800044 	addi	r2,r2,1
  80949c:	e0bff315 	stw	r2,-52(fp)
	}

	for(ch=StrtCh; ch<EndCh ;ch++){
  8094a0:	e0bff217 	ldw	r2,-56(fp)
  8094a4:	e0bfee15 	stw	r2,-72(fp)
  8094a8:	00004b06 	br	8095d8 <DispWaveImg+0x34c>
		switch(ch){
  8094ac:	e0bfee17 	ldw	r2,-72(fp)
  8094b0:	10c00060 	cmpeqi	r3,r2,1
  8094b4:	18000c1e 	bne	r3,zero,8094e8 <DispWaveImg+0x25c>
  8094b8:	10c00088 	cmpgei	r3,r2,2
  8094bc:	1800021e 	bne	r3,zero,8094c8 <DispWaveImg+0x23c>
  8094c0:	10000626 	beq	r2,zero,8094dc <DispWaveImg+0x250>
  8094c4:	00001106 	br	80950c <DispWaveImg+0x280>
  8094c8:	10c000a0 	cmpeqi	r3,r2,2
  8094cc:	1800091e 	bne	r3,zero,8094f4 <DispWaveImg+0x268>
  8094d0:	108000e0 	cmpeqi	r2,r2,3
  8094d4:	10000a1e 	bne	r2,zero,809500 <DispWaveImg+0x274>
  8094d8:	00000c06 	br	80950c <DispWaveImg+0x280>
			case 0:DotColor = RGB565_YELLOW;break;
  8094dc:	00bff804 	movi	r2,-32
  8094e0:	e0bff10d 	sth	r2,-60(fp)
  8094e4:	00000c06 	br	809518 <DispWaveImg+0x28c>
			case 1:DotColor = RGB565_CYAN;break;
  8094e8:	0081ffc4 	movi	r2,2047
  8094ec:	e0bff10d 	sth	r2,-60(fp)
  8094f0:	00000906 	br	809518 <DispWaveImg+0x28c>
			case 2:DotColor = RGB565_MAGENTA;break;
  8094f4:	00be07c4 	movi	r2,-2017
  8094f8:	e0bff10d 	sth	r2,-60(fp)
  8094fc:	00000606 	br	809518 <DispWaveImg+0x28c>
			case 3:DotColor = RGB565_GREEN;break;
  809500:	0081f804 	movi	r2,2016
  809504:	e0bff10d 	sth	r2,-60(fp)
  809508:	00000306 	br	809518 <DispWaveImg+0x28c>
			default:DotColor = RGB565_WHITE;break;
  80950c:	00bfffc4 	movi	r2,-1
  809510:	e0bff10d 	sth	r2,-60(fp)
  809514:	0001883a 	nop
		}
		for(int i=0,tpos=0,tsub=0;i<HMAX;i++){
  809518:	e03ff415 	stw	zero,-48(fp)
  80951c:	e03ff515 	stw	zero,-44(fp)
  809520:	e03ff615 	stw	zero,-40(fp)
  809524:	00002606 	br	8095c0 <DispWaveImg+0x334>
			mic_data=pPDMDATA->Data[ch][i];
  809528:	d0e00f17 	ldw	r3,-32708(gp)
  80952c:	e0bfee17 	ldw	r2,-72(fp)
  809530:	100894ba 	slli	r4,r2,18
  809534:	e0bff417 	ldw	r2,-48(fp)
  809538:	2085883a 	add	r2,r4,r2
  80953c:	1085883a 	add	r2,r2,r2
  809540:	1885883a 	add	r2,r3,r2
  809544:	1080000b 	ldhu	r2,0(r2)
  809548:	e0bff80d 	sth	r2,-32(fp)
			mic_data = mic_data>>Vshift;
  80954c:	e0fff80f 	ldh	r3,-32(fp)
  809550:	e0bff017 	ldw	r2,-64(fp)
  809554:	1885d83a 	sra	r2,r3,r2
  809558:	e0bff80d 	sth	r2,-32(fp)
			ypos= 100 - mic_data;
  80955c:	e0bff80f 	ldh	r2,-32(fp)
  809560:	00c01904 	movi	r3,100
  809564:	1885c83a 	sub	r2,r3,r2
  809568:	e0bff915 	stw	r2,-28(fp)
			plotPoint(pDISPBUF,tpos,ypos,DotColor);
  80956c:	e0bff10b 	ldhu	r2,-60(fp)
  809570:	100f883a 	mov	r7,r2
  809574:	e1bff917 	ldw	r6,-28(fp)
  809578:	e17ff517 	ldw	r5,-44(fp)
  80957c:	e13ffc17 	ldw	r4,-16(fp)
  809580:	08092040 	call	809204 <plotPoint>

			if(tsub==tstep-1){
  809584:	e0bff717 	ldw	r2,-36(fp)
  809588:	10ffffc4 	addi	r3,r2,-1
  80958c:	e0bff617 	ldw	r2,-40(fp)
  809590:	1880051e 	bne	r3,r2,8095a8 <DispWaveImg+0x31c>
				tpos++;
  809594:	e0bff517 	ldw	r2,-44(fp)
  809598:	10800044 	addi	r2,r2,1
  80959c:	e0bff515 	stw	r2,-44(fp)
				tsub=0;
  8095a0:	e03ff615 	stw	zero,-40(fp)
  8095a4:	00000306 	br	8095b4 <DispWaveImg+0x328>
			}
			else{
				tsub++;
  8095a8:	e0bff617 	ldw	r2,-40(fp)
  8095ac:	10800044 	addi	r2,r2,1
  8095b0:	e0bff615 	stw	r2,-40(fp)
			case 1:DotColor = RGB565_CYAN;break;
			case 2:DotColor = RGB565_MAGENTA;break;
			case 3:DotColor = RGB565_GREEN;break;
			default:DotColor = RGB565_WHITE;break;
		}
		for(int i=0,tpos=0,tsub=0;i<HMAX;i++){
  8095b4:	e0bff417 	ldw	r2,-48(fp)
  8095b8:	10800044 	addi	r2,r2,1
  8095bc:	e0bff415 	stw	r2,-48(fp)
  8095c0:	e0fff417 	ldw	r3,-48(fp)
  8095c4:	e0bfef17 	ldw	r2,-68(fp)
  8095c8:	18bfd716 	blt	r3,r2,809528 <__alt_data_end+0xfff09528>
	else{
		StrtCh=mode;
		EndCh=mode+1;
	}

	for(ch=StrtCh; ch<EndCh ;ch++){
  8095cc:	e0bfee17 	ldw	r2,-72(fp)
  8095d0:	10800044 	addi	r2,r2,1
  8095d4:	e0bfee15 	stw	r2,-72(fp)
  8095d8:	e0ffee17 	ldw	r3,-72(fp)
  8095dc:	e0bff317 	ldw	r2,-52(fp)
  8095e0:	18bfb216 	blt	r3,r2,8094ac <__alt_data_end+0xfff094ac>
			else{
				tsub++;
			}
		}
	}
	return 0;
  8095e4:	0005883a 	mov	r2,zero
}
  8095e8:	e037883a 	mov	sp,fp
  8095ec:	dfc00117 	ldw	ra,4(sp)
  8095f0:	df000017 	ldw	fp,0(sp)
  8095f4:	dec00204 	addi	sp,sp,8
  8095f8:	f800283a 	ret

008095fc <pow>:
  8095fc:	deffee04 	addi	sp,sp,-72
  809600:	dc800b15 	stw	r18,44(sp)
  809604:	048020b4 	movhi	r18,130
  809608:	ddc01015 	stw	r23,64(sp)
  80960c:	dd800f15 	stw	r22,60(sp)
  809610:	dd400e15 	stw	r21,56(sp)
  809614:	dd000d15 	stw	r20,52(sp)
  809618:	dcc00c15 	stw	r19,48(sp)
  80961c:	dc400a15 	stw	r17,40(sp)
  809620:	dc000915 	stw	r16,36(sp)
  809624:	dfc01115 	stw	ra,68(sp)
  809628:	94ad4804 	addi	r18,r18,-19168
  80962c:	202f883a 	mov	r23,r4
  809630:	282d883a 	mov	r22,r5
  809634:	302b883a 	mov	r21,r6
  809638:	3829883a 	mov	r20,r7
  80963c:	0809ac00 	call	809ac0 <__ieee754_pow>
  809640:	1023883a 	mov	r17,r2
  809644:	90800017 	ldw	r2,0(r18)
  809648:	04ffffc4 	movi	r19,-1
  80964c:	1821883a 	mov	r16,r3
  809650:	14c00426 	beq	r2,r19,809664 <pow+0x68>
  809654:	a809883a 	mov	r4,r21
  809658:	a00b883a 	mov	r5,r20
  80965c:	080ae1c0 	call	80ae1c <__fpclassifyd>
  809660:	10000d1e 	bne	r2,zero,809698 <pow+0x9c>
  809664:	8805883a 	mov	r2,r17
  809668:	8007883a 	mov	r3,r16
  80966c:	dfc01117 	ldw	ra,68(sp)
  809670:	ddc01017 	ldw	r23,64(sp)
  809674:	dd800f17 	ldw	r22,60(sp)
  809678:	dd400e17 	ldw	r21,56(sp)
  80967c:	dd000d17 	ldw	r20,52(sp)
  809680:	dcc00c17 	ldw	r19,48(sp)
  809684:	dc800b17 	ldw	r18,44(sp)
  809688:	dc400a17 	ldw	r17,40(sp)
  80968c:	dc000917 	ldw	r16,36(sp)
  809690:	dec01204 	addi	sp,sp,72
  809694:	f800283a 	ret
  809698:	b809883a 	mov	r4,r23
  80969c:	b00b883a 	mov	r5,r22
  8096a0:	080ae1c0 	call	80ae1c <__fpclassifyd>
  8096a4:	000d883a 	mov	r6,zero
  8096a8:	000f883a 	mov	r7,zero
  8096ac:	1000201e 	bne	r2,zero,809730 <pow+0x134>
  8096b0:	a809883a 	mov	r4,r21
  8096b4:	a00b883a 	mov	r5,r20
  8096b8:	080da480 	call	80da48 <__eqdf2>
  8096bc:	103fe91e 	bne	r2,zero,809664 <__alt_data_end+0xfff09664>
  8096c0:	01000044 	movi	r4,1
  8096c4:	d9000015 	stw	r4,0(sp)
  8096c8:	90800017 	ldw	r2,0(r18)
  8096cc:	010020b4 	movhi	r4,130
  8096d0:	00cffc34 	movhi	r3,16368
  8096d4:	2126e604 	addi	r4,r4,-25704
  8096d8:	d9000115 	stw	r4,4(sp)
  8096dc:	d8000815 	stw	zero,32(sp)
  8096e0:	ddc00215 	stw	r23,8(sp)
  8096e4:	dd800315 	stw	r22,12(sp)
  8096e8:	dd400415 	stw	r21,16(sp)
  8096ec:	dd000515 	stw	r20,20(sp)
  8096f0:	d8000615 	stw	zero,24(sp)
  8096f4:	d8c00715 	stw	r3,28(sp)
  8096f8:	14c02826 	beq	r2,r19,80979c <pow+0x1a0>
  8096fc:	01000084 	movi	r4,2
  809700:	11002626 	beq	r2,r4,80979c <pow+0x1a0>
  809704:	d809883a 	mov	r4,sp
  809708:	080ae900 	call	80ae90 <matherr>
  80970c:	10006b26 	beq	r2,zero,8098bc <pow+0x2c0>
  809710:	d8800817 	ldw	r2,32(sp)
  809714:	10000326 	beq	r2,zero,809724 <pow+0x128>
  809718:	080f4340 	call	80f434 <__errno>
  80971c:	d8c00817 	ldw	r3,32(sp)
  809720:	10c00015 	stw	r3,0(r2)
  809724:	d8800617 	ldw	r2,24(sp)
  809728:	d8c00717 	ldw	r3,28(sp)
  80972c:	003fcf06 	br	80966c <__alt_data_end+0xfff0966c>
  809730:	b809883a 	mov	r4,r23
  809734:	b00b883a 	mov	r5,r22
  809738:	080da480 	call	80da48 <__eqdf2>
  80973c:	1000191e 	bne	r2,zero,8097a4 <pow+0x1a8>
  809740:	000d883a 	mov	r6,zero
  809744:	000f883a 	mov	r7,zero
  809748:	a809883a 	mov	r4,r21
  80974c:	a00b883a 	mov	r5,r20
  809750:	080da480 	call	80da48 <__eqdf2>
  809754:	10003a1e 	bne	r2,zero,809840 <pow+0x244>
  809758:	00c00044 	movi	r3,1
  80975c:	d8c00015 	stw	r3,0(sp)
  809760:	90800017 	ldw	r2,0(r18)
  809764:	00c020b4 	movhi	r3,130
  809768:	18e6e604 	addi	r3,r3,-25704
  80976c:	d8c00115 	stw	r3,4(sp)
  809770:	d8000815 	stw	zero,32(sp)
  809774:	ddc00215 	stw	r23,8(sp)
  809778:	dd800315 	stw	r22,12(sp)
  80977c:	dd400415 	stw	r21,16(sp)
  809780:	dd000515 	stw	r20,20(sp)
  809784:	d8000615 	stw	zero,24(sp)
  809788:	d8000715 	stw	zero,28(sp)
  80978c:	103fdd26 	beq	r2,zero,809704 <__alt_data_end+0xfff09704>
  809790:	0005883a 	mov	r2,zero
  809794:	00cffc34 	movhi	r3,16368
  809798:	003fb406 	br	80966c <__alt_data_end+0xfff0966c>
  80979c:	0005883a 	mov	r2,zero
  8097a0:	003fb206 	br	80966c <__alt_data_end+0xfff0966c>
  8097a4:	8809883a 	mov	r4,r17
  8097a8:	800b883a 	mov	r5,r16
  8097ac:	080ae000 	call	80ae00 <finite>
  8097b0:	10004626 	beq	r2,zero,8098cc <pow+0x2d0>
  8097b4:	000d883a 	mov	r6,zero
  8097b8:	000f883a 	mov	r7,zero
  8097bc:	8809883a 	mov	r4,r17
  8097c0:	800b883a 	mov	r5,r16
  8097c4:	080da480 	call	80da48 <__eqdf2>
  8097c8:	103fa61e 	bne	r2,zero,809664 <__alt_data_end+0xfff09664>
  8097cc:	b809883a 	mov	r4,r23
  8097d0:	b00b883a 	mov	r5,r22
  8097d4:	080ae000 	call	80ae00 <finite>
  8097d8:	103fa226 	beq	r2,zero,809664 <__alt_data_end+0xfff09664>
  8097dc:	a809883a 	mov	r4,r21
  8097e0:	a00b883a 	mov	r5,r20
  8097e4:	080ae000 	call	80ae00 <finite>
  8097e8:	103f9e26 	beq	r2,zero,809664 <__alt_data_end+0xfff09664>
  8097ec:	00800104 	movi	r2,4
  8097f0:	d8800015 	stw	r2,0(sp)
  8097f4:	90c00017 	ldw	r3,0(r18)
  8097f8:	008020b4 	movhi	r2,130
  8097fc:	10a6e604 	addi	r2,r2,-25704
  809800:	d8800115 	stw	r2,4(sp)
  809804:	d8000815 	stw	zero,32(sp)
  809808:	ddc00215 	stw	r23,8(sp)
  80980c:	dd800315 	stw	r22,12(sp)
  809810:	dd400415 	stw	r21,16(sp)
  809814:	dd000515 	stw	r20,20(sp)
  809818:	d8000615 	stw	zero,24(sp)
  80981c:	d8000715 	stw	zero,28(sp)
  809820:	00800084 	movi	r2,2
  809824:	18804726 	beq	r3,r2,809944 <pow+0x348>
  809828:	d809883a 	mov	r4,sp
  80982c:	080ae900 	call	80ae90 <matherr>
  809830:	10004426 	beq	r2,zero,809944 <pow+0x348>
  809834:	d8800817 	ldw	r2,32(sp)
  809838:	103fba26 	beq	r2,zero,809724 <__alt_data_end+0xfff09724>
  80983c:	003fb606 	br	809718 <__alt_data_end+0xfff09718>
  809840:	a809883a 	mov	r4,r21
  809844:	a00b883a 	mov	r5,r20
  809848:	080ae000 	call	80ae00 <finite>
  80984c:	103f8526 	beq	r2,zero,809664 <__alt_data_end+0xfff09664>
  809850:	000d883a 	mov	r6,zero
  809854:	000f883a 	mov	r7,zero
  809858:	a809883a 	mov	r4,r21
  80985c:	a00b883a 	mov	r5,r20
  809860:	080dbac0 	call	80dbac <__ledf2>
  809864:	103f7f0e 	bge	r2,zero,809664 <__alt_data_end+0xfff09664>
  809868:	00c00044 	movi	r3,1
  80986c:	d8c00015 	stw	r3,0(sp)
  809870:	90800017 	ldw	r2,0(r18)
  809874:	00c020b4 	movhi	r3,130
  809878:	18e6e604 	addi	r3,r3,-25704
  80987c:	d8c00115 	stw	r3,4(sp)
  809880:	d8000815 	stw	zero,32(sp)
  809884:	ddc00215 	stw	r23,8(sp)
  809888:	dd800315 	stw	r22,12(sp)
  80988c:	dd400415 	stw	r21,16(sp)
  809890:	dd000515 	stw	r20,20(sp)
  809894:	d8000615 	stw	zero,24(sp)
  809898:	10002526 	beq	r2,zero,809930 <pow+0x334>
  80989c:	00fffc34 	movhi	r3,65520
  8098a0:	d8c00715 	stw	r3,28(sp)
  8098a4:	00c00084 	movi	r3,2
  8098a8:	10c0221e 	bne	r2,r3,809934 <pow+0x338>
  8098ac:	080f4340 	call	80f434 <__errno>
  8098b0:	00c00844 	movi	r3,33
  8098b4:	10c00015 	stw	r3,0(r2)
  8098b8:	003fde06 	br	809834 <__alt_data_end+0xfff09834>
  8098bc:	080f4340 	call	80f434 <__errno>
  8098c0:	00c00844 	movi	r3,33
  8098c4:	10c00015 	stw	r3,0(r2)
  8098c8:	003f9106 	br	809710 <__alt_data_end+0xfff09710>
  8098cc:	b809883a 	mov	r4,r23
  8098d0:	b00b883a 	mov	r5,r22
  8098d4:	080ae000 	call	80ae00 <finite>
  8098d8:	103fb626 	beq	r2,zero,8097b4 <__alt_data_end+0xfff097b4>
  8098dc:	a809883a 	mov	r4,r21
  8098e0:	a00b883a 	mov	r5,r20
  8098e4:	080ae000 	call	80ae00 <finite>
  8098e8:	103fb226 	beq	r2,zero,8097b4 <__alt_data_end+0xfff097b4>
  8098ec:	8809883a 	mov	r4,r17
  8098f0:	800b883a 	mov	r5,r16
  8098f4:	080ae1c0 	call	80ae1c <__fpclassifyd>
  8098f8:	1000161e 	bne	r2,zero,809954 <pow+0x358>
  8098fc:	00800044 	movi	r2,1
  809900:	d8800015 	stw	r2,0(sp)
  809904:	94000017 	ldw	r16,0(r18)
  809908:	008020b4 	movhi	r2,130
  80990c:	10a6e604 	addi	r2,r2,-25704
  809910:	d8800115 	stw	r2,4(sp)
  809914:	d8000815 	stw	zero,32(sp)
  809918:	ddc00215 	stw	r23,8(sp)
  80991c:	dd800315 	stw	r22,12(sp)
  809920:	dd400415 	stw	r21,16(sp)
  809924:	dd000515 	stw	r20,20(sp)
  809928:	8000281e 	bne	r16,zero,8099cc <pow+0x3d0>
  80992c:	d8000615 	stw	zero,24(sp)
  809930:	d8000715 	stw	zero,28(sp)
  809934:	d809883a 	mov	r4,sp
  809938:	080ae900 	call	80ae90 <matherr>
  80993c:	103fbd1e 	bne	r2,zero,809834 <__alt_data_end+0xfff09834>
  809940:	003fda06 	br	8098ac <__alt_data_end+0xfff098ac>
  809944:	080f4340 	call	80f434 <__errno>
  809948:	00c00884 	movi	r3,34
  80994c:	10c00015 	stw	r3,0(r2)
  809950:	003fb806 	br	809834 <__alt_data_end+0xfff09834>
  809954:	00c000c4 	movi	r3,3
  809958:	d8c00015 	stw	r3,0(sp)
  80995c:	90800017 	ldw	r2,0(r18)
  809960:	00c020b4 	movhi	r3,130
  809964:	18e6e604 	addi	r3,r3,-25704
  809968:	d8c00115 	stw	r3,4(sp)
  80996c:	d8000815 	stw	zero,32(sp)
  809970:	ddc00215 	stw	r23,8(sp)
  809974:	dd800315 	stw	r22,12(sp)
  809978:	dd400415 	stw	r21,16(sp)
  80997c:	dd000515 	stw	r20,20(sp)
  809980:	000d883a 	mov	r6,zero
  809984:	000f883a 	mov	r7,zero
  809988:	b809883a 	mov	r4,r23
  80998c:	b00b883a 	mov	r5,r22
  809990:	1000181e 	bne	r2,zero,8099f4 <pow+0x3f8>
  809994:	00b80034 	movhi	r2,57344
  809998:	d8800615 	stw	r2,24(sp)
  80999c:	0091fc34 	movhi	r2,18416
  8099a0:	10bfffc4 	addi	r2,r2,-1
  8099a4:	d8800715 	stw	r2,28(sp)
  8099a8:	080dbac0 	call	80dbac <__ledf2>
  8099ac:	10001a16 	blt	r2,zero,809a18 <pow+0x41c>
  8099b0:	d809883a 	mov	r4,sp
  8099b4:	080ae900 	call	80ae90 <matherr>
  8099b8:	103f551e 	bne	r2,zero,809710 <__alt_data_end+0xfff09710>
  8099bc:	080f4340 	call	80f434 <__errno>
  8099c0:	00c00884 	movi	r3,34
  8099c4:	10c00015 	stw	r3,0(r2)
  8099c8:	003f5106 	br	809710 <__alt_data_end+0xfff09710>
  8099cc:	000d883a 	mov	r6,zero
  8099d0:	000f883a 	mov	r7,zero
  8099d4:	0009883a 	mov	r4,zero
  8099d8:	000b883a 	mov	r5,zero
  8099dc:	080d0780 	call	80d078 <__divdf3>
  8099e0:	d8800615 	stw	r2,24(sp)
  8099e4:	d8c00715 	stw	r3,28(sp)
  8099e8:	00800084 	movi	r2,2
  8099ec:	80bfaf26 	beq	r16,r2,8098ac <__alt_data_end+0xfff098ac>
  8099f0:	003fd006 	br	809934 <__alt_data_end+0xfff09934>
  8099f4:	009ffc34 	movhi	r2,32752
  8099f8:	d8000615 	stw	zero,24(sp)
  8099fc:	d8800715 	stw	r2,28(sp)
  809a00:	080dbac0 	call	80dbac <__ledf2>
  809a04:	10001a16 	blt	r2,zero,809a70 <pow+0x474>
  809a08:	90c00017 	ldw	r3,0(r18)
  809a0c:	00800084 	movi	r2,2
  809a10:	18bfe71e 	bne	r3,r2,8099b0 <__alt_data_end+0xfff099b0>
  809a14:	003fe906 	br	8099bc <__alt_data_end+0xfff099bc>
  809a18:	000d883a 	mov	r6,zero
  809a1c:	01cff834 	movhi	r7,16352
  809a20:	a809883a 	mov	r4,r21
  809a24:	a00b883a 	mov	r5,r20
  809a28:	080dca00 	call	80dca0 <__muldf3>
  809a2c:	1009883a 	mov	r4,r2
  809a30:	180b883a 	mov	r5,r3
  809a34:	1023883a 	mov	r17,r2
  809a38:	1821883a 	mov	r16,r3
  809a3c:	080aea40 	call	80aea4 <rint>
  809a40:	100d883a 	mov	r6,r2
  809a44:	180f883a 	mov	r7,r3
  809a48:	8809883a 	mov	r4,r17
  809a4c:	800b883a 	mov	r5,r16
  809a50:	080da480 	call	80da48 <__eqdf2>
  809a54:	103fec26 	beq	r2,zero,809a08 <__alt_data_end+0xfff09a08>
  809a58:	00b80034 	movhi	r2,57344
  809a5c:	d8800615 	stw	r2,24(sp)
  809a60:	00b1fc34 	movhi	r2,51184
  809a64:	10bfffc4 	addi	r2,r2,-1
  809a68:	d8800715 	stw	r2,28(sp)
  809a6c:	003fe606 	br	809a08 <__alt_data_end+0xfff09a08>
  809a70:	000d883a 	mov	r6,zero
  809a74:	01cff834 	movhi	r7,16352
  809a78:	a809883a 	mov	r4,r21
  809a7c:	a00b883a 	mov	r5,r20
  809a80:	080dca00 	call	80dca0 <__muldf3>
  809a84:	1009883a 	mov	r4,r2
  809a88:	180b883a 	mov	r5,r3
  809a8c:	1023883a 	mov	r17,r2
  809a90:	1821883a 	mov	r16,r3
  809a94:	080aea40 	call	80aea4 <rint>
  809a98:	100d883a 	mov	r6,r2
  809a9c:	180f883a 	mov	r7,r3
  809aa0:	8809883a 	mov	r4,r17
  809aa4:	800b883a 	mov	r5,r16
  809aa8:	080da480 	call	80da48 <__eqdf2>
  809aac:	103fd626 	beq	r2,zero,809a08 <__alt_data_end+0xfff09a08>
  809ab0:	00bffc34 	movhi	r2,65520
  809ab4:	d8000615 	stw	zero,24(sp)
  809ab8:	d8800715 	stw	r2,28(sp)
  809abc:	003fd206 	br	809a08 <__alt_data_end+0xfff09a08>

00809ac0 <__ieee754_pow>:
  809ac0:	00a00034 	movhi	r2,32768
  809ac4:	deffea04 	addi	sp,sp,-88
  809ac8:	10bfffc4 	addi	r2,r2,-1
  809acc:	dc800e15 	stw	r18,56(sp)
  809ad0:	38a4703a 	and	r18,r7,r2
  809ad4:	dfc01515 	stw	ra,84(sp)
  809ad8:	df001415 	stw	fp,80(sp)
  809adc:	ddc01315 	stw	r23,76(sp)
  809ae0:	dd801215 	stw	r22,72(sp)
  809ae4:	dd401115 	stw	r21,68(sp)
  809ae8:	dd001015 	stw	r20,64(sp)
  809aec:	dcc00f15 	stw	r19,60(sp)
  809af0:	dc400d15 	stw	r17,52(sp)
  809af4:	dc000c15 	stw	r16,48(sp)
  809af8:	9186b03a 	or	r3,r18,r6
  809afc:	18002a26 	beq	r3,zero,809ba8 <__ieee754_pow+0xe8>
  809b00:	28a2703a 	and	r17,r5,r2
  809b04:	009ffc34 	movhi	r2,32752
  809b08:	14402316 	blt	r2,r17,809b98 <__ieee754_pow+0xd8>
  809b0c:	88802126 	beq	r17,r2,809b94 <__ieee754_pow+0xd4>
  809b10:	14802116 	blt	r2,r18,809b98 <__ieee754_pow+0xd8>
  809b14:	009ffc34 	movhi	r2,32752
  809b18:	90807326 	beq	r18,r2,809ce8 <__ieee754_pow+0x228>
  809b1c:	2827883a 	mov	r19,r5
  809b20:	2021883a 	mov	r16,r4
  809b24:	302d883a 	mov	r22,r6
  809b28:	3839883a 	mov	fp,r7
  809b2c:	28007016 	blt	r5,zero,809cf0 <__ieee754_pow+0x230>
  809b30:	002b883a 	mov	r21,zero
  809b34:	b0003a1e 	bne	r22,zero,809c20 <__ieee754_pow+0x160>
  809b38:	009ffc34 	movhi	r2,32752
  809b3c:	90807f26 	beq	r18,r2,809d3c <__ieee754_pow+0x27c>
  809b40:	008ffc34 	movhi	r2,16368
  809b44:	90805426 	beq	r18,r2,809c98 <__ieee754_pow+0x1d8>
  809b48:	00900034 	movhi	r2,16384
  809b4c:	e0833b26 	beq	fp,r2,80a83c <__ieee754_pow+0xd7c>
  809b50:	008ff834 	movhi	r2,16352
  809b54:	e080321e 	bne	fp,r2,809c20 <__ieee754_pow+0x160>
  809b58:	98003116 	blt	r19,zero,809c20 <__ieee754_pow+0x160>
  809b5c:	8009883a 	mov	r4,r16
  809b60:	980b883a 	mov	r5,r19
  809b64:	dfc01517 	ldw	ra,84(sp)
  809b68:	df001417 	ldw	fp,80(sp)
  809b6c:	ddc01317 	ldw	r23,76(sp)
  809b70:	dd801217 	ldw	r22,72(sp)
  809b74:	dd401117 	ldw	r21,68(sp)
  809b78:	dd001017 	ldw	r20,64(sp)
  809b7c:	dcc00f17 	ldw	r19,60(sp)
  809b80:	dc800e17 	ldw	r18,56(sp)
  809b84:	dc400d17 	ldw	r17,52(sp)
  809b88:	dc000c17 	ldw	r16,48(sp)
  809b8c:	dec01604 	addi	sp,sp,88
  809b90:	080ab641 	jmpi	80ab64 <__ieee754_sqrt>
  809b94:	20001226 	beq	r4,zero,809be0 <__ieee754_pow+0x120>
  809b98:	00b00434 	movhi	r2,49168
  809b9c:	8885883a 	add	r2,r17,r2
  809ba0:	1108b03a 	or	r4,r2,r4
  809ba4:	20000f1e 	bne	r4,zero,809be4 <__ieee754_pow+0x124>
  809ba8:	0005883a 	mov	r2,zero
  809bac:	00cffc34 	movhi	r3,16368
  809bb0:	dfc01517 	ldw	ra,84(sp)
  809bb4:	df001417 	ldw	fp,80(sp)
  809bb8:	ddc01317 	ldw	r23,76(sp)
  809bbc:	dd801217 	ldw	r22,72(sp)
  809bc0:	dd401117 	ldw	r21,68(sp)
  809bc4:	dd001017 	ldw	r20,64(sp)
  809bc8:	dcc00f17 	ldw	r19,60(sp)
  809bcc:	dc800e17 	ldw	r18,56(sp)
  809bd0:	dc400d17 	ldw	r17,52(sp)
  809bd4:	dc000c17 	ldw	r16,48(sp)
  809bd8:	dec01604 	addi	sp,sp,88
  809bdc:	f800283a 	ret
  809be0:	8cbfcc0e 	bge	r17,r18,809b14 <__alt_data_end+0xfff09b14>
  809be4:	010020b4 	movhi	r4,130
  809be8:	2126e704 	addi	r4,r4,-25700
  809bec:	dfc01517 	ldw	ra,84(sp)
  809bf0:	df001417 	ldw	fp,80(sp)
  809bf4:	ddc01317 	ldw	r23,76(sp)
  809bf8:	dd801217 	ldw	r22,72(sp)
  809bfc:	dd401117 	ldw	r21,68(sp)
  809c00:	dd001017 	ldw	r20,64(sp)
  809c04:	dcc00f17 	ldw	r19,60(sp)
  809c08:	dc800e17 	ldw	r18,56(sp)
  809c0c:	dc400d17 	ldw	r17,52(sp)
  809c10:	dc000c17 	ldw	r16,48(sp)
  809c14:	dec01604 	addi	sp,sp,88
  809c18:	080ae981 	jmpi	80ae98 <nan>
  809c1c:	002b883a 	mov	r21,zero
  809c20:	8009883a 	mov	r4,r16
  809c24:	980b883a 	mov	r5,r19
  809c28:	080adec0 	call	80adec <fabs>
  809c2c:	102f883a 	mov	r23,r2
  809c30:	80000f26 	beq	r16,zero,809c70 <__ieee754_pow+0x1b0>
  809c34:	9816d7fa 	srli	r11,r19,31
  809c38:	5affffc4 	addi	r11,r11,-1
  809c3c:	aac4b03a 	or	r2,r21,r11
  809c40:	10004b26 	beq	r2,zero,809d70 <__ieee754_pow+0x2b0>
  809c44:	00907834 	movhi	r2,16864
  809c48:	1480540e 	bge	r2,r18,809d9c <__ieee754_pow+0x2dc>
  809c4c:	0090fc34 	movhi	r2,17392
  809c50:	14832d0e 	bge	r2,r18,80a908 <__ieee754_pow+0xe48>
  809c54:	008ffc34 	movhi	r2,16368
  809c58:	10bfffc4 	addi	r2,r2,-1
  809c5c:	14401916 	blt	r2,r17,809cc4 <__ieee754_pow+0x204>
  809c60:	e0001916 	blt	fp,zero,809cc8 <__ieee754_pow+0x208>
  809c64:	0005883a 	mov	r2,zero
  809c68:	0007883a 	mov	r3,zero
  809c6c:	003fd006 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809c70:	88000526 	beq	r17,zero,809c88 <__ieee754_pow+0x1c8>
  809c74:	00900034 	movhi	r2,16384
  809c78:	10bfffc4 	addi	r2,r2,-1
  809c7c:	9884703a 	and	r2,r19,r2
  809c80:	010ffc34 	movhi	r4,16368
  809c84:	113feb1e 	bne	r2,r4,809c34 <__alt_data_end+0xfff09c34>
  809c88:	e0000716 	blt	fp,zero,809ca8 <__ieee754_pow+0x1e8>
  809c8c:	9802e216 	blt	r19,zero,80a818 <__ieee754_pow+0xd58>
  809c90:	b805883a 	mov	r2,r23
  809c94:	003fc606 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809c98:	e0037516 	blt	fp,zero,80aa70 <__ieee754_pow+0xfb0>
  809c9c:	8005883a 	mov	r2,r16
  809ca0:	9807883a 	mov	r3,r19
  809ca4:	003fc206 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809ca8:	b80d883a 	mov	r6,r23
  809cac:	180f883a 	mov	r7,r3
  809cb0:	0009883a 	mov	r4,zero
  809cb4:	014ffc34 	movhi	r5,16368
  809cb8:	080d0780 	call	80d078 <__divdf3>
  809cbc:	102f883a 	mov	r23,r2
  809cc0:	003ff206 	br	809c8c <__alt_data_end+0xfff09c8c>
  809cc4:	073fe70e 	bge	zero,fp,809c64 <__alt_data_end+0xfff09c64>
  809cc8:	01a20034 	movhi	r6,34816
  809ccc:	01df8e34 	movhi	r7,32312
  809cd0:	319d6704 	addi	r6,r6,30108
  809cd4:	39f90f04 	addi	r7,r7,-7108
  809cd8:	3009883a 	mov	r4,r6
  809cdc:	380b883a 	mov	r5,r7
  809ce0:	080dca00 	call	80dca0 <__muldf3>
  809ce4:	003fb206 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809ce8:	303f8c26 	beq	r6,zero,809b1c <__alt_data_end+0xfff09b1c>
  809cec:	003faa06 	br	809b98 <__alt_data_end+0xfff09b98>
  809cf0:	0090d034 	movhi	r2,17216
  809cf4:	10bfffc4 	addi	r2,r2,-1
  809cf8:	14801b16 	blt	r2,r18,809d68 <__ieee754_pow+0x2a8>
  809cfc:	008ffc34 	movhi	r2,16368
  809d00:	10bfffc4 	addi	r2,r2,-1
  809d04:	14bf8a0e 	bge	r2,r18,809b30 <__alt_data_end+0xfff09b30>
  809d08:	9005d53a 	srai	r2,r18,20
  809d0c:	00c00504 	movi	r3,20
  809d10:	10bf0044 	addi	r2,r2,-1023
  809d14:	18836b0e 	bge	r3,r2,80aac4 <__ieee754_pow+0x1004>
  809d18:	00c00d04 	movi	r3,52
  809d1c:	1885c83a 	sub	r2,r3,r2
  809d20:	3086d83a 	srl	r3,r6,r2
  809d24:	1884983a 	sll	r2,r3,r2
  809d28:	30bf811e 	bne	r6,r2,809b30 <__alt_data_end+0xfff09b30>
  809d2c:	18c0004c 	andi	r3,r3,1
  809d30:	02800084 	movi	r10,2
  809d34:	50ebc83a 	sub	r21,r10,r3
  809d38:	003f7e06 	br	809b34 <__alt_data_end+0xfff09b34>
  809d3c:	01300434 	movhi	r4,49168
  809d40:	8909883a 	add	r4,r17,r4
  809d44:	2408b03a 	or	r4,r4,r16
  809d48:	203f9726 	beq	r4,zero,809ba8 <__alt_data_end+0xfff09ba8>
  809d4c:	008ffc34 	movhi	r2,16368
  809d50:	10bfffc4 	addi	r2,r2,-1
  809d54:	1442e60e 	bge	r2,r17,80a8f0 <__ieee754_pow+0xe30>
  809d58:	e03fc216 	blt	fp,zero,809c64 <__alt_data_end+0xfff09c64>
  809d5c:	0005883a 	mov	r2,zero
  809d60:	e007883a 	mov	r3,fp
  809d64:	003f9206 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809d68:	05400084 	movi	r21,2
  809d6c:	003f7106 	br	809b34 <__alt_data_end+0xfff09b34>
  809d70:	800d883a 	mov	r6,r16
  809d74:	980f883a 	mov	r7,r19
  809d78:	3009883a 	mov	r4,r6
  809d7c:	380b883a 	mov	r5,r7
  809d80:	080e50c0 	call	80e50c <__subdf3>
  809d84:	100d883a 	mov	r6,r2
  809d88:	180f883a 	mov	r7,r3
  809d8c:	1009883a 	mov	r4,r2
  809d90:	180b883a 	mov	r5,r3
  809d94:	080d0780 	call	80d078 <__divdf3>
  809d98:	003f8506 	br	809bb0 <__alt_data_end+0xfff09bb0>
  809d9c:	00800434 	movhi	r2,16
  809da0:	10bfffc4 	addi	r2,r2,-1
  809da4:	1442d616 	blt	r2,r17,80a900 <__ieee754_pow+0xe40>
  809da8:	b809883a 	mov	r4,r23
  809dac:	000d883a 	mov	r6,zero
  809db0:	01d0d034 	movhi	r7,17216
  809db4:	180b883a 	mov	r5,r3
  809db8:	dac00b15 	stw	r11,44(sp)
  809dbc:	080dca00 	call	80dca0 <__muldf3>
  809dc0:	dac00b17 	ldw	r11,44(sp)
  809dc4:	102f883a 	mov	r23,r2
  809dc8:	1823883a 	mov	r17,r3
  809dcc:	033ff2c4 	movi	r12,-53
  809dd0:	8807d53a 	srai	r3,r17,20
  809dd4:	00800434 	movhi	r2,16
  809dd8:	10bfffc4 	addi	r2,r2,-1
  809ddc:	18ff0044 	addi	r3,r3,-1023
  809de0:	1b19883a 	add	r12,r3,r12
  809de4:	00c00134 	movhi	r3,4
  809de8:	8884703a 	and	r2,r17,r2
  809dec:	18e62384 	addi	r3,r3,-26482
  809df0:	150ffc34 	orhi	r20,r2,16368
  809df4:	1880060e 	bge	r3,r2,809e10 <__ieee754_pow+0x350>
  809df8:	00c00334 	movhi	r3,12
  809dfc:	18ed9e44 	addi	r3,r3,-18823
  809e00:	18833f0e 	bge	r3,r2,80ab00 <__ieee754_pow+0x1040>
  809e04:	00bffc34 	movhi	r2,65520
  809e08:	63000044 	addi	r12,r12,1
  809e0c:	a0a9883a 	add	r20,r20,r2
  809e10:	0027883a 	mov	r19,zero
  809e14:	d8000215 	stw	zero,8(sp)
  809e18:	0013883a 	mov	r9,zero
  809e1c:	0011883a 	mov	r8,zero
  809e20:	0015883a 	mov	r10,zero
  809e24:	048ffc34 	movhi	r18,16368
  809e28:	900f883a 	mov	r7,r18
  809e2c:	b809883a 	mov	r4,r23
  809e30:	a00b883a 	mov	r5,r20
  809e34:	000d883a 	mov	r6,zero
  809e38:	da000a15 	stw	r8,40(sp)
  809e3c:	da400815 	stw	r9,32(sp)
  809e40:	dac00b15 	stw	r11,44(sp)
  809e44:	db000915 	stw	r12,36(sp)
  809e48:	da800515 	stw	r10,20(sp)
  809e4c:	080e50c0 	call	80e50c <__subdf3>
  809e50:	b809883a 	mov	r4,r23
  809e54:	a00b883a 	mov	r5,r20
  809e58:	900f883a 	mov	r7,r18
  809e5c:	000d883a 	mov	r6,zero
  809e60:	d8800015 	stw	r2,0(sp)
  809e64:	d8c00115 	stw	r3,4(sp)
  809e68:	080c7cc0 	call	80c7cc <__adddf3>
  809e6c:	100d883a 	mov	r6,r2
  809e70:	180f883a 	mov	r7,r3
  809e74:	0009883a 	mov	r4,zero
  809e78:	014ffc34 	movhi	r5,16368
  809e7c:	080d0780 	call	80d078 <__divdf3>
  809e80:	d9000017 	ldw	r4,0(sp)
  809e84:	d9400117 	ldw	r5,4(sp)
  809e88:	100d883a 	mov	r6,r2
  809e8c:	180f883a 	mov	r7,r3
  809e90:	d8c00715 	stw	r3,28(sp)
  809e94:	d8800615 	stw	r2,24(sp)
  809e98:	080dca00 	call	80dca0 <__muldf3>
  809e9c:	1023883a 	mov	r17,r2
  809ea0:	a005d07a 	srai	r2,r20,1
  809ea4:	da800517 	ldw	r10,20(sp)
  809ea8:	1821883a 	mov	r16,r3
  809eac:	10c80034 	orhi	r3,r2,8192
  809eb0:	00800234 	movhi	r2,8
  809eb4:	1885883a 	add	r2,r3,r2
  809eb8:	1295883a 	add	r10,r2,r10
  809ebc:	500f883a 	mov	r7,r10
  809ec0:	800b883a 	mov	r5,r16
  809ec4:	000d883a 	mov	r6,zero
  809ec8:	0009883a 	mov	r4,zero
  809ecc:	da800515 	stw	r10,20(sp)
  809ed0:	080dca00 	call	80dca0 <__muldf3>
  809ed4:	d9000017 	ldw	r4,0(sp)
  809ed8:	d9400117 	ldw	r5,4(sp)
  809edc:	100d883a 	mov	r6,r2
  809ee0:	180f883a 	mov	r7,r3
  809ee4:	080e50c0 	call	80e50c <__subdf3>
  809ee8:	da800517 	ldw	r10,20(sp)
  809eec:	900f883a 	mov	r7,r18
  809ef0:	000d883a 	mov	r6,zero
  809ef4:	500b883a 	mov	r5,r10
  809ef8:	0009883a 	mov	r4,zero
  809efc:	d8800015 	stw	r2,0(sp)
  809f00:	d8c00515 	stw	r3,20(sp)
  809f04:	080e50c0 	call	80e50c <__subdf3>
  809f08:	b809883a 	mov	r4,r23
  809f0c:	a00b883a 	mov	r5,r20
  809f10:	100d883a 	mov	r6,r2
  809f14:	180f883a 	mov	r7,r3
  809f18:	080e50c0 	call	80e50c <__subdf3>
  809f1c:	800f883a 	mov	r7,r16
  809f20:	000d883a 	mov	r6,zero
  809f24:	1009883a 	mov	r4,r2
  809f28:	180b883a 	mov	r5,r3
  809f2c:	080dca00 	call	80dca0 <__muldf3>
  809f30:	db400517 	ldw	r13,20(sp)
  809f34:	d9000017 	ldw	r4,0(sp)
  809f38:	100d883a 	mov	r6,r2
  809f3c:	680b883a 	mov	r5,r13
  809f40:	180f883a 	mov	r7,r3
  809f44:	080e50c0 	call	80e50c <__subdf3>
  809f48:	dbc00617 	ldw	r15,24(sp)
  809f4c:	db800717 	ldw	r14,28(sp)
  809f50:	1009883a 	mov	r4,r2
  809f54:	780d883a 	mov	r6,r15
  809f58:	700f883a 	mov	r7,r14
  809f5c:	180b883a 	mov	r5,r3
  809f60:	080dca00 	call	80dca0 <__muldf3>
  809f64:	880d883a 	mov	r6,r17
  809f68:	800f883a 	mov	r7,r16
  809f6c:	8809883a 	mov	r4,r17
  809f70:	800b883a 	mov	r5,r16
  809f74:	d8800015 	stw	r2,0(sp)
  809f78:	d8c00115 	stw	r3,4(sp)
  809f7c:	080dca00 	call	80dca0 <__muldf3>
  809f80:	01929174 	movhi	r6,19013
  809f84:	01cff2b4 	movhi	r7,16330
  809f88:	3193bbc4 	addi	r6,r6,20207
  809f8c:	39df8a04 	addi	r7,r7,32296
  809f90:	1009883a 	mov	r4,r2
  809f94:	180b883a 	mov	r5,r3
  809f98:	102f883a 	mov	r23,r2
  809f9c:	1829883a 	mov	r20,r3
  809fa0:	080dca00 	call	80dca0 <__muldf3>
  809fa4:	01a4f2b4 	movhi	r6,37834
  809fa8:	01cff3b4 	movhi	r7,16334
  809fac:	31b6d944 	addi	r6,r6,-9371
  809fb0:	39e19284 	addi	r7,r7,-31158
  809fb4:	1009883a 	mov	r4,r2
  809fb8:	180b883a 	mov	r5,r3
  809fbc:	080c7cc0 	call	80c7cc <__adddf3>
  809fc0:	b80d883a 	mov	r6,r23
  809fc4:	a00f883a 	mov	r7,r20
  809fc8:	1009883a 	mov	r4,r2
  809fcc:	180b883a 	mov	r5,r3
  809fd0:	080dca00 	call	80dca0 <__muldf3>
  809fd4:	01aa4774 	movhi	r6,43293
  809fd8:	01cff474 	movhi	r7,16337
  809fdc:	31904044 	addi	r6,r6,16641
  809fe0:	39dd1804 	addi	r7,r7,29792
  809fe4:	1009883a 	mov	r4,r2
  809fe8:	180b883a 	mov	r5,r3
  809fec:	080c7cc0 	call	80c7cc <__adddf3>
  809ff0:	b80d883a 	mov	r6,r23
  809ff4:	a00f883a 	mov	r7,r20
  809ff8:	1009883a 	mov	r4,r2
  809ffc:	180b883a 	mov	r5,r3
  80a000:	080dca00 	call	80dca0 <__muldf3>
  80a004:	019463f4 	movhi	r6,20879
  80a008:	01cff574 	movhi	r7,16341
  80a00c:	31899344 	addi	r6,r6,9805
  80a010:	39d55544 	addi	r7,r7,21845
  80a014:	1009883a 	mov	r4,r2
  80a018:	180b883a 	mov	r5,r3
  80a01c:	080c7cc0 	call	80c7cc <__adddf3>
  80a020:	b80d883a 	mov	r6,r23
  80a024:	a00f883a 	mov	r7,r20
  80a028:	1009883a 	mov	r4,r2
  80a02c:	180b883a 	mov	r5,r3
  80a030:	080dca00 	call	80dca0 <__muldf3>
  80a034:	01b6dc34 	movhi	r6,56176
  80a038:	01cff6f4 	movhi	r7,16347
  80a03c:	31aaffc4 	addi	r6,r6,-21505
  80a040:	39db6d84 	addi	r7,r7,28086
  80a044:	1009883a 	mov	r4,r2
  80a048:	180b883a 	mov	r5,r3
  80a04c:	080c7cc0 	call	80c7cc <__adddf3>
  80a050:	b80d883a 	mov	r6,r23
  80a054:	a00f883a 	mov	r7,r20
  80a058:	1009883a 	mov	r4,r2
  80a05c:	180b883a 	mov	r5,r3
  80a060:	080dca00 	call	80dca0 <__muldf3>
  80a064:	018cccf4 	movhi	r6,13107
  80a068:	01cff8f4 	movhi	r7,16355
  80a06c:	318cc0c4 	addi	r6,r6,13059
  80a070:	39ccccc4 	addi	r7,r7,13107
  80a074:	1009883a 	mov	r4,r2
  80a078:	180b883a 	mov	r5,r3
  80a07c:	080c7cc0 	call	80c7cc <__adddf3>
  80a080:	b80d883a 	mov	r6,r23
  80a084:	a00f883a 	mov	r7,r20
  80a088:	b809883a 	mov	r4,r23
  80a08c:	a00b883a 	mov	r5,r20
  80a090:	1825883a 	mov	r18,r3
  80a094:	d8800515 	stw	r2,20(sp)
  80a098:	080dca00 	call	80dca0 <__muldf3>
  80a09c:	db400517 	ldw	r13,20(sp)
  80a0a0:	900b883a 	mov	r5,r18
  80a0a4:	100d883a 	mov	r6,r2
  80a0a8:	6809883a 	mov	r4,r13
  80a0ac:	180f883a 	mov	r7,r3
  80a0b0:	080dca00 	call	80dca0 <__muldf3>
  80a0b4:	800f883a 	mov	r7,r16
  80a0b8:	8809883a 	mov	r4,r17
  80a0bc:	800b883a 	mov	r5,r16
  80a0c0:	000d883a 	mov	r6,zero
  80a0c4:	102f883a 	mov	r23,r2
  80a0c8:	1829883a 	mov	r20,r3
  80a0cc:	080c7cc0 	call	80c7cc <__adddf3>
  80a0d0:	d9800017 	ldw	r6,0(sp)
  80a0d4:	d9c00117 	ldw	r7,4(sp)
  80a0d8:	1009883a 	mov	r4,r2
  80a0dc:	180b883a 	mov	r5,r3
  80a0e0:	080dca00 	call	80dca0 <__muldf3>
  80a0e4:	b80d883a 	mov	r6,r23
  80a0e8:	a00f883a 	mov	r7,r20
  80a0ec:	1009883a 	mov	r4,r2
  80a0f0:	180b883a 	mov	r5,r3
  80a0f4:	080c7cc0 	call	80c7cc <__adddf3>
  80a0f8:	800f883a 	mov	r7,r16
  80a0fc:	800b883a 	mov	r5,r16
  80a100:	000d883a 	mov	r6,zero
  80a104:	0009883a 	mov	r4,zero
  80a108:	1025883a 	mov	r18,r2
  80a10c:	182f883a 	mov	r23,r3
  80a110:	080dca00 	call	80dca0 <__muldf3>
  80a114:	000d883a 	mov	r6,zero
  80a118:	01d00234 	movhi	r7,16392
  80a11c:	1009883a 	mov	r4,r2
  80a120:	180b883a 	mov	r5,r3
  80a124:	d8c00715 	stw	r3,28(sp)
  80a128:	d8800615 	stw	r2,24(sp)
  80a12c:	080c7cc0 	call	80c7cc <__adddf3>
  80a130:	900d883a 	mov	r6,r18
  80a134:	b80f883a 	mov	r7,r23
  80a138:	1009883a 	mov	r4,r2
  80a13c:	180b883a 	mov	r5,r3
  80a140:	080c7cc0 	call	80c7cc <__adddf3>
  80a144:	800b883a 	mov	r5,r16
  80a148:	000d883a 	mov	r6,zero
  80a14c:	180f883a 	mov	r7,r3
  80a150:	0009883a 	mov	r4,zero
  80a154:	1829883a 	mov	r20,r3
  80a158:	080dca00 	call	80dca0 <__muldf3>
  80a15c:	a00b883a 	mov	r5,r20
  80a160:	000d883a 	mov	r6,zero
  80a164:	01d00234 	movhi	r7,16392
  80a168:	0009883a 	mov	r4,zero
  80a16c:	d8800315 	stw	r2,12(sp)
  80a170:	d8c00415 	stw	r3,16(sp)
  80a174:	080e50c0 	call	80e50c <__subdf3>
  80a178:	dbc00617 	ldw	r15,24(sp)
  80a17c:	db800717 	ldw	r14,28(sp)
  80a180:	1009883a 	mov	r4,r2
  80a184:	780d883a 	mov	r6,r15
  80a188:	700f883a 	mov	r7,r14
  80a18c:	180b883a 	mov	r5,r3
  80a190:	080e50c0 	call	80e50c <__subdf3>
  80a194:	9009883a 	mov	r4,r18
  80a198:	b80b883a 	mov	r5,r23
  80a19c:	100d883a 	mov	r6,r2
  80a1a0:	180f883a 	mov	r7,r3
  80a1a4:	080e50c0 	call	80e50c <__subdf3>
  80a1a8:	880d883a 	mov	r6,r17
  80a1ac:	800f883a 	mov	r7,r16
  80a1b0:	1009883a 	mov	r4,r2
  80a1b4:	180b883a 	mov	r5,r3
  80a1b8:	080dca00 	call	80dca0 <__muldf3>
  80a1bc:	d9000017 	ldw	r4,0(sp)
  80a1c0:	d9400117 	ldw	r5,4(sp)
  80a1c4:	a00f883a 	mov	r7,r20
  80a1c8:	000d883a 	mov	r6,zero
  80a1cc:	1023883a 	mov	r17,r2
  80a1d0:	1821883a 	mov	r16,r3
  80a1d4:	080dca00 	call	80dca0 <__muldf3>
  80a1d8:	8809883a 	mov	r4,r17
  80a1dc:	800b883a 	mov	r5,r16
  80a1e0:	100d883a 	mov	r6,r2
  80a1e4:	180f883a 	mov	r7,r3
  80a1e8:	080c7cc0 	call	80c7cc <__adddf3>
  80a1ec:	d9000317 	ldw	r4,12(sp)
  80a1f0:	d9400417 	ldw	r5,16(sp)
  80a1f4:	100d883a 	mov	r6,r2
  80a1f8:	180f883a 	mov	r7,r3
  80a1fc:	102f883a 	mov	r23,r2
  80a200:	1823883a 	mov	r17,r3
  80a204:	080c7cc0 	call	80c7cc <__adddf3>
  80a208:	01cffbf4 	movhi	r7,16367
  80a20c:	39f1c244 	addi	r7,r7,-14583
  80a210:	0009883a 	mov	r4,zero
  80a214:	180b883a 	mov	r5,r3
  80a218:	01b80034 	movhi	r6,57344
  80a21c:	1821883a 	mov	r16,r3
  80a220:	080dca00 	call	80dca0 <__muldf3>
  80a224:	d9800317 	ldw	r6,12(sp)
  80a228:	d9c00417 	ldw	r7,16(sp)
  80a22c:	800b883a 	mov	r5,r16
  80a230:	0009883a 	mov	r4,zero
  80a234:	1825883a 	mov	r18,r3
  80a238:	d8800015 	stw	r2,0(sp)
  80a23c:	080e50c0 	call	80e50c <__subdf3>
  80a240:	b809883a 	mov	r4,r23
  80a244:	880b883a 	mov	r5,r17
  80a248:	100d883a 	mov	r6,r2
  80a24c:	180f883a 	mov	r7,r3
  80a250:	080e50c0 	call	80e50c <__subdf3>
  80a254:	01b70eb4 	movhi	r6,56378
  80a258:	01cffbf4 	movhi	r7,16367
  80a25c:	3180ff44 	addi	r6,r6,1021
  80a260:	39f1c244 	addi	r7,r7,-14583
  80a264:	1009883a 	mov	r4,r2
  80a268:	180b883a 	mov	r5,r3
  80a26c:	080dca00 	call	80dca0 <__muldf3>
  80a270:	018516f4 	movhi	r6,5211
  80a274:	01ef8fb4 	movhi	r7,48702
  80a278:	800b883a 	mov	r5,r16
  80a27c:	31807d44 	addi	r6,r6,501
  80a280:	39cbf804 	addi	r7,r7,12256
  80a284:	0009883a 	mov	r4,zero
  80a288:	1029883a 	mov	r20,r2
  80a28c:	1823883a 	mov	r17,r3
  80a290:	080dca00 	call	80dca0 <__muldf3>
  80a294:	a009883a 	mov	r4,r20
  80a298:	880b883a 	mov	r5,r17
  80a29c:	100d883a 	mov	r6,r2
  80a2a0:	180f883a 	mov	r7,r3
  80a2a4:	080c7cc0 	call	80c7cc <__adddf3>
  80a2a8:	da400817 	ldw	r9,32(sp)
  80a2ac:	da000a17 	ldw	r8,40(sp)
  80a2b0:	180b883a 	mov	r5,r3
  80a2b4:	480d883a 	mov	r6,r9
  80a2b8:	400f883a 	mov	r7,r8
  80a2bc:	1009883a 	mov	r4,r2
  80a2c0:	080c7cc0 	call	80c7cc <__adddf3>
  80a2c4:	db000917 	ldw	r12,36(sp)
  80a2c8:	1029883a 	mov	r20,r2
  80a2cc:	1823883a 	mov	r17,r3
  80a2d0:	6009883a 	mov	r4,r12
  80a2d4:	080ee880 	call	80ee88 <__floatsidf>
  80a2d8:	d9000017 	ldw	r4,0(sp)
  80a2dc:	a00d883a 	mov	r6,r20
  80a2e0:	880f883a 	mov	r7,r17
  80a2e4:	900b883a 	mov	r5,r18
  80a2e8:	182f883a 	mov	r23,r3
  80a2ec:	d8800115 	stw	r2,4(sp)
  80a2f0:	080c7cc0 	call	80c7cc <__adddf3>
  80a2f4:	d9c00217 	ldw	r7,8(sp)
  80a2f8:	980d883a 	mov	r6,r19
  80a2fc:	1009883a 	mov	r4,r2
  80a300:	180b883a 	mov	r5,r3
  80a304:	080c7cc0 	call	80c7cc <__adddf3>
  80a308:	d9800117 	ldw	r6,4(sp)
  80a30c:	b80f883a 	mov	r7,r23
  80a310:	1009883a 	mov	r4,r2
  80a314:	180b883a 	mov	r5,r3
  80a318:	080c7cc0 	call	80c7cc <__adddf3>
  80a31c:	d9800117 	ldw	r6,4(sp)
  80a320:	b80f883a 	mov	r7,r23
  80a324:	0009883a 	mov	r4,zero
  80a328:	180b883a 	mov	r5,r3
  80a32c:	1821883a 	mov	r16,r3
  80a330:	080e50c0 	call	80e50c <__subdf3>
  80a334:	d9c00217 	ldw	r7,8(sp)
  80a338:	980d883a 	mov	r6,r19
  80a33c:	1009883a 	mov	r4,r2
  80a340:	180b883a 	mov	r5,r3
  80a344:	080e50c0 	call	80e50c <__subdf3>
  80a348:	d9800017 	ldw	r6,0(sp)
  80a34c:	900f883a 	mov	r7,r18
  80a350:	1009883a 	mov	r4,r2
  80a354:	180b883a 	mov	r5,r3
  80a358:	080e50c0 	call	80e50c <__subdf3>
  80a35c:	880b883a 	mov	r5,r17
  80a360:	100d883a 	mov	r6,r2
  80a364:	180f883a 	mov	r7,r3
  80a368:	a009883a 	mov	r4,r20
  80a36c:	080e50c0 	call	80e50c <__subdf3>
  80a370:	dac00b17 	ldw	r11,44(sp)
  80a374:	aabfffc4 	addi	r10,r21,-1
  80a378:	1025883a 	mov	r18,r2
  80a37c:	52d6b03a 	or	r11,r10,r11
  80a380:	1823883a 	mov	r17,r3
  80a384:	58015826 	beq	r11,zero,80a8e8 <__ieee754_pow+0xe28>
  80a388:	04cffc34 	movhi	r19,16368
  80a38c:	b009883a 	mov	r4,r22
  80a390:	000d883a 	mov	r6,zero
  80a394:	e00f883a 	mov	r7,fp
  80a398:	e00b883a 	mov	r5,fp
  80a39c:	080e50c0 	call	80e50c <__subdf3>
  80a3a0:	800f883a 	mov	r7,r16
  80a3a4:	000d883a 	mov	r6,zero
  80a3a8:	1009883a 	mov	r4,r2
  80a3ac:	180b883a 	mov	r5,r3
  80a3b0:	080dca00 	call	80dca0 <__muldf3>
  80a3b4:	b00d883a 	mov	r6,r22
  80a3b8:	9009883a 	mov	r4,r18
  80a3bc:	880b883a 	mov	r5,r17
  80a3c0:	e00f883a 	mov	r7,fp
  80a3c4:	1829883a 	mov	r20,r3
  80a3c8:	102b883a 	mov	r21,r2
  80a3cc:	080dca00 	call	80dca0 <__muldf3>
  80a3d0:	a00b883a 	mov	r5,r20
  80a3d4:	100d883a 	mov	r6,r2
  80a3d8:	180f883a 	mov	r7,r3
  80a3dc:	a809883a 	mov	r4,r21
  80a3e0:	080c7cc0 	call	80c7cc <__adddf3>
  80a3e4:	800b883a 	mov	r5,r16
  80a3e8:	000d883a 	mov	r6,zero
  80a3ec:	e00f883a 	mov	r7,fp
  80a3f0:	0009883a 	mov	r4,zero
  80a3f4:	102d883a 	mov	r22,r2
  80a3f8:	1829883a 	mov	r20,r3
  80a3fc:	080dca00 	call	80dca0 <__muldf3>
  80a400:	100d883a 	mov	r6,r2
  80a404:	180f883a 	mov	r7,r3
  80a408:	b009883a 	mov	r4,r22
  80a40c:	a00b883a 	mov	r5,r20
  80a410:	1025883a 	mov	r18,r2
  80a414:	1823883a 	mov	r17,r3
  80a418:	080c7cc0 	call	80c7cc <__adddf3>
  80a41c:	102f883a 	mov	r23,r2
  80a420:	00902434 	movhi	r2,16528
  80a424:	10bfffc4 	addi	r2,r2,-1
  80a428:	1821883a 	mov	r16,r3
  80a42c:	9013883a 	mov	r9,r18
  80a430:	8811883a 	mov	r8,r17
  80a434:	10c1070e 	bge	r2,r3,80a854 <__ieee754_pow+0xd94>
  80a438:	00afdc34 	movhi	r2,49008
  80a43c:	1885883a 	add	r2,r3,r2
  80a440:	15c4b03a 	or	r2,r2,r23
  80a444:	1001901e 	bne	r2,zero,80aa88 <__ieee754_pow+0xfc8>
  80a448:	01994b34 	movhi	r6,25900
  80a44c:	01cf25f4 	movhi	r7,15511
  80a450:	31a0bf84 	addi	r6,r6,-32002
  80a454:	39c551c4 	addi	r7,r7,5447
  80a458:	b009883a 	mov	r4,r22
  80a45c:	a00b883a 	mov	r5,r20
  80a460:	080c7cc0 	call	80c7cc <__adddf3>
  80a464:	900d883a 	mov	r6,r18
  80a468:	880f883a 	mov	r7,r17
  80a46c:	b809883a 	mov	r4,r23
  80a470:	800b883a 	mov	r5,r16
  80a474:	1039883a 	mov	fp,r2
  80a478:	182b883a 	mov	r21,r3
  80a47c:	080e50c0 	call	80e50c <__subdf3>
  80a480:	100d883a 	mov	r6,r2
  80a484:	180f883a 	mov	r7,r3
  80a488:	e009883a 	mov	r4,fp
  80a48c:	a80b883a 	mov	r5,r21
  80a490:	080dad00 	call	80dad0 <__gedf2>
  80a494:	00817c16 	blt	zero,r2,80aa88 <__ieee754_pow+0xfc8>
  80a498:	802b883a 	mov	r21,r16
  80a49c:	a805d53a 	srai	r2,r21,20
  80a4a0:	00c00434 	movhi	r3,16
  80a4a4:	01000434 	movhi	r4,16
  80a4a8:	10bf0084 	addi	r2,r2,-1022
  80a4ac:	1885d83a 	sra	r2,r3,r2
  80a4b0:	213fffc4 	addi	r4,r4,-1
  80a4b4:	1405883a 	add	r2,r2,r16
  80a4b8:	1006907a 	slli	r3,r2,1
  80a4bc:	112a703a 	and	r21,r2,r4
  80a4c0:	ad400434 	orhi	r21,r21,16
  80a4c4:	1806d57a 	srli	r3,r3,21
  80a4c8:	18ff0044 	addi	r3,r3,-1023
  80a4cc:	20cfd83a 	sra	r7,r4,r3
  80a4d0:	01000504 	movi	r4,20
  80a4d4:	20c7c83a 	sub	r3,r4,r3
  80a4d8:	a8c7d83a 	sra	r3,r21,r3
  80a4dc:	01ce303a 	nor	r7,zero,r7
  80a4e0:	388e703a 	and	r7,r7,r2
  80a4e4:	d8c00015 	stw	r3,0(sp)
  80a4e8:	80019016 	blt	r16,zero,80ab2c <__ieee754_pow+0x106c>
  80a4ec:	000d883a 	mov	r6,zero
  80a4f0:	9009883a 	mov	r4,r18
  80a4f4:	880b883a 	mov	r5,r17
  80a4f8:	080e50c0 	call	80e50c <__subdf3>
  80a4fc:	100d883a 	mov	r6,r2
  80a500:	180f883a 	mov	r7,r3
  80a504:	b009883a 	mov	r4,r22
  80a508:	a00b883a 	mov	r5,r20
  80a50c:	d8c00a15 	stw	r3,40(sp)
  80a510:	d8800815 	stw	r2,32(sp)
  80a514:	080c7cc0 	call	80c7cc <__adddf3>
  80a518:	d8800017 	ldw	r2,0(sp)
  80a51c:	da000a17 	ldw	r8,40(sp)
  80a520:	da400817 	ldw	r9,32(sp)
  80a524:	1004953a 	slli	r2,r2,20
  80a528:	1821883a 	mov	r16,r3
  80a52c:	d8800215 	stw	r2,8(sp)
  80a530:	01cff9b4 	movhi	r7,16358
  80a534:	800b883a 	mov	r5,r16
  80a538:	39cb90c4 	addi	r7,r7,11843
  80a53c:	0009883a 	mov	r4,zero
  80a540:	000d883a 	mov	r6,zero
  80a544:	da000a15 	stw	r8,40(sp)
  80a548:	da400815 	stw	r9,32(sp)
  80a54c:	080dca00 	call	80dca0 <__muldf3>
  80a550:	da400817 	ldw	r9,32(sp)
  80a554:	da000a17 	ldw	r8,40(sp)
  80a558:	800b883a 	mov	r5,r16
  80a55c:	480d883a 	mov	r6,r9
  80a560:	400f883a 	mov	r7,r8
  80a564:	0009883a 	mov	r4,zero
  80a568:	1039883a 	mov	fp,r2
  80a56c:	182f883a 	mov	r23,r3
  80a570:	080e50c0 	call	80e50c <__subdf3>
  80a574:	b009883a 	mov	r4,r22
  80a578:	a00b883a 	mov	r5,r20
  80a57c:	100d883a 	mov	r6,r2
  80a580:	180f883a 	mov	r7,r3
  80a584:	080e50c0 	call	80e50c <__subdf3>
  80a588:	01bfbeb4 	movhi	r6,65274
  80a58c:	01cff9b4 	movhi	r7,16358
  80a590:	318e7bc4 	addi	r6,r6,14831
  80a594:	39cb9084 	addi	r7,r7,11842
  80a598:	1009883a 	mov	r4,r2
  80a59c:	180b883a 	mov	r5,r3
  80a5a0:	080dca00 	call	80dca0 <__muldf3>
  80a5a4:	01832a34 	movhi	r6,3240
  80a5a8:	01ef8834 	movhi	r7,48672
  80a5ac:	800b883a 	mov	r5,r16
  80a5b0:	319b0e44 	addi	r6,r6,27705
  80a5b4:	39d71844 	addi	r7,r7,23649
  80a5b8:	0009883a 	mov	r4,zero
  80a5bc:	1029883a 	mov	r20,r2
  80a5c0:	1823883a 	mov	r17,r3
  80a5c4:	080dca00 	call	80dca0 <__muldf3>
  80a5c8:	a009883a 	mov	r4,r20
  80a5cc:	880b883a 	mov	r5,r17
  80a5d0:	100d883a 	mov	r6,r2
  80a5d4:	180f883a 	mov	r7,r3
  80a5d8:	080c7cc0 	call	80c7cc <__adddf3>
  80a5dc:	e009883a 	mov	r4,fp
  80a5e0:	b80b883a 	mov	r5,r23
  80a5e4:	100d883a 	mov	r6,r2
  80a5e8:	180f883a 	mov	r7,r3
  80a5ec:	102d883a 	mov	r22,r2
  80a5f0:	1829883a 	mov	r20,r3
  80a5f4:	080c7cc0 	call	80c7cc <__adddf3>
  80a5f8:	e00d883a 	mov	r6,fp
  80a5fc:	b80f883a 	mov	r7,r23
  80a600:	1009883a 	mov	r4,r2
  80a604:	180b883a 	mov	r5,r3
  80a608:	1023883a 	mov	r17,r2
  80a60c:	1821883a 	mov	r16,r3
  80a610:	080e50c0 	call	80e50c <__subdf3>
  80a614:	b009883a 	mov	r4,r22
  80a618:	a00b883a 	mov	r5,r20
  80a61c:	100d883a 	mov	r6,r2
  80a620:	180f883a 	mov	r7,r3
  80a624:	080e50c0 	call	80e50c <__subdf3>
  80a628:	880d883a 	mov	r6,r17
  80a62c:	800f883a 	mov	r7,r16
  80a630:	8809883a 	mov	r4,r17
  80a634:	800b883a 	mov	r5,r16
  80a638:	1039883a 	mov	fp,r2
  80a63c:	182f883a 	mov	r23,r3
  80a640:	080dca00 	call	80dca0 <__muldf3>
  80a644:	019caff4 	movhi	r6,29375
  80a648:	01cf99b4 	movhi	r7,15974
  80a64c:	31a93404 	addi	r6,r6,-23344
  80a650:	39cdda44 	addi	r7,r7,14185
  80a654:	1009883a 	mov	r4,r2
  80a658:	180b883a 	mov	r5,r3
  80a65c:	102d883a 	mov	r22,r2
  80a660:	1829883a 	mov	r20,r3
  80a664:	080dca00 	call	80dca0 <__muldf3>
  80a668:	01b174b4 	movhi	r6,50642
  80a66c:	01cfaf34 	movhi	r7,16060
  80a670:	319afc44 	addi	r6,r6,27633
  80a674:	39ef5044 	addi	r7,r7,-17087
  80a678:	1009883a 	mov	r4,r2
  80a67c:	180b883a 	mov	r5,r3
  80a680:	080e50c0 	call	80e50c <__subdf3>
  80a684:	b00d883a 	mov	r6,r22
  80a688:	a00f883a 	mov	r7,r20
  80a68c:	1009883a 	mov	r4,r2
  80a690:	180b883a 	mov	r5,r3
  80a694:	080dca00 	call	80dca0 <__muldf3>
  80a698:	01abc9b4 	movhi	r6,44838
  80a69c:	01cfc474 	movhi	r7,16145
  80a6a0:	31b78b04 	addi	r6,r6,-8660
  80a6a4:	39d59a84 	addi	r7,r7,22122
  80a6a8:	1009883a 	mov	r4,r2
  80a6ac:	180b883a 	mov	r5,r3
  80a6b0:	080c7cc0 	call	80c7cc <__adddf3>
  80a6b4:	b00d883a 	mov	r6,r22
  80a6b8:	a00f883a 	mov	r7,r20
  80a6bc:	1009883a 	mov	r4,r2
  80a6c0:	180b883a 	mov	r5,r3
  80a6c4:	080dca00 	call	80dca0 <__muldf3>
  80a6c8:	0185aff4 	movhi	r6,5823
  80a6cc:	01cfd9f4 	movhi	r7,16231
  80a6d0:	31af64c4 	addi	r6,r6,-17005
  80a6d4:	39f05b04 	addi	r7,r7,-16020
  80a6d8:	1009883a 	mov	r4,r2
  80a6dc:	180b883a 	mov	r5,r3
  80a6e0:	080e50c0 	call	80e50c <__subdf3>
  80a6e4:	b00d883a 	mov	r6,r22
  80a6e8:	a00f883a 	mov	r7,r20
  80a6ec:	1009883a 	mov	r4,r2
  80a6f0:	180b883a 	mov	r5,r3
  80a6f4:	080dca00 	call	80dca0 <__muldf3>
  80a6f8:	01955574 	movhi	r6,21845
  80a6fc:	01cff174 	movhi	r7,16325
  80a700:	31954f84 	addi	r6,r6,21822
  80a704:	39d55544 	addi	r7,r7,21845
  80a708:	1009883a 	mov	r4,r2
  80a70c:	180b883a 	mov	r5,r3
  80a710:	080c7cc0 	call	80c7cc <__adddf3>
  80a714:	b00d883a 	mov	r6,r22
  80a718:	a00f883a 	mov	r7,r20
  80a71c:	1009883a 	mov	r4,r2
  80a720:	180b883a 	mov	r5,r3
  80a724:	080dca00 	call	80dca0 <__muldf3>
  80a728:	100d883a 	mov	r6,r2
  80a72c:	180f883a 	mov	r7,r3
  80a730:	8809883a 	mov	r4,r17
  80a734:	800b883a 	mov	r5,r16
  80a738:	080e50c0 	call	80e50c <__subdf3>
  80a73c:	100d883a 	mov	r6,r2
  80a740:	180f883a 	mov	r7,r3
  80a744:	8809883a 	mov	r4,r17
  80a748:	800b883a 	mov	r5,r16
  80a74c:	102d883a 	mov	r22,r2
  80a750:	1829883a 	mov	r20,r3
  80a754:	080dca00 	call	80dca0 <__muldf3>
  80a758:	b009883a 	mov	r4,r22
  80a75c:	a00b883a 	mov	r5,r20
  80a760:	000d883a 	mov	r6,zero
  80a764:	01d00034 	movhi	r7,16384
  80a768:	1025883a 	mov	r18,r2
  80a76c:	182b883a 	mov	r21,r3
  80a770:	080e50c0 	call	80e50c <__subdf3>
  80a774:	100d883a 	mov	r6,r2
  80a778:	180f883a 	mov	r7,r3
  80a77c:	9009883a 	mov	r4,r18
  80a780:	a80b883a 	mov	r5,r21
  80a784:	080d0780 	call	80d078 <__divdf3>
  80a788:	e00d883a 	mov	r6,fp
  80a78c:	b80f883a 	mov	r7,r23
  80a790:	8809883a 	mov	r4,r17
  80a794:	800b883a 	mov	r5,r16
  80a798:	102d883a 	mov	r22,r2
  80a79c:	1829883a 	mov	r20,r3
  80a7a0:	080dca00 	call	80dca0 <__muldf3>
  80a7a4:	e00d883a 	mov	r6,fp
  80a7a8:	b80f883a 	mov	r7,r23
  80a7ac:	1009883a 	mov	r4,r2
  80a7b0:	180b883a 	mov	r5,r3
  80a7b4:	080c7cc0 	call	80c7cc <__adddf3>
  80a7b8:	100d883a 	mov	r6,r2
  80a7bc:	180f883a 	mov	r7,r3
  80a7c0:	b009883a 	mov	r4,r22
  80a7c4:	a00b883a 	mov	r5,r20
  80a7c8:	080e50c0 	call	80e50c <__subdf3>
  80a7cc:	880d883a 	mov	r6,r17
  80a7d0:	800f883a 	mov	r7,r16
  80a7d4:	1009883a 	mov	r4,r2
  80a7d8:	180b883a 	mov	r5,r3
  80a7dc:	080e50c0 	call	80e50c <__subdf3>
  80a7e0:	0009883a 	mov	r4,zero
  80a7e4:	014ffc34 	movhi	r5,16368
  80a7e8:	100d883a 	mov	r6,r2
  80a7ec:	180f883a 	mov	r7,r3
  80a7f0:	080e50c0 	call	80e50c <__subdf3>
  80a7f4:	d9000217 	ldw	r4,8(sp)
  80a7f8:	190b883a 	add	r5,r3,r4
  80a7fc:	2809d53a 	srai	r4,r5,20
  80a800:	0100cd0e 	bge	zero,r4,80ab38 <__ieee754_pow+0x1078>
  80a804:	1009883a 	mov	r4,r2
  80a808:	000d883a 	mov	r6,zero
  80a80c:	980f883a 	mov	r7,r19
  80a810:	080dca00 	call	80dca0 <__muldf3>
  80a814:	003ce606 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80a818:	00b00434 	movhi	r2,49168
  80a81c:	8885883a 	add	r2,r17,r2
  80a820:	1544b03a 	or	r2,r2,r21
  80a824:	1000b326 	beq	r2,zero,80aaf4 <__ieee754_pow+0x1034>
  80a828:	00800044 	movi	r2,1
  80a82c:	a8bd181e 	bne	r21,r2,809c90 <__alt_data_end+0xfff09c90>
  80a830:	18e0003c 	xorhi	r3,r3,32768
  80a834:	b805883a 	mov	r2,r23
  80a838:	003cdd06 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80a83c:	800d883a 	mov	r6,r16
  80a840:	980f883a 	mov	r7,r19
  80a844:	8009883a 	mov	r4,r16
  80a848:	980b883a 	mov	r5,r19
  80a84c:	080dca00 	call	80dca0 <__muldf3>
  80a850:	003cd706 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80a854:	05600034 	movhi	r21,32768
  80a858:	ad7fffc4 	addi	r21,r21,-1
  80a85c:	00902474 	movhi	r2,16529
  80a860:	1d6a703a 	and	r21,r3,r21
  80a864:	10b2ffc4 	addi	r2,r2,-13313
  80a868:	15409d0e 	bge	r2,r21,80aae0 <__ieee754_pow+0x1020>
  80a86c:	008fdbf4 	movhi	r2,16239
  80a870:	108d0004 	addi	r2,r2,13312
  80a874:	1885883a 	add	r2,r3,r2
  80a878:	15c4b03a 	or	r2,r2,r23
  80a87c:	10000b1e 	bne	r2,zero,80a8ac <__ieee754_pow+0xdec>
  80a880:	900d883a 	mov	r6,r18
  80a884:	880f883a 	mov	r7,r17
  80a888:	b809883a 	mov	r4,r23
  80a88c:	180b883a 	mov	r5,r3
  80a890:	080e50c0 	call	80e50c <__subdf3>
  80a894:	100d883a 	mov	r6,r2
  80a898:	180f883a 	mov	r7,r3
  80a89c:	b009883a 	mov	r4,r22
  80a8a0:	a00b883a 	mov	r5,r20
  80a8a4:	080dbac0 	call	80dbac <__ledf2>
  80a8a8:	00befc16 	blt	zero,r2,80a49c <__alt_data_end+0xfff0a49c>
  80a8ac:	01b0be74 	movhi	r6,49913
  80a8b0:	01c06974 	movhi	r7,421
  80a8b4:	980b883a 	mov	r5,r19
  80a8b8:	31bcd644 	addi	r6,r6,-3239
  80a8bc:	39db87c4 	addi	r7,r7,28191
  80a8c0:	0009883a 	mov	r4,zero
  80a8c4:	080dca00 	call	80dca0 <__muldf3>
  80a8c8:	01b0be74 	movhi	r6,49913
  80a8cc:	01c06974 	movhi	r7,421
  80a8d0:	31bcd644 	addi	r6,r6,-3239
  80a8d4:	39db87c4 	addi	r7,r7,28191
  80a8d8:	1009883a 	mov	r4,r2
  80a8dc:	180b883a 	mov	r5,r3
  80a8e0:	080dca00 	call	80dca0 <__muldf3>
  80a8e4:	003cb206 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80a8e8:	04effc34 	movhi	r19,49136
  80a8ec:	003ea706 	br	80a38c <__alt_data_end+0xfff0a38c>
  80a8f0:	e03cdc0e 	bge	fp,zero,809c64 <__alt_data_end+0xfff09c64>
  80a8f4:	0005883a 	mov	r2,zero
  80a8f8:	e0e0003c 	xorhi	r3,fp,32768
  80a8fc:	003cac06 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80a900:	0019883a 	mov	r12,zero
  80a904:	003d3206 	br	809dd0 <__alt_data_end+0xfff09dd0>
  80a908:	008ffc34 	movhi	r2,16368
  80a90c:	10bfff84 	addi	r2,r2,-2
  80a910:	147cd30e 	bge	r2,r17,809c60 <__alt_data_end+0xfff09c60>
  80a914:	01cffc34 	movhi	r7,16368
  80a918:	3c7cea16 	blt	r7,r17,809cc4 <__alt_data_end+0xfff09cc4>
  80a91c:	b809883a 	mov	r4,r23
  80a920:	000d883a 	mov	r6,zero
  80a924:	180b883a 	mov	r5,r3
  80a928:	dac00b15 	stw	r11,44(sp)
  80a92c:	080e50c0 	call	80e50c <__subdf3>
  80a930:	01cffdf4 	movhi	r7,16375
  80a934:	39c551c4 	addi	r7,r7,5447
  80a938:	01980034 	movhi	r6,24576
  80a93c:	1009883a 	mov	r4,r2
  80a940:	180b883a 	mov	r5,r3
  80a944:	1023883a 	mov	r17,r2
  80a948:	1821883a 	mov	r16,r3
  80a94c:	080dca00 	call	80dca0 <__muldf3>
  80a950:	01be17b4 	movhi	r6,63582
  80a954:	01cf9574 	movhi	r7,15957
  80a958:	8809883a 	mov	r4,r17
  80a95c:	800b883a 	mov	r5,r16
  80a960:	31b7d104 	addi	r6,r6,-8380
  80a964:	39eb82c4 	addi	r7,r7,-20981
  80a968:	1027883a 	mov	r19,r2
  80a96c:	1825883a 	mov	r18,r3
  80a970:	080dca00 	call	80dca0 <__muldf3>
  80a974:	8809883a 	mov	r4,r17
  80a978:	800b883a 	mov	r5,r16
  80a97c:	000d883a 	mov	r6,zero
  80a980:	01cff434 	movhi	r7,16336
  80a984:	1829883a 	mov	r20,r3
  80a988:	d8800a15 	stw	r2,40(sp)
  80a98c:	080dca00 	call	80dca0 <__muldf3>
  80a990:	01155574 	movhi	r4,21845
  80a994:	014ff574 	movhi	r5,16341
  80a998:	100d883a 	mov	r6,r2
  80a99c:	180f883a 	mov	r7,r3
  80a9a0:	21155544 	addi	r4,r4,21845
  80a9a4:	29555544 	addi	r5,r5,21845
  80a9a8:	080e50c0 	call	80e50c <__subdf3>
  80a9ac:	880d883a 	mov	r6,r17
  80a9b0:	800f883a 	mov	r7,r16
  80a9b4:	1009883a 	mov	r4,r2
  80a9b8:	180b883a 	mov	r5,r3
  80a9bc:	080dca00 	call	80dca0 <__muldf3>
  80a9c0:	100d883a 	mov	r6,r2
  80a9c4:	180f883a 	mov	r7,r3
  80a9c8:	0009883a 	mov	r4,zero
  80a9cc:	014ff834 	movhi	r5,16352
  80a9d0:	080e50c0 	call	80e50c <__subdf3>
  80a9d4:	880d883a 	mov	r6,r17
  80a9d8:	800f883a 	mov	r7,r16
  80a9dc:	8809883a 	mov	r4,r17
  80a9e0:	800b883a 	mov	r5,r16
  80a9e4:	102f883a 	mov	r23,r2
  80a9e8:	d8c00815 	stw	r3,32(sp)
  80a9ec:	080dca00 	call	80dca0 <__muldf3>
  80a9f0:	da400817 	ldw	r9,32(sp)
  80a9f4:	100d883a 	mov	r6,r2
  80a9f8:	180f883a 	mov	r7,r3
  80a9fc:	480b883a 	mov	r5,r9
  80aa00:	b809883a 	mov	r4,r23
  80aa04:	080dca00 	call	80dca0 <__muldf3>
  80aa08:	01994b34 	movhi	r6,25900
  80aa0c:	01cffdf4 	movhi	r7,16375
  80aa10:	31a0bf84 	addi	r6,r6,-32002
  80aa14:	39c551c4 	addi	r7,r7,5447
  80aa18:	1009883a 	mov	r4,r2
  80aa1c:	180b883a 	mov	r5,r3
  80aa20:	080dca00 	call	80dca0 <__muldf3>
  80aa24:	da000a17 	ldw	r8,40(sp)
  80aa28:	a00b883a 	mov	r5,r20
  80aa2c:	100d883a 	mov	r6,r2
  80aa30:	4009883a 	mov	r4,r8
  80aa34:	180f883a 	mov	r7,r3
  80aa38:	080e50c0 	call	80e50c <__subdf3>
  80aa3c:	100d883a 	mov	r6,r2
  80aa40:	180f883a 	mov	r7,r3
  80aa44:	9809883a 	mov	r4,r19
  80aa48:	900b883a 	mov	r5,r18
  80aa4c:	1029883a 	mov	r20,r2
  80aa50:	1823883a 	mov	r17,r3
  80aa54:	080c7cc0 	call	80c7cc <__adddf3>
  80aa58:	1821883a 	mov	r16,r3
  80aa5c:	980d883a 	mov	r6,r19
  80aa60:	900f883a 	mov	r7,r18
  80aa64:	0009883a 	mov	r4,zero
  80aa68:	180b883a 	mov	r5,r3
  80aa6c:	003e3a06 	br	80a358 <__alt_data_end+0xfff0a358>
  80aa70:	800d883a 	mov	r6,r16
  80aa74:	980f883a 	mov	r7,r19
  80aa78:	0009883a 	mov	r4,zero
  80aa7c:	900b883a 	mov	r5,r18
  80aa80:	080d0780 	call	80d078 <__divdf3>
  80aa84:	003c4a06 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80aa88:	01a20034 	movhi	r6,34816
  80aa8c:	01df8e34 	movhi	r7,32312
  80aa90:	980b883a 	mov	r5,r19
  80aa94:	319d6704 	addi	r6,r6,30108
  80aa98:	39f90f04 	addi	r7,r7,-7108
  80aa9c:	0009883a 	mov	r4,zero
  80aaa0:	080dca00 	call	80dca0 <__muldf3>
  80aaa4:	01a20034 	movhi	r6,34816
  80aaa8:	01df8e34 	movhi	r7,32312
  80aaac:	319d6704 	addi	r6,r6,30108
  80aab0:	39f90f04 	addi	r7,r7,-7108
  80aab4:	1009883a 	mov	r4,r2
  80aab8:	180b883a 	mov	r5,r3
  80aabc:	080dca00 	call	80dca0 <__muldf3>
  80aac0:	003c3b06 	br	809bb0 <__alt_data_end+0xfff09bb0>
  80aac4:	303c551e 	bne	r6,zero,809c1c <__alt_data_end+0xfff09c1c>
  80aac8:	1885c83a 	sub	r2,r3,r2
  80aacc:	9087d83a 	sra	r3,r18,r2
  80aad0:	1884983a 	sll	r2,r3,r2
  80aad4:	90801f26 	beq	r18,r2,80ab54 <__ieee754_pow+0x1094>
  80aad8:	002b883a 	mov	r21,zero
  80aadc:	003c1806 	br	809b40 <__alt_data_end+0xfff09b40>
  80aae0:	008ff834 	movhi	r2,16352
  80aae4:	157e6d16 	blt	r2,r21,80a49c <__alt_data_end+0xfff0a49c>
  80aae8:	d8000215 	stw	zero,8(sp)
  80aaec:	d8000015 	stw	zero,0(sp)
  80aaf0:	003e8f06 	br	80a530 <__alt_data_end+0xfff0a530>
  80aaf4:	b80d883a 	mov	r6,r23
  80aaf8:	180f883a 	mov	r7,r3
  80aafc:	003c9e06 	br	809d78 <__alt_data_end+0xfff09d78>
  80ab00:	008ff8f4 	movhi	r2,16355
  80ab04:	10ae00c4 	addi	r2,r2,-18429
  80ab08:	0250f434 	movhi	r9,17360
  80ab0c:	020f9374 	movhi	r8,15949
  80ab10:	d8800215 	stw	r2,8(sp)
  80ab14:	4a740184 	addi	r9,r9,-12282
  80ab18:	423f7ac4 	addi	r8,r8,-533
  80ab1c:	04d00034 	movhi	r19,16384
  80ab20:	02800134 	movhi	r10,4
  80ab24:	048ffe34 	movhi	r18,16376
  80ab28:	003cbf06 	br	809e28 <__alt_data_end+0xfff09e28>
  80ab2c:	00c9c83a 	sub	r4,zero,r3
  80ab30:	d9000015 	stw	r4,0(sp)
  80ab34:	003e6d06 	br	80a4ec <__alt_data_end+0xfff0a4ec>
  80ab38:	d9800017 	ldw	r6,0(sp)
  80ab3c:	1009883a 	mov	r4,r2
  80ab40:	180b883a 	mov	r5,r3
  80ab44:	080b0900 	call	80b090 <scalbn>
  80ab48:	1009883a 	mov	r4,r2
  80ab4c:	180b883a 	mov	r5,r3
  80ab50:	003f2d06 	br	80a808 <__alt_data_end+0xfff0a808>
  80ab54:	18c0004c 	andi	r3,r3,1
  80ab58:	02800084 	movi	r10,2
  80ab5c:	50ebc83a 	sub	r21,r10,r3
  80ab60:	003bf706 	br	809b40 <__alt_data_end+0xfff09b40>

0080ab64 <__ieee754_sqrt>:
  80ab64:	defffd04 	addi	sp,sp,-12
  80ab68:	dc400115 	stw	r17,4(sp)
  80ab6c:	dc000015 	stw	r16,0(sp)
  80ab70:	dfc00215 	stw	ra,8(sp)
  80ab74:	28dffc2c 	andhi	r3,r5,32752
  80ab78:	009ffc34 	movhi	r2,32752
  80ab7c:	2821883a 	mov	r16,r5
  80ab80:	2023883a 	mov	r17,r4
  80ab84:	200d883a 	mov	r6,r4
  80ab88:	18807b26 	beq	r3,r2,80ad78 <__ieee754_sqrt+0x214>
  80ab8c:	01405f0e 	bge	zero,r5,80ad0c <__ieee754_sqrt+0x1a8>
  80ab90:	2815d53a 	srai	r10,r5,20
  80ab94:	50006a26 	beq	r10,zero,80ad40 <__ieee754_sqrt+0x1dc>
  80ab98:	00c00434 	movhi	r3,16
  80ab9c:	52bf0044 	addi	r10,r10,-1023
  80aba0:	18ffffc4 	addi	r3,r3,-1
  80aba4:	80c6703a 	and	r3,r16,r3
  80aba8:	5080004c 	andi	r2,r10,1
  80abac:	18c00434 	orhi	r3,r3,16
  80abb0:	1000511e 	bne	r2,zero,80acf8 <__ieee754_sqrt+0x194>
  80abb4:	3004d7fa 	srli	r2,r6,31
  80abb8:	5015d07a 	srai	r10,r10,1
  80abbc:	18c7883a 	add	r3,r3,r3
  80abc0:	10c5883a 	add	r2,r2,r3
  80abc4:	01400584 	movi	r5,22
  80abc8:	3187883a 	add	r3,r6,r6
  80abcc:	0013883a 	mov	r9,zero
  80abd0:	000f883a 	mov	r7,zero
  80abd4:	01000834 	movhi	r4,32
  80abd8:	390d883a 	add	r6,r7,r4
  80abdc:	1810d7fa 	srli	r8,r3,31
  80abe0:	297fffc4 	addi	r5,r5,-1
  80abe4:	11800316 	blt	r2,r6,80abf4 <__ieee754_sqrt+0x90>
  80abe8:	1185c83a 	sub	r2,r2,r6
  80abec:	310f883a 	add	r7,r6,r4
  80abf0:	4913883a 	add	r9,r9,r4
  80abf4:	1085883a 	add	r2,r2,r2
  80abf8:	4085883a 	add	r2,r8,r2
  80abfc:	18c7883a 	add	r3,r3,r3
  80ac00:	2008d07a 	srli	r4,r4,1
  80ac04:	283ff41e 	bne	r5,zero,80abd8 <__alt_data_end+0xfff0abd8>
  80ac08:	01200034 	movhi	r4,32768
  80ac0c:	01800804 	movi	r6,32
  80ac10:	0011883a 	mov	r8,zero
  80ac14:	0019883a 	mov	r12,zero
  80ac18:	201b883a 	mov	r13,r4
  80ac1c:	00000806 	br	80ac40 <__ieee754_sqrt+0xdc>
  80ac20:	38801726 	beq	r7,r2,80ac80 <__ieee754_sqrt+0x11c>
  80ac24:	180ad7fa 	srli	r5,r3,31
  80ac28:	1085883a 	add	r2,r2,r2
  80ac2c:	31bfffc4 	addi	r6,r6,-1
  80ac30:	2885883a 	add	r2,r5,r2
  80ac34:	18c7883a 	add	r3,r3,r3
  80ac38:	2008d07a 	srli	r4,r4,1
  80ac3c:	30001726 	beq	r6,zero,80ac9c <__ieee754_sqrt+0x138>
  80ac40:	230b883a 	add	r5,r4,r12
  80ac44:	38bff60e 	bge	r7,r2,80ac20 <__alt_data_end+0xfff0ac20>
  80ac48:	2ae0002c 	andhi	r11,r5,32768
  80ac4c:	2919883a 	add	r12,r5,r4
  80ac50:	5b400826 	beq	r11,r13,80ac74 <__ieee754_sqrt+0x110>
  80ac54:	3817883a 	mov	r11,r7
  80ac58:	11c5c83a 	sub	r2,r2,r7
  80ac5c:	1940012e 	bgeu	r3,r5,80ac64 <__ieee754_sqrt+0x100>
  80ac60:	10bfffc4 	addi	r2,r2,-1
  80ac64:	1947c83a 	sub	r3,r3,r5
  80ac68:	4111883a 	add	r8,r8,r4
  80ac6c:	580f883a 	mov	r7,r11
  80ac70:	003fec06 	br	80ac24 <__alt_data_end+0xfff0ac24>
  80ac74:	603ff716 	blt	r12,zero,80ac54 <__alt_data_end+0xfff0ac54>
  80ac78:	3ac00044 	addi	r11,r7,1
  80ac7c:	003ff606 	br	80ac58 <__alt_data_end+0xfff0ac58>
  80ac80:	19401936 	bltu	r3,r5,80ace8 <__ieee754_sqrt+0x184>
  80ac84:	2ae0002c 	andhi	r11,r5,32768
  80ac88:	2919883a 	add	r12,r5,r4
  80ac8c:	5b404526 	beq	r11,r13,80ada4 <__ieee754_sqrt+0x240>
  80ac90:	1017883a 	mov	r11,r2
  80ac94:	0005883a 	mov	r2,zero
  80ac98:	003ff206 	br	80ac64 <__alt_data_end+0xfff0ac64>
  80ac9c:	10c4b03a 	or	r2,r2,r3
  80aca0:	10000426 	beq	r2,zero,80acb4 <__ieee754_sqrt+0x150>
  80aca4:	00bfffc4 	movi	r2,-1
  80aca8:	40804026 	beq	r8,r2,80adac <__ieee754_sqrt+0x248>
  80acac:	4080004c 	andi	r2,r8,1
  80acb0:	4091883a 	add	r8,r8,r2
  80acb4:	4004d07a 	srli	r2,r8,1
  80acb8:	4807d07a 	srai	r3,r9,1
  80acbc:	010ff834 	movhi	r4,16352
  80acc0:	4a40004c 	andi	r9,r9,1
  80acc4:	1909883a 	add	r4,r3,r4
  80acc8:	4800091e 	bne	r9,zero,80acf0 <__ieee754_sqrt+0x18c>
  80accc:	5006953a 	slli	r3,r10,20
  80acd0:	1907883a 	add	r3,r3,r4
  80acd4:	dfc00217 	ldw	ra,8(sp)
  80acd8:	dc400117 	ldw	r17,4(sp)
  80acdc:	dc000017 	ldw	r16,0(sp)
  80ace0:	dec00304 	addi	sp,sp,12
  80ace4:	f800283a 	ret
  80ace8:	3805883a 	mov	r2,r7
  80acec:	003fcd06 	br	80ac24 <__alt_data_end+0xfff0ac24>
  80acf0:	10a00034 	orhi	r2,r2,32768
  80acf4:	003ff506 	br	80accc <__alt_data_end+0xfff0accc>
  80acf8:	3004d7fa 	srli	r2,r6,31
  80acfc:	18c7883a 	add	r3,r3,r3
  80ad00:	318d883a 	add	r6,r6,r6
  80ad04:	10c7883a 	add	r3,r2,r3
  80ad08:	003faa06 	br	80abb4 <__alt_data_end+0xfff0abb4>
  80ad0c:	00a00034 	movhi	r2,32768
  80ad10:	10bfffc4 	addi	r2,r2,-1
  80ad14:	2884703a 	and	r2,r5,r2
  80ad18:	1104b03a 	or	r2,r2,r4
  80ad1c:	10001e26 	beq	r2,zero,80ad98 <__ieee754_sqrt+0x234>
  80ad20:	2800291e 	bne	r5,zero,80adc8 <__ieee754_sqrt+0x264>
  80ad24:	0015883a 	mov	r10,zero
  80ad28:	3020d2fa 	srli	r16,r6,11
  80ad2c:	52bffac4 	addi	r10,r10,-21
  80ad30:	300c957a 	slli	r6,r6,21
  80ad34:	803ffc26 	beq	r16,zero,80ad28 <__alt_data_end+0xfff0ad28>
  80ad38:	8080042c 	andhi	r2,r16,16
  80ad3c:	10001e1e 	bne	r2,zero,80adb8 <__ieee754_sqrt+0x254>
  80ad40:	0005883a 	mov	r2,zero
  80ad44:	00000106 	br	80ad4c <__ieee754_sqrt+0x1e8>
  80ad48:	1805883a 	mov	r2,r3
  80ad4c:	8421883a 	add	r16,r16,r16
  80ad50:	8100042c 	andhi	r4,r16,16
  80ad54:	10c00044 	addi	r3,r2,1
  80ad58:	203ffb26 	beq	r4,zero,80ad48 <__alt_data_end+0xfff0ad48>
  80ad5c:	01000804 	movi	r4,32
  80ad60:	20c9c83a 	sub	r4,r4,r3
  80ad64:	3108d83a 	srl	r4,r6,r4
  80ad68:	5095c83a 	sub	r10,r10,r2
  80ad6c:	30cc983a 	sll	r6,r6,r3
  80ad70:	2420b03a 	or	r16,r4,r16
  80ad74:	003f8806 	br	80ab98 <__alt_data_end+0xfff0ab98>
  80ad78:	280f883a 	mov	r7,r5
  80ad7c:	080dca00 	call	80dca0 <__muldf3>
  80ad80:	880d883a 	mov	r6,r17
  80ad84:	800f883a 	mov	r7,r16
  80ad88:	1009883a 	mov	r4,r2
  80ad8c:	180b883a 	mov	r5,r3
  80ad90:	080c7cc0 	call	80c7cc <__adddf3>
  80ad94:	003fcf06 	br	80acd4 <__alt_data_end+0xfff0acd4>
  80ad98:	2005883a 	mov	r2,r4
  80ad9c:	2807883a 	mov	r3,r5
  80ada0:	003fcc06 	br	80acd4 <__alt_data_end+0xfff0acd4>
  80ada4:	603fba16 	blt	r12,zero,80ac90 <__alt_data_end+0xfff0ac90>
  80ada8:	003fb306 	br	80ac78 <__alt_data_end+0xfff0ac78>
  80adac:	4a400044 	addi	r9,r9,1
  80adb0:	0005883a 	mov	r2,zero
  80adb4:	003fc006 	br	80acb8 <__alt_data_end+0xfff0acb8>
  80adb8:	01000804 	movi	r4,32
  80adbc:	00bfffc4 	movi	r2,-1
  80adc0:	0007883a 	mov	r3,zero
  80adc4:	003fe706 	br	80ad64 <__alt_data_end+0xfff0ad64>
  80adc8:	200d883a 	mov	r6,r4
  80adcc:	280f883a 	mov	r7,r5
  80add0:	080e50c0 	call	80e50c <__subdf3>
  80add4:	100d883a 	mov	r6,r2
  80add8:	180f883a 	mov	r7,r3
  80addc:	1009883a 	mov	r4,r2
  80ade0:	180b883a 	mov	r5,r3
  80ade4:	080d0780 	call	80d078 <__divdf3>
  80ade8:	003fba06 	br	80acd4 <__alt_data_end+0xfff0acd4>

0080adec <fabs>:
  80adec:	00e00034 	movhi	r3,32768
  80adf0:	18ffffc4 	addi	r3,r3,-1
  80adf4:	2005883a 	mov	r2,r4
  80adf8:	28c6703a 	and	r3,r5,r3
  80adfc:	f800283a 	ret

0080ae00 <finite>:
  80ae00:	00a00034 	movhi	r2,32768
  80ae04:	10bfffc4 	addi	r2,r2,-1
  80ae08:	288a703a 	and	r5,r5,r2
  80ae0c:	00e00434 	movhi	r3,32784
  80ae10:	28c5883a 	add	r2,r5,r3
  80ae14:	1004d7fa 	srli	r2,r2,31
  80ae18:	f800283a 	ret

0080ae1c <__fpclassifyd>:
  80ae1c:	00a00034 	movhi	r2,32768
  80ae20:	10bfffc4 	addi	r2,r2,-1
  80ae24:	2884703a 	and	r2,r5,r2
  80ae28:	10000726 	beq	r2,zero,80ae48 <__fpclassifyd+0x2c>
  80ae2c:	00fffc34 	movhi	r3,65520
  80ae30:	019ff834 	movhi	r6,32736
  80ae34:	28c7883a 	add	r3,r5,r3
  80ae38:	31bfffc4 	addi	r6,r6,-1
  80ae3c:	30c00536 	bltu	r6,r3,80ae54 <__fpclassifyd+0x38>
  80ae40:	00800104 	movi	r2,4
  80ae44:	f800283a 	ret
  80ae48:	2000021e 	bne	r4,zero,80ae54 <__fpclassifyd+0x38>
  80ae4c:	00800084 	movi	r2,2
  80ae50:	f800283a 	ret
  80ae54:	00dffc34 	movhi	r3,32752
  80ae58:	019ff834 	movhi	r6,32736
  80ae5c:	28cb883a 	add	r5,r5,r3
  80ae60:	31bfffc4 	addi	r6,r6,-1
  80ae64:	317ff62e 	bgeu	r6,r5,80ae40 <__alt_data_end+0xfff0ae40>
  80ae68:	01400434 	movhi	r5,16
  80ae6c:	297fffc4 	addi	r5,r5,-1
  80ae70:	28800236 	bltu	r5,r2,80ae7c <__fpclassifyd+0x60>
  80ae74:	008000c4 	movi	r2,3
  80ae78:	f800283a 	ret
  80ae7c:	10c00226 	beq	r2,r3,80ae88 <__fpclassifyd+0x6c>
  80ae80:	0005883a 	mov	r2,zero
  80ae84:	f800283a 	ret
  80ae88:	2005003a 	cmpeq	r2,r4,zero
  80ae8c:	f800283a 	ret

0080ae90 <matherr>:
  80ae90:	0005883a 	mov	r2,zero
  80ae94:	f800283a 	ret

0080ae98 <nan>:
  80ae98:	0005883a 	mov	r2,zero
  80ae9c:	00dffe34 	movhi	r3,32760
  80aea0:	f800283a 	ret

0080aea4 <rint>:
  80aea4:	2813d53a 	srai	r9,r5,20
  80aea8:	defff904 	addi	sp,sp,-28
  80aeac:	dc000215 	stw	r16,8(sp)
  80aeb0:	4a41ffcc 	andi	r9,r9,2047
  80aeb4:	dfc00615 	stw	ra,24(sp)
  80aeb8:	dcc00515 	stw	r19,20(sp)
  80aebc:	dc800415 	stw	r18,16(sp)
  80aec0:	dc400315 	stw	r17,12(sp)
  80aec4:	01c004c4 	movi	r7,19
  80aec8:	49bf0044 	addi	r6,r9,-1023
  80aecc:	2811883a 	mov	r8,r5
  80aed0:	2005883a 	mov	r2,r4
  80aed4:	2807883a 	mov	r3,r5
  80aed8:	2015883a 	mov	r10,r4
  80aedc:	2820d7fa 	srli	r16,r5,31
  80aee0:	39801316 	blt	r7,r6,80af30 <rint+0x8c>
  80aee4:	30003d16 	blt	r6,zero,80afdc <rint+0x138>
  80aee8:	01000434 	movhi	r4,16
  80aeec:	213fffc4 	addi	r4,r4,-1
  80aef0:	2189d83a 	sra	r4,r4,r6
  80aef4:	290a703a 	and	r5,r5,r4
  80aef8:	288ab03a 	or	r5,r5,r2
  80aefc:	28001026 	beq	r5,zero,80af40 <rint+0x9c>
  80af00:	2008d07a 	srli	r4,r4,1
  80af04:	4104703a 	and	r2,r8,r4
  80af08:	1294b03a 	or	r10,r2,r10
  80af0c:	50005626 	beq	r10,zero,80b068 <rint+0x1c4>
  80af10:	31c05d26 	beq	r6,r7,80b088 <rint+0x1e4>
  80af14:	0015883a 	mov	r10,zero
  80af18:	00c00134 	movhi	r3,4
  80af1c:	1987d83a 	sra	r3,r3,r6
  80af20:	0108303a 	nor	r4,zero,r4
  80af24:	2210703a 	and	r8,r4,r8
  80af28:	40c6b03a 	or	r3,r8,r3
  80af2c:	00001806 	br	80af90 <rint+0xec>
  80af30:	01c00cc4 	movi	r7,51
  80af34:	3980090e 	bge	r7,r6,80af5c <rint+0xb8>
  80af38:	01c10004 	movi	r7,1024
  80af3c:	31c04e26 	beq	r6,r7,80b078 <rint+0x1d4>
  80af40:	dfc00617 	ldw	ra,24(sp)
  80af44:	dcc00517 	ldw	r19,20(sp)
  80af48:	dc800417 	ldw	r18,16(sp)
  80af4c:	dc400317 	ldw	r17,12(sp)
  80af50:	dc000217 	ldw	r16,8(sp)
  80af54:	dec00704 	addi	sp,sp,28
  80af58:	f800283a 	ret
  80af5c:	4a7efb44 	addi	r9,r9,-1043
  80af60:	013fffc4 	movi	r4,-1
  80af64:	2248d83a 	srl	r4,r4,r9
  80af68:	110a703a 	and	r5,r2,r4
  80af6c:	28004026 	beq	r5,zero,80b070 <rint+0x1cc>
  80af70:	2008d07a 	srli	r4,r4,1
  80af74:	1104703a 	and	r2,r2,r4
  80af78:	10000526 	beq	r2,zero,80af90 <rint+0xec>
  80af7c:	00900034 	movhi	r2,16384
  80af80:	1253d83a 	sra	r9,r2,r9
  80af84:	0108303a 	nor	r4,zero,r4
  80af88:	2294703a 	and	r10,r4,r10
  80af8c:	4a94b03a 	or	r10,r9,r10
  80af90:	802090fa 	slli	r16,r16,3
  80af94:	180b883a 	mov	r5,r3
  80af98:	00c020b4 	movhi	r3,130
  80af9c:	18e6e804 	addi	r3,r3,-25696
  80afa0:	1c21883a 	add	r16,r3,r16
  80afa4:	84400017 	ldw	r17,0(r16)
  80afa8:	84000117 	ldw	r16,4(r16)
  80afac:	5009883a 	mov	r4,r10
  80afb0:	880d883a 	mov	r6,r17
  80afb4:	800f883a 	mov	r7,r16
  80afb8:	080c7cc0 	call	80c7cc <__adddf3>
  80afbc:	d8800015 	stw	r2,0(sp)
  80afc0:	d8c00115 	stw	r3,4(sp)
  80afc4:	d9000017 	ldw	r4,0(sp)
  80afc8:	d9400117 	ldw	r5,4(sp)
  80afcc:	880d883a 	mov	r6,r17
  80afd0:	800f883a 	mov	r7,r16
  80afd4:	080e50c0 	call	80e50c <__subdf3>
  80afd8:	003fd906 	br	80af40 <__alt_data_end+0xfff0af40>
  80afdc:	04600034 	movhi	r17,32768
  80afe0:	8c7fffc4 	addi	r17,r17,-1
  80afe4:	2c46703a 	and	r3,r5,r17
  80afe8:	1906b03a 	or	r3,r3,r4
  80afec:	18002026 	beq	r3,zero,80b070 <rint+0x1cc>
  80aff0:	01800434 	movhi	r6,16
  80aff4:	31bfffc4 	addi	r6,r6,-1
  80aff8:	298c703a 	and	r6,r5,r6
  80affc:	3104b03a 	or	r2,r6,r4
  80b000:	008bc83a 	sub	r5,zero,r2
  80b004:	800690fa 	slli	r3,r16,3
  80b008:	2884b03a 	or	r2,r5,r2
  80b00c:	014020b4 	movhi	r5,130
  80b010:	2966e804 	addi	r5,r5,-25696
  80b014:	28c7883a 	add	r3,r5,r3
  80b018:	1004d33a 	srli	r2,r2,12
  80b01c:	1cc00017 	ldw	r19,0(r3)
  80b020:	1c800117 	ldw	r18,4(r3)
  80b024:	417fffac 	andhi	r5,r8,65534
  80b028:	1080022c 	andhi	r2,r2,8
  80b02c:	980d883a 	mov	r6,r19
  80b030:	900f883a 	mov	r7,r18
  80b034:	114ab03a 	or	r5,r2,r5
  80b038:	080c7cc0 	call	80c7cc <__adddf3>
  80b03c:	d8800015 	stw	r2,0(sp)
  80b040:	d8c00115 	stw	r3,4(sp)
  80b044:	d9000017 	ldw	r4,0(sp)
  80b048:	d9400117 	ldw	r5,4(sp)
  80b04c:	980d883a 	mov	r6,r19
  80b050:	900f883a 	mov	r7,r18
  80b054:	080e50c0 	call	80e50c <__subdf3>
  80b058:	800897fa 	slli	r4,r16,31
  80b05c:	1c46703a 	and	r3,r3,r17
  80b060:	1906b03a 	or	r3,r3,r4
  80b064:	003fb606 	br	80af40 <__alt_data_end+0xfff0af40>
  80b068:	0015883a 	mov	r10,zero
  80b06c:	003fc806 	br	80af90 <__alt_data_end+0xfff0af90>
  80b070:	4007883a 	mov	r3,r8
  80b074:	003fb206 	br	80af40 <__alt_data_end+0xfff0af40>
  80b078:	200d883a 	mov	r6,r4
  80b07c:	280f883a 	mov	r7,r5
  80b080:	080c7cc0 	call	80c7cc <__adddf3>
  80b084:	003fae06 	br	80af40 <__alt_data_end+0xfff0af40>
  80b088:	02a00034 	movhi	r10,32768
  80b08c:	003fa206 	br	80af18 <__alt_data_end+0xfff0af18>

0080b090 <scalbn>:
  80b090:	2a1ffc2c 	andhi	r8,r5,32752
  80b094:	4011d53a 	srai	r8,r8,20
  80b098:	defffe04 	addi	sp,sp,-8
  80b09c:	dc000015 	stw	r16,0(sp)
  80b0a0:	dfc00115 	stw	ra,4(sp)
  80b0a4:	280f883a 	mov	r7,r5
  80b0a8:	2015883a 	mov	r10,r4
  80b0ac:	3021883a 	mov	r16,r6
  80b0b0:	40001e1e 	bne	r8,zero,80b12c <scalbn+0x9c>
  80b0b4:	00a00034 	movhi	r2,32768
  80b0b8:	10bfffc4 	addi	r2,r2,-1
  80b0bc:	2884703a 	and	r2,r5,r2
  80b0c0:	1104b03a 	or	r2,r2,r4
  80b0c4:	10002226 	beq	r2,zero,80b150 <scalbn+0xc0>
  80b0c8:	01d0d434 	movhi	r7,17232
  80b0cc:	000d883a 	mov	r6,zero
  80b0d0:	080dca00 	call	80dca0 <__muldf3>
  80b0d4:	013ffff4 	movhi	r4,65535
  80b0d8:	210f2c04 	addi	r4,r4,15536
  80b0dc:	1015883a 	mov	r10,r2
  80b0e0:	180f883a 	mov	r7,r3
  80b0e4:	81002a16 	blt	r16,r4,80b190 <scalbn+0x100>
  80b0e8:	191ffc2c 	andhi	r4,r3,32752
  80b0ec:	2009d53a 	srai	r4,r4,20
  80b0f0:	223ff284 	addi	r8,r4,-54
  80b0f4:	8211883a 	add	r8,r16,r8
  80b0f8:	0081ff84 	movi	r2,2046
  80b0fc:	12002f16 	blt	r2,r8,80b1bc <scalbn+0x12c>
  80b100:	0200190e 	bge	zero,r8,80b168 <scalbn+0xd8>
  80b104:	4010953a 	slli	r8,r8,20
  80b108:	01600434 	movhi	r5,32784
  80b10c:	297fffc4 	addi	r5,r5,-1
  80b110:	194e703a 	and	r7,r3,r5
  80b114:	5005883a 	mov	r2,r10
  80b118:	3a06b03a 	or	r3,r7,r8
  80b11c:	dfc00117 	ldw	ra,4(sp)
  80b120:	dc000017 	ldw	r16,0(sp)
  80b124:	dec00204 	addi	sp,sp,8
  80b128:	f800283a 	ret
  80b12c:	0081ffc4 	movi	r2,2047
  80b130:	2807883a 	mov	r3,r5
  80b134:	40bfef1e 	bne	r8,r2,80b0f4 <__alt_data_end+0xfff0b0f4>
  80b138:	200d883a 	mov	r6,r4
  80b13c:	080c7cc0 	call	80c7cc <__adddf3>
  80b140:	dfc00117 	ldw	ra,4(sp)
  80b144:	dc000017 	ldw	r16,0(sp)
  80b148:	dec00204 	addi	sp,sp,8
  80b14c:	f800283a 	ret
  80b150:	2005883a 	mov	r2,r4
  80b154:	2807883a 	mov	r3,r5
  80b158:	dfc00117 	ldw	ra,4(sp)
  80b15c:	dc000017 	ldw	r16,0(sp)
  80b160:	dec00204 	addi	sp,sp,8
  80b164:	f800283a 	ret
  80b168:	00bff2c4 	movi	r2,-53
  80b16c:	4080240e 	bge	r8,r2,80b200 <scalbn+0x170>
  80b170:	00b0d414 	movui	r2,50000
  80b174:	14001116 	blt	r2,r16,80b1bc <scalbn+0x12c>
  80b178:	0130be74 	movhi	r4,49913
  80b17c:	01406974 	movhi	r5,421
  80b180:	213cd644 	addi	r4,r4,-3239
  80b184:	295b87c4 	addi	r5,r5,28191
  80b188:	500d883a 	mov	r6,r10
  80b18c:	080b22c0 	call	80b22c <copysign>
  80b190:	01b0be74 	movhi	r6,49913
  80b194:	01c06974 	movhi	r7,421
  80b198:	31bcd644 	addi	r6,r6,-3239
  80b19c:	39db87c4 	addi	r7,r7,28191
  80b1a0:	1009883a 	mov	r4,r2
  80b1a4:	180b883a 	mov	r5,r3
  80b1a8:	080dca00 	call	80dca0 <__muldf3>
  80b1ac:	dfc00117 	ldw	ra,4(sp)
  80b1b0:	dc000017 	ldw	r16,0(sp)
  80b1b4:	dec00204 	addi	sp,sp,8
  80b1b8:	f800283a 	ret
  80b1bc:	01220034 	movhi	r4,34816
  80b1c0:	015f8e34 	movhi	r5,32312
  80b1c4:	500d883a 	mov	r6,r10
  80b1c8:	211d6704 	addi	r4,r4,30108
  80b1cc:	29790f04 	addi	r5,r5,-7108
  80b1d0:	080b22c0 	call	80b22c <copysign>
  80b1d4:	01a20034 	movhi	r6,34816
  80b1d8:	01df8e34 	movhi	r7,32312
  80b1dc:	319d6704 	addi	r6,r6,30108
  80b1e0:	39f90f04 	addi	r7,r7,-7108
  80b1e4:	1009883a 	mov	r4,r2
  80b1e8:	180b883a 	mov	r5,r3
  80b1ec:	080dca00 	call	80dca0 <__muldf3>
  80b1f0:	dfc00117 	ldw	ra,4(sp)
  80b1f4:	dc000017 	ldw	r16,0(sp)
  80b1f8:	dec00204 	addi	sp,sp,8
  80b1fc:	f800283a 	ret
  80b200:	42000d84 	addi	r8,r8,54
  80b204:	4012953a 	slli	r9,r8,20
  80b208:	01e00434 	movhi	r7,32784
  80b20c:	39ffffc4 	addi	r7,r7,-1
  80b210:	19ca703a 	and	r5,r3,r7
  80b214:	000d883a 	mov	r6,zero
  80b218:	01cf2434 	movhi	r7,15504
  80b21c:	5009883a 	mov	r4,r10
  80b220:	494ab03a 	or	r5,r9,r5
  80b224:	080dca00 	call	80dca0 <__muldf3>
  80b228:	003fbc06 	br	80b11c <__alt_data_end+0xfff0b11c>

0080b22c <copysign>:
  80b22c:	2005883a 	mov	r2,r4
  80b230:	01200034 	movhi	r4,32768
  80b234:	213fffc4 	addi	r4,r4,-1
  80b238:	38e0002c 	andhi	r3,r7,32768
  80b23c:	290a703a 	and	r5,r5,r4
  80b240:	28c6b03a 	or	r3,r5,r3
  80b244:	f800283a 	ret

0080b248 <__mulsi3>:
  80b248:	0005883a 	mov	r2,zero
  80b24c:	20000726 	beq	r4,zero,80b26c <__mulsi3+0x24>
  80b250:	20c0004c 	andi	r3,r4,1
  80b254:	2008d07a 	srli	r4,r4,1
  80b258:	18000126 	beq	r3,zero,80b260 <__mulsi3+0x18>
  80b25c:	1145883a 	add	r2,r2,r5
  80b260:	294b883a 	add	r5,r5,r5
  80b264:	203ffa1e 	bne	r4,zero,80b250 <__alt_data_end+0xfff0b250>
  80b268:	f800283a 	ret
  80b26c:	f800283a 	ret

0080b270 <__addsf3>:
  80b270:	defffc04 	addi	sp,sp,-16
  80b274:	2004d7fa 	srli	r2,r4,31
  80b278:	280cd5fa 	srli	r6,r5,23
  80b27c:	dc000015 	stw	r16,0(sp)
  80b280:	00c02034 	movhi	r3,128
  80b284:	2020d5fa 	srli	r16,r4,23
  80b288:	280ed7fa 	srli	r7,r5,31
  80b28c:	18ffffc4 	addi	r3,r3,-1
  80b290:	dc400115 	stw	r17,4(sp)
  80b294:	1908703a 	and	r4,r3,r4
  80b298:	194a703a 	and	r5,r3,r5
  80b29c:	dfc00315 	stw	ra,12(sp)
  80b2a0:	dc800215 	stw	r18,8(sp)
  80b2a4:	14403fcc 	andi	r17,r2,255
  80b2a8:	84003fcc 	andi	r16,r16,255
  80b2ac:	200890fa 	slli	r4,r4,3
  80b2b0:	31803fcc 	andi	r6,r6,255
  80b2b4:	280a90fa 	slli	r5,r5,3
  80b2b8:	89c05026 	beq	r17,r7,80b3fc <__addsf3+0x18c>
  80b2bc:	8185c83a 	sub	r2,r16,r6
  80b2c0:	00807a0e 	bge	zero,r2,80b4ac <__addsf3+0x23c>
  80b2c4:	30001e1e 	bne	r6,zero,80b340 <__addsf3+0xd0>
  80b2c8:	28006d1e 	bne	r5,zero,80b480 <__addsf3+0x210>
  80b2cc:	208001cc 	andi	r2,r4,7
  80b2d0:	10000426 	beq	r2,zero,80b2e4 <__addsf3+0x74>
  80b2d4:	208003cc 	andi	r2,r4,15
  80b2d8:	00c00104 	movi	r3,4
  80b2dc:	10c00126 	beq	r2,r3,80b2e4 <__addsf3+0x74>
  80b2e0:	20c9883a 	add	r4,r4,r3
  80b2e4:	2081002c 	andhi	r2,r4,1024
  80b2e8:	10003926 	beq	r2,zero,80b3d0 <__addsf3+0x160>
  80b2ec:	84000044 	addi	r16,r16,1
  80b2f0:	00803fc4 	movi	r2,255
  80b2f4:	80807826 	beq	r16,r2,80b4d8 <__addsf3+0x268>
  80b2f8:	200891ba 	slli	r4,r4,6
  80b2fc:	8805883a 	mov	r2,r17
  80b300:	2008d27a 	srli	r4,r4,9
  80b304:	84003fcc 	andi	r16,r16,255
  80b308:	800695fa 	slli	r3,r16,23
  80b30c:	10803fcc 	andi	r2,r2,255
  80b310:	04002034 	movhi	r16,128
  80b314:	843fffc4 	addi	r16,r16,-1
  80b318:	100497fa 	slli	r2,r2,31
  80b31c:	2408703a 	and	r4,r4,r16
  80b320:	20e0b03a 	or	r16,r4,r3
  80b324:	8084b03a 	or	r2,r16,r2
  80b328:	dfc00317 	ldw	ra,12(sp)
  80b32c:	dc800217 	ldw	r18,8(sp)
  80b330:	dc400117 	ldw	r17,4(sp)
  80b334:	dc000017 	ldw	r16,0(sp)
  80b338:	dec00404 	addi	sp,sp,16
  80b33c:	f800283a 	ret
  80b340:	00c03fc4 	movi	r3,255
  80b344:	80ffe126 	beq	r16,r3,80b2cc <__alt_data_end+0xfff0b2cc>
  80b348:	29410034 	orhi	r5,r5,1024
  80b34c:	00c006c4 	movi	r3,27
  80b350:	18807516 	blt	r3,r2,80b528 <__addsf3+0x2b8>
  80b354:	00c00804 	movi	r3,32
  80b358:	1887c83a 	sub	r3,r3,r2
  80b35c:	28c6983a 	sll	r3,r5,r3
  80b360:	288ad83a 	srl	r5,r5,r2
  80b364:	1804c03a 	cmpne	r2,r3,zero
  80b368:	288ab03a 	or	r5,r5,r2
  80b36c:	2149c83a 	sub	r4,r4,r5
  80b370:	2081002c 	andhi	r2,r4,1024
  80b374:	10001426 	beq	r2,zero,80b3c8 <__addsf3+0x158>
  80b378:	04810034 	movhi	r18,1024
  80b37c:	94bfffc4 	addi	r18,r18,-1
  80b380:	24a4703a 	and	r18,r4,r18
  80b384:	9009883a 	mov	r4,r18
  80b388:	080f21c0 	call	80f21c <__clzsi2>
  80b38c:	10bffec4 	addi	r2,r2,-5
  80b390:	90a4983a 	sll	r18,r18,r2
  80b394:	14005416 	blt	r2,r16,80b4e8 <__addsf3+0x278>
  80b398:	1405c83a 	sub	r2,r2,r16
  80b39c:	11000044 	addi	r4,r2,1
  80b3a0:	00800804 	movi	r2,32
  80b3a4:	1105c83a 	sub	r2,r2,r4
  80b3a8:	9084983a 	sll	r2,r18,r2
  80b3ac:	9124d83a 	srl	r18,r18,r4
  80b3b0:	0021883a 	mov	r16,zero
  80b3b4:	1008c03a 	cmpne	r4,r2,zero
  80b3b8:	9108b03a 	or	r4,r18,r4
  80b3bc:	003fc306 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b3c0:	1000db26 	beq	r2,zero,80b730 <__addsf3+0x4c0>
  80b3c4:	1009883a 	mov	r4,r2
  80b3c8:	208001cc 	andi	r2,r4,7
  80b3cc:	103fc11e 	bne	r2,zero,80b2d4 <__alt_data_end+0xfff0b2d4>
  80b3d0:	2006d0fa 	srli	r3,r4,3
  80b3d4:	01003fc4 	movi	r4,255
  80b3d8:	8805883a 	mov	r2,r17
  80b3dc:	8100241e 	bne	r16,r4,80b470 <__addsf3+0x200>
  80b3e0:	18006e26 	beq	r3,zero,80b59c <__addsf3+0x32c>
  80b3e4:	19001034 	orhi	r4,r3,64
  80b3e8:	00c02034 	movhi	r3,128
  80b3ec:	18ffffc4 	addi	r3,r3,-1
  80b3f0:	043fffc4 	movi	r16,-1
  80b3f4:	20c8703a 	and	r4,r4,r3
  80b3f8:	003fc206 	br	80b304 <__alt_data_end+0xfff0b304>
  80b3fc:	8187c83a 	sub	r3,r16,r6
  80b400:	00c03e0e 	bge	zero,r3,80b4fc <__addsf3+0x28c>
  80b404:	30002326 	beq	r6,zero,80b494 <__addsf3+0x224>
  80b408:	01803fc4 	movi	r6,255
  80b40c:	81bfaf26 	beq	r16,r6,80b2cc <__alt_data_end+0xfff0b2cc>
  80b410:	29410034 	orhi	r5,r5,1024
  80b414:	018006c4 	movi	r6,27
  80b418:	30c07416 	blt	r6,r3,80b5ec <__addsf3+0x37c>
  80b41c:	01800804 	movi	r6,32
  80b420:	30cdc83a 	sub	r6,r6,r3
  80b424:	298c983a 	sll	r6,r5,r6
  80b428:	28cad83a 	srl	r5,r5,r3
  80b42c:	3006c03a 	cmpne	r3,r6,zero
  80b430:	28cab03a 	or	r5,r5,r3
  80b434:	2149883a 	add	r4,r4,r5
  80b438:	20c1002c 	andhi	r3,r4,1024
  80b43c:	183fe226 	beq	r3,zero,80b3c8 <__alt_data_end+0xfff0b3c8>
  80b440:	84000044 	addi	r16,r16,1
  80b444:	00c03fc4 	movi	r3,255
  80b448:	80c05426 	beq	r16,r3,80b59c <__addsf3+0x32c>
  80b44c:	00bf0034 	movhi	r2,64512
  80b450:	10bfffc4 	addi	r2,r2,-1
  80b454:	20c0004c 	andi	r3,r4,1
  80b458:	2088703a 	and	r4,r4,r2
  80b45c:	2008d07a 	srli	r4,r4,1
  80b460:	20c8b03a 	or	r4,r4,r3
  80b464:	003f9906 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b468:	0007883a 	mov	r3,zero
  80b46c:	0005883a 	mov	r2,zero
  80b470:	01002034 	movhi	r4,128
  80b474:	213fffc4 	addi	r4,r4,-1
  80b478:	1908703a 	and	r4,r3,r4
  80b47c:	003fa106 	br	80b304 <__alt_data_end+0xfff0b304>
  80b480:	10bfffc4 	addi	r2,r2,-1
  80b484:	103fb926 	beq	r2,zero,80b36c <__alt_data_end+0xfff0b36c>
  80b488:	00c03fc4 	movi	r3,255
  80b48c:	80ffaf1e 	bne	r16,r3,80b34c <__alt_data_end+0xfff0b34c>
  80b490:	003f8e06 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b494:	283f8d26 	beq	r5,zero,80b2cc <__alt_data_end+0xfff0b2cc>
  80b498:	18ffffc4 	addi	r3,r3,-1
  80b49c:	183fe526 	beq	r3,zero,80b434 <__alt_data_end+0xfff0b434>
  80b4a0:	01803fc4 	movi	r6,255
  80b4a4:	81bfdb1e 	bne	r16,r6,80b414 <__alt_data_end+0xfff0b414>
  80b4a8:	003f8806 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b4ac:	1000201e 	bne	r2,zero,80b530 <__addsf3+0x2c0>
  80b4b0:	80800044 	addi	r2,r16,1
  80b4b4:	10803fcc 	andi	r2,r2,255
  80b4b8:	01800044 	movi	r6,1
  80b4bc:	3080450e 	bge	r6,r2,80b5d4 <__addsf3+0x364>
  80b4c0:	2165c83a 	sub	r18,r4,r5
  80b4c4:	90c1002c 	andhi	r3,r18,1024
  80b4c8:	18002b26 	beq	r3,zero,80b578 <__addsf3+0x308>
  80b4cc:	2925c83a 	sub	r18,r5,r4
  80b4d0:	3823883a 	mov	r17,r7
  80b4d4:	003fab06 	br	80b384 <__alt_data_end+0xfff0b384>
  80b4d8:	8805883a 	mov	r2,r17
  80b4dc:	043fffc4 	movi	r16,-1
  80b4e0:	0009883a 	mov	r4,zero
  80b4e4:	003f8706 	br	80b304 <__alt_data_end+0xfff0b304>
  80b4e8:	013f0034 	movhi	r4,64512
  80b4ec:	213fffc4 	addi	r4,r4,-1
  80b4f0:	80a1c83a 	sub	r16,r16,r2
  80b4f4:	9108703a 	and	r4,r18,r4
  80b4f8:	003f7406 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b4fc:	1800411e 	bne	r3,zero,80b604 <__addsf3+0x394>
  80b500:	80c00044 	addi	r3,r16,1
  80b504:	19c03fcc 	andi	r7,r3,255
  80b508:	01800044 	movi	r6,1
  80b50c:	31c0260e 	bge	r6,r7,80b5a8 <__addsf3+0x338>
  80b510:	01803fc4 	movi	r6,255
  80b514:	19802126 	beq	r3,r6,80b59c <__addsf3+0x32c>
  80b518:	2149883a 	add	r4,r4,r5
  80b51c:	2008d07a 	srli	r4,r4,1
  80b520:	1821883a 	mov	r16,r3
  80b524:	003f6906 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b528:	01400044 	movi	r5,1
  80b52c:	003f8f06 	br	80b36c <__alt_data_end+0xfff0b36c>
  80b530:	8000151e 	bne	r16,zero,80b588 <__addsf3+0x318>
  80b534:	20002f26 	beq	r4,zero,80b5f4 <__addsf3+0x384>
  80b538:	0084303a 	nor	r2,zero,r2
  80b53c:	10000a26 	beq	r2,zero,80b568 <__addsf3+0x2f8>
  80b540:	00c03fc4 	movi	r3,255
  80b544:	30c02b26 	beq	r6,r3,80b5f4 <__addsf3+0x384>
  80b548:	00c006c4 	movi	r3,27
  80b54c:	18806d16 	blt	r3,r2,80b704 <__addsf3+0x494>
  80b550:	00c00804 	movi	r3,32
  80b554:	1887c83a 	sub	r3,r3,r2
  80b558:	20c6983a 	sll	r3,r4,r3
  80b55c:	2084d83a 	srl	r2,r4,r2
  80b560:	1808c03a 	cmpne	r4,r3,zero
  80b564:	1108b03a 	or	r4,r2,r4
  80b568:	2909c83a 	sub	r4,r5,r4
  80b56c:	3021883a 	mov	r16,r6
  80b570:	3823883a 	mov	r17,r7
  80b574:	003f7e06 	br	80b370 <__alt_data_end+0xfff0b370>
  80b578:	903f821e 	bne	r18,zero,80b384 <__alt_data_end+0xfff0b384>
  80b57c:	0005883a 	mov	r2,zero
  80b580:	0021883a 	mov	r16,zero
  80b584:	003fba06 	br	80b470 <__alt_data_end+0xfff0b470>
  80b588:	00c03fc4 	movi	r3,255
  80b58c:	30c01926 	beq	r6,r3,80b5f4 <__addsf3+0x384>
  80b590:	0085c83a 	sub	r2,zero,r2
  80b594:	21010034 	orhi	r4,r4,1024
  80b598:	003feb06 	br	80b548 <__alt_data_end+0xfff0b548>
  80b59c:	043fffc4 	movi	r16,-1
  80b5a0:	0009883a 	mov	r4,zero
  80b5a4:	003f5706 	br	80b304 <__alt_data_end+0xfff0b304>
  80b5a8:	80004a1e 	bne	r16,zero,80b6d4 <__addsf3+0x464>
  80b5ac:	20005926 	beq	r4,zero,80b714 <__addsf3+0x4a4>
  80b5b0:	283f4626 	beq	r5,zero,80b2cc <__alt_data_end+0xfff0b2cc>
  80b5b4:	2149883a 	add	r4,r4,r5
  80b5b8:	2081002c 	andhi	r2,r4,1024
  80b5bc:	103f8226 	beq	r2,zero,80b3c8 <__alt_data_end+0xfff0b3c8>
  80b5c0:	00bf0034 	movhi	r2,64512
  80b5c4:	10bfffc4 	addi	r2,r2,-1
  80b5c8:	3021883a 	mov	r16,r6
  80b5cc:	2088703a 	and	r4,r4,r2
  80b5d0:	003f3e06 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b5d4:	8000121e 	bne	r16,zero,80b620 <__addsf3+0x3b0>
  80b5d8:	2000261e 	bne	r4,zero,80b674 <__addsf3+0x404>
  80b5dc:	283fa226 	beq	r5,zero,80b468 <__alt_data_end+0xfff0b468>
  80b5e0:	2809883a 	mov	r4,r5
  80b5e4:	3823883a 	mov	r17,r7
  80b5e8:	003f3806 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b5ec:	01400044 	movi	r5,1
  80b5f0:	003f9006 	br	80b434 <__alt_data_end+0xfff0b434>
  80b5f4:	2809883a 	mov	r4,r5
  80b5f8:	3021883a 	mov	r16,r6
  80b5fc:	3823883a 	mov	r17,r7
  80b600:	003f3206 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b604:	80000c1e 	bne	r16,zero,80b638 <__addsf3+0x3c8>
  80b608:	20002f26 	beq	r4,zero,80b6c8 <__addsf3+0x458>
  80b60c:	00c6303a 	nor	r3,zero,r3
  80b610:	18002b1e 	bne	r3,zero,80b6c0 <__addsf3+0x450>
  80b614:	2149883a 	add	r4,r4,r5
  80b618:	3021883a 	mov	r16,r6
  80b61c:	003f8606 	br	80b438 <__alt_data_end+0xfff0b438>
  80b620:	20001b1e 	bne	r4,zero,80b690 <__addsf3+0x420>
  80b624:	28003926 	beq	r5,zero,80b70c <__addsf3+0x49c>
  80b628:	2809883a 	mov	r4,r5
  80b62c:	3823883a 	mov	r17,r7
  80b630:	04003fc4 	movi	r16,255
  80b634:	003f2506 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b638:	01c03fc4 	movi	r7,255
  80b63c:	31c02226 	beq	r6,r7,80b6c8 <__addsf3+0x458>
  80b640:	00c7c83a 	sub	r3,zero,r3
  80b644:	21010034 	orhi	r4,r4,1024
  80b648:	01c006c4 	movi	r7,27
  80b64c:	38c03616 	blt	r7,r3,80b728 <__addsf3+0x4b8>
  80b650:	01c00804 	movi	r7,32
  80b654:	38cfc83a 	sub	r7,r7,r3
  80b658:	21ce983a 	sll	r7,r4,r7
  80b65c:	20c6d83a 	srl	r3,r4,r3
  80b660:	3808c03a 	cmpne	r4,r7,zero
  80b664:	1906b03a 	or	r3,r3,r4
  80b668:	1949883a 	add	r4,r3,r5
  80b66c:	3021883a 	mov	r16,r6
  80b670:	003f7106 	br	80b438 <__alt_data_end+0xfff0b438>
  80b674:	283f1526 	beq	r5,zero,80b2cc <__alt_data_end+0xfff0b2cc>
  80b678:	2145c83a 	sub	r2,r4,r5
  80b67c:	10c1002c 	andhi	r3,r2,1024
  80b680:	183f4f26 	beq	r3,zero,80b3c0 <__alt_data_end+0xfff0b3c0>
  80b684:	2909c83a 	sub	r4,r5,r4
  80b688:	3823883a 	mov	r17,r7
  80b68c:	003f0f06 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b690:	28001a26 	beq	r5,zero,80b6fc <__addsf3+0x48c>
  80b694:	2008d0fa 	srli	r4,r4,3
  80b698:	2080102c 	andhi	r2,r4,64
  80b69c:	10000526 	beq	r2,zero,80b6b4 <__addsf3+0x444>
  80b6a0:	280ad0fa 	srli	r5,r5,3
  80b6a4:	2880102c 	andhi	r2,r5,64
  80b6a8:	1000021e 	bne	r2,zero,80b6b4 <__addsf3+0x444>
  80b6ac:	2809883a 	mov	r4,r5
  80b6b0:	3823883a 	mov	r17,r7
  80b6b4:	200890fa 	slli	r4,r4,3
  80b6b8:	04003fc4 	movi	r16,255
  80b6bc:	003f0306 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b6c0:	01c03fc4 	movi	r7,255
  80b6c4:	31ffe01e 	bne	r6,r7,80b648 <__alt_data_end+0xfff0b648>
  80b6c8:	2809883a 	mov	r4,r5
  80b6cc:	3021883a 	mov	r16,r6
  80b6d0:	003efe06 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b6d4:	20001126 	beq	r4,zero,80b71c <__addsf3+0x4ac>
  80b6d8:	28000826 	beq	r5,zero,80b6fc <__addsf3+0x48c>
  80b6dc:	2008d0fa 	srli	r4,r4,3
  80b6e0:	2080102c 	andhi	r2,r4,64
  80b6e4:	103ff326 	beq	r2,zero,80b6b4 <__alt_data_end+0xfff0b6b4>
  80b6e8:	280ad0fa 	srli	r5,r5,3
  80b6ec:	2880102c 	andhi	r2,r5,64
  80b6f0:	103ff01e 	bne	r2,zero,80b6b4 <__alt_data_end+0xfff0b6b4>
  80b6f4:	2809883a 	mov	r4,r5
  80b6f8:	003fee06 	br	80b6b4 <__alt_data_end+0xfff0b6b4>
  80b6fc:	04003fc4 	movi	r16,255
  80b700:	003ef206 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b704:	01000044 	movi	r4,1
  80b708:	003f9706 	br	80b568 <__alt_data_end+0xfff0b568>
  80b70c:	0005883a 	mov	r2,zero
  80b710:	003f3406 	br	80b3e4 <__alt_data_end+0xfff0b3e4>
  80b714:	2809883a 	mov	r4,r5
  80b718:	003eec06 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b71c:	2809883a 	mov	r4,r5
  80b720:	04003fc4 	movi	r16,255
  80b724:	003ee906 	br	80b2cc <__alt_data_end+0xfff0b2cc>
  80b728:	00c00044 	movi	r3,1
  80b72c:	003fce06 	br	80b668 <__alt_data_end+0xfff0b668>
  80b730:	0005883a 	mov	r2,zero
  80b734:	003f4e06 	br	80b470 <__alt_data_end+0xfff0b470>

0080b738 <__divsf3>:
  80b738:	defff504 	addi	sp,sp,-44
  80b73c:	200cd5fa 	srli	r6,r4,23
  80b740:	dcc00415 	stw	r19,16(sp)
  80b744:	2026d7fa 	srli	r19,r4,31
  80b748:	00c02034 	movhi	r3,128
  80b74c:	dd800715 	stw	r22,28(sp)
  80b750:	dd000515 	stw	r20,20(sp)
  80b754:	dc800315 	stw	r18,12(sp)
  80b758:	18ffffc4 	addi	r3,r3,-1
  80b75c:	dfc00a15 	stw	ra,40(sp)
  80b760:	df000915 	stw	fp,36(sp)
  80b764:	ddc00815 	stw	r23,32(sp)
  80b768:	dd400615 	stw	r21,24(sp)
  80b76c:	dc400215 	stw	r17,8(sp)
  80b770:	dc000115 	stw	r16,4(sp)
  80b774:	35003fcc 	andi	r20,r6,255
  80b778:	1924703a 	and	r18,r3,r4
  80b77c:	9d803fcc 	andi	r22,r19,255
  80b780:	a0005226 	beq	r20,zero,80b8cc <__divsf3+0x194>
  80b784:	00803fc4 	movi	r2,255
  80b788:	a0802e26 	beq	r20,r2,80b844 <__divsf3+0x10c>
  80b78c:	91002034 	orhi	r4,r18,128
  80b790:	202490fa 	slli	r18,r4,3
  80b794:	a53fe044 	addi	r20,r20,-127
  80b798:	0021883a 	mov	r16,zero
  80b79c:	002f883a 	mov	r23,zero
  80b7a0:	280cd5fa 	srli	r6,r5,23
  80b7a4:	282ad7fa 	srli	r21,r5,31
  80b7a8:	00c02034 	movhi	r3,128
  80b7ac:	18ffffc4 	addi	r3,r3,-1
  80b7b0:	31803fcc 	andi	r6,r6,255
  80b7b4:	1962703a 	and	r17,r3,r5
  80b7b8:	af003fcc 	andi	fp,r21,255
  80b7bc:	30004a26 	beq	r6,zero,80b8e8 <__divsf3+0x1b0>
  80b7c0:	00803fc4 	movi	r2,255
  80b7c4:	30804526 	beq	r6,r2,80b8dc <__divsf3+0x1a4>
  80b7c8:	89402034 	orhi	r5,r17,128
  80b7cc:	282290fa 	slli	r17,r5,3
  80b7d0:	31bfe044 	addi	r6,r6,-127
  80b7d4:	000b883a 	mov	r5,zero
  80b7d8:	2c20b03a 	or	r16,r5,r16
  80b7dc:	802090ba 	slli	r16,r16,2
  80b7e0:	00802074 	movhi	r2,129
  80b7e4:	10ae0104 	addi	r2,r2,-18428
  80b7e8:	80a1883a 	add	r16,r16,r2
  80b7ec:	81000017 	ldw	r4,0(r16)
  80b7f0:	9d46f03a 	xor	r3,r19,r21
  80b7f4:	180f883a 	mov	r7,r3
  80b7f8:	18803fcc 	andi	r2,r3,255
  80b7fc:	a18dc83a 	sub	r6,r20,r6
  80b800:	2000683a 	jmp	r4
  80b804:	0080b9e8 	cmpgeui	r2,zero,743
  80b808:	0080b86c 	andhi	r2,zero,737
  80b80c:	0080b9dc 	xori	r2,zero,743
  80b810:	0080b858 	cmpnei	r2,zero,737
  80b814:	0080b9dc 	xori	r2,zero,743
  80b818:	0080b9b4 	movhi	r2,742
  80b81c:	0080b9dc 	xori	r2,zero,743
  80b820:	0080b858 	cmpnei	r2,zero,737
  80b824:	0080b86c 	andhi	r2,zero,737
  80b828:	0080b86c 	andhi	r2,zero,737
  80b82c:	0080b9b4 	movhi	r2,742
  80b830:	0080b858 	cmpnei	r2,zero,737
  80b834:	0080bac8 	cmpgei	r2,zero,747
  80b838:	0080bac8 	cmpgei	r2,zero,747
  80b83c:	0080bac8 	cmpgei	r2,zero,747
  80b840:	0080ba7c 	xorhi	r2,zero,745
  80b844:	9000581e 	bne	r18,zero,80b9a8 <__divsf3+0x270>
  80b848:	04000204 	movi	r16,8
  80b84c:	05c00084 	movi	r23,2
  80b850:	003fd306 	br	80b7a0 <__alt_data_end+0xfff0b7a0>
  80b854:	0023883a 	mov	r17,zero
  80b858:	e02d883a 	mov	r22,fp
  80b85c:	282f883a 	mov	r23,r5
  80b860:	00800084 	movi	r2,2
  80b864:	b8808f1e 	bne	r23,r2,80baa4 <__divsf3+0x36c>
  80b868:	b005883a 	mov	r2,r22
  80b86c:	11c0004c 	andi	r7,r2,1
  80b870:	013fffc4 	movi	r4,-1
  80b874:	000d883a 	mov	r6,zero
  80b878:	21003fcc 	andi	r4,r4,255
  80b87c:	200895fa 	slli	r4,r4,23
  80b880:	38803fcc 	andi	r2,r7,255
  80b884:	00c02034 	movhi	r3,128
  80b888:	100497fa 	slli	r2,r2,31
  80b88c:	18ffffc4 	addi	r3,r3,-1
  80b890:	30c6703a 	and	r3,r6,r3
  80b894:	1906b03a 	or	r3,r3,r4
  80b898:	1884b03a 	or	r2,r3,r2
  80b89c:	dfc00a17 	ldw	ra,40(sp)
  80b8a0:	df000917 	ldw	fp,36(sp)
  80b8a4:	ddc00817 	ldw	r23,32(sp)
  80b8a8:	dd800717 	ldw	r22,28(sp)
  80b8ac:	dd400617 	ldw	r21,24(sp)
  80b8b0:	dd000517 	ldw	r20,20(sp)
  80b8b4:	dcc00417 	ldw	r19,16(sp)
  80b8b8:	dc800317 	ldw	r18,12(sp)
  80b8bc:	dc400217 	ldw	r17,8(sp)
  80b8c0:	dc000117 	ldw	r16,4(sp)
  80b8c4:	dec00b04 	addi	sp,sp,44
  80b8c8:	f800283a 	ret
  80b8cc:	90002b1e 	bne	r18,zero,80b97c <__divsf3+0x244>
  80b8d0:	04000104 	movi	r16,4
  80b8d4:	05c00044 	movi	r23,1
  80b8d8:	003fb106 	br	80b7a0 <__alt_data_end+0xfff0b7a0>
  80b8dc:	8800251e 	bne	r17,zero,80b974 <__divsf3+0x23c>
  80b8e0:	01400084 	movi	r5,2
  80b8e4:	00000206 	br	80b8f0 <__divsf3+0x1b8>
  80b8e8:	88001a1e 	bne	r17,zero,80b954 <__divsf3+0x21c>
  80b8ec:	01400044 	movi	r5,1
  80b8f0:	8160b03a 	or	r16,r16,r5
  80b8f4:	802090ba 	slli	r16,r16,2
  80b8f8:	00c02074 	movhi	r3,129
  80b8fc:	18ee4504 	addi	r3,r3,-18156
  80b900:	80e1883a 	add	r16,r16,r3
  80b904:	80c00017 	ldw	r3,0(r16)
  80b908:	9d44f03a 	xor	r2,r19,r21
  80b90c:	a18dc83a 	sub	r6,r20,r6
  80b910:	1800683a 	jmp	r3
  80b914:	0080b86c 	andhi	r2,zero,737
  80b918:	0080b86c 	andhi	r2,zero,737
  80b91c:	0080bab8 	rdprs	r2,zero,746
  80b920:	0080b854 	movui	r2,737
  80b924:	0080bab8 	rdprs	r2,zero,746
  80b928:	0080b9b4 	movhi	r2,742
  80b92c:	0080bab8 	rdprs	r2,zero,746
  80b930:	0080b854 	movui	r2,737
  80b934:	0080b86c 	andhi	r2,zero,737
  80b938:	0080b86c 	andhi	r2,zero,737
  80b93c:	0080b9b4 	movhi	r2,742
  80b940:	0080b854 	movui	r2,737
  80b944:	0080bac8 	cmpgei	r2,zero,747
  80b948:	0080bac8 	cmpgei	r2,zero,747
  80b94c:	0080bac8 	cmpgei	r2,zero,747
  80b950:	0080bae0 	cmpeqi	r2,zero,747
  80b954:	8809883a 	mov	r4,r17
  80b958:	080f21c0 	call	80f21c <__clzsi2>
  80b95c:	10fffec4 	addi	r3,r2,-5
  80b960:	10801d84 	addi	r2,r2,118
  80b964:	88e2983a 	sll	r17,r17,r3
  80b968:	008dc83a 	sub	r6,zero,r2
  80b96c:	000b883a 	mov	r5,zero
  80b970:	003f9906 	br	80b7d8 <__alt_data_end+0xfff0b7d8>
  80b974:	014000c4 	movi	r5,3
  80b978:	003f9706 	br	80b7d8 <__alt_data_end+0xfff0b7d8>
  80b97c:	9009883a 	mov	r4,r18
  80b980:	d9400015 	stw	r5,0(sp)
  80b984:	080f21c0 	call	80f21c <__clzsi2>
  80b988:	10fffec4 	addi	r3,r2,-5
  80b98c:	11801d84 	addi	r6,r2,118
  80b990:	90e4983a 	sll	r18,r18,r3
  80b994:	01a9c83a 	sub	r20,zero,r6
  80b998:	0021883a 	mov	r16,zero
  80b99c:	002f883a 	mov	r23,zero
  80b9a0:	d9400017 	ldw	r5,0(sp)
  80b9a4:	003f7e06 	br	80b7a0 <__alt_data_end+0xfff0b7a0>
  80b9a8:	04000304 	movi	r16,12
  80b9ac:	05c000c4 	movi	r23,3
  80b9b0:	003f7b06 	br	80b7a0 <__alt_data_end+0xfff0b7a0>
  80b9b4:	01802034 	movhi	r6,128
  80b9b8:	000f883a 	mov	r7,zero
  80b9bc:	31bfffc4 	addi	r6,r6,-1
  80b9c0:	013fffc4 	movi	r4,-1
  80b9c4:	003fac06 	br	80b878 <__alt_data_end+0xfff0b878>
  80b9c8:	01400044 	movi	r5,1
  80b9cc:	2909c83a 	sub	r4,r5,r4
  80b9d0:	00c006c4 	movi	r3,27
  80b9d4:	19004b0e 	bge	r3,r4,80bb04 <__divsf3+0x3cc>
  80b9d8:	114e703a 	and	r7,r2,r5
  80b9dc:	0009883a 	mov	r4,zero
  80b9e0:	000d883a 	mov	r6,zero
  80b9e4:	003fa406 	br	80b878 <__alt_data_end+0xfff0b878>
  80b9e8:	9006917a 	slli	r3,r18,5
  80b9ec:	8822917a 	slli	r17,r17,5
  80b9f0:	1c40372e 	bgeu	r3,r17,80bad0 <__divsf3+0x398>
  80b9f4:	31bfffc4 	addi	r6,r6,-1
  80b9f8:	010006c4 	movi	r4,27
  80b9fc:	000b883a 	mov	r5,zero
  80ba00:	180f883a 	mov	r7,r3
  80ba04:	294b883a 	add	r5,r5,r5
  80ba08:	18c7883a 	add	r3,r3,r3
  80ba0c:	38000116 	blt	r7,zero,80ba14 <__divsf3+0x2dc>
  80ba10:	1c400236 	bltu	r3,r17,80ba1c <__divsf3+0x2e4>
  80ba14:	1c47c83a 	sub	r3,r3,r17
  80ba18:	29400054 	ori	r5,r5,1
  80ba1c:	213fffc4 	addi	r4,r4,-1
  80ba20:	203ff71e 	bne	r4,zero,80ba00 <__alt_data_end+0xfff0ba00>
  80ba24:	1806c03a 	cmpne	r3,r3,zero
  80ba28:	1962b03a 	or	r17,r3,r5
  80ba2c:	31001fc4 	addi	r4,r6,127
  80ba30:	013fe50e 	bge	zero,r4,80b9c8 <__alt_data_end+0xfff0b9c8>
  80ba34:	88c001cc 	andi	r3,r17,7
  80ba38:	18000426 	beq	r3,zero,80ba4c <__divsf3+0x314>
  80ba3c:	88c003cc 	andi	r3,r17,15
  80ba40:	01400104 	movi	r5,4
  80ba44:	19400126 	beq	r3,r5,80ba4c <__divsf3+0x314>
  80ba48:	8963883a 	add	r17,r17,r5
  80ba4c:	88c2002c 	andhi	r3,r17,2048
  80ba50:	18000426 	beq	r3,zero,80ba64 <__divsf3+0x32c>
  80ba54:	00fe0034 	movhi	r3,63488
  80ba58:	18ffffc4 	addi	r3,r3,-1
  80ba5c:	31002004 	addi	r4,r6,128
  80ba60:	88e2703a 	and	r17,r17,r3
  80ba64:	00c03f84 	movi	r3,254
  80ba68:	193f8016 	blt	r3,r4,80b86c <__alt_data_end+0xfff0b86c>
  80ba6c:	880c91ba 	slli	r6,r17,6
  80ba70:	11c0004c 	andi	r7,r2,1
  80ba74:	300cd27a 	srli	r6,r6,9
  80ba78:	003f7f06 	br	80b878 <__alt_data_end+0xfff0b878>
  80ba7c:	9080102c 	andhi	r2,r18,64
  80ba80:	10000226 	beq	r2,zero,80ba8c <__divsf3+0x354>
  80ba84:	8880102c 	andhi	r2,r17,64
  80ba88:	10001826 	beq	r2,zero,80baec <__divsf3+0x3b4>
  80ba8c:	00802034 	movhi	r2,128
  80ba90:	91801034 	orhi	r6,r18,64
  80ba94:	10bfffc4 	addi	r2,r2,-1
  80ba98:	980f883a 	mov	r7,r19
  80ba9c:	308c703a 	and	r6,r6,r2
  80baa0:	003fc706 	br	80b9c0 <__alt_data_end+0xfff0b9c0>
  80baa4:	008000c4 	movi	r2,3
  80baa8:	b8802d26 	beq	r23,r2,80bb60 <__divsf3+0x428>
  80baac:	00c00044 	movi	r3,1
  80bab0:	b005883a 	mov	r2,r22
  80bab4:	b8ffdd1e 	bne	r23,r3,80ba2c <__alt_data_end+0xfff0ba2c>
  80bab8:	11c0004c 	andi	r7,r2,1
  80babc:	0009883a 	mov	r4,zero
  80bac0:	000d883a 	mov	r6,zero
  80bac4:	003f6c06 	br	80b878 <__alt_data_end+0xfff0b878>
  80bac8:	9023883a 	mov	r17,r18
  80bacc:	003f6406 	br	80b860 <__alt_data_end+0xfff0b860>
  80bad0:	1c47c83a 	sub	r3,r3,r17
  80bad4:	01000684 	movi	r4,26
  80bad8:	01400044 	movi	r5,1
  80badc:	003fc806 	br	80ba00 <__alt_data_end+0xfff0ba00>
  80bae0:	9080102c 	andhi	r2,r18,64
  80bae4:	103fe926 	beq	r2,zero,80ba8c <__alt_data_end+0xfff0ba8c>
  80bae8:	0023883a 	mov	r17,zero
  80baec:	00802034 	movhi	r2,128
  80baf0:	89801034 	orhi	r6,r17,64
  80baf4:	10bfffc4 	addi	r2,r2,-1
  80baf8:	a80f883a 	mov	r7,r21
  80bafc:	308c703a 	and	r6,r6,r2
  80bb00:	003faf06 	br	80b9c0 <__alt_data_end+0xfff0b9c0>
  80bb04:	01c00804 	movi	r7,32
  80bb08:	390fc83a 	sub	r7,r7,r4
  80bb0c:	89ce983a 	sll	r7,r17,r7
  80bb10:	890ad83a 	srl	r5,r17,r4
  80bb14:	380ec03a 	cmpne	r7,r7,zero
  80bb18:	29cab03a 	or	r5,r5,r7
  80bb1c:	28c001cc 	andi	r3,r5,7
  80bb20:	18000426 	beq	r3,zero,80bb34 <__divsf3+0x3fc>
  80bb24:	28c003cc 	andi	r3,r5,15
  80bb28:	01000104 	movi	r4,4
  80bb2c:	19000126 	beq	r3,r4,80bb34 <__divsf3+0x3fc>
  80bb30:	290b883a 	add	r5,r5,r4
  80bb34:	28c1002c 	andhi	r3,r5,1024
  80bb38:	18000426 	beq	r3,zero,80bb4c <__divsf3+0x414>
  80bb3c:	11c0004c 	andi	r7,r2,1
  80bb40:	01000044 	movi	r4,1
  80bb44:	000d883a 	mov	r6,zero
  80bb48:	003f4b06 	br	80b878 <__alt_data_end+0xfff0b878>
  80bb4c:	280a91ba 	slli	r5,r5,6
  80bb50:	11c0004c 	andi	r7,r2,1
  80bb54:	0009883a 	mov	r4,zero
  80bb58:	280cd27a 	srli	r6,r5,9
  80bb5c:	003f4606 	br	80b878 <__alt_data_end+0xfff0b878>
  80bb60:	00802034 	movhi	r2,128
  80bb64:	89801034 	orhi	r6,r17,64
  80bb68:	10bfffc4 	addi	r2,r2,-1
  80bb6c:	b00f883a 	mov	r7,r22
  80bb70:	308c703a 	and	r6,r6,r2
  80bb74:	003f9206 	br	80b9c0 <__alt_data_end+0xfff0b9c0>

0080bb78 <__gesf2>:
  80bb78:	2004d5fa 	srli	r2,r4,23
  80bb7c:	2806d5fa 	srli	r3,r5,23
  80bb80:	01802034 	movhi	r6,128
  80bb84:	31bfffc4 	addi	r6,r6,-1
  80bb88:	10803fcc 	andi	r2,r2,255
  80bb8c:	01c03fc4 	movi	r7,255
  80bb90:	3110703a 	and	r8,r6,r4
  80bb94:	18c03fcc 	andi	r3,r3,255
  80bb98:	314c703a 	and	r6,r6,r5
  80bb9c:	2008d7fa 	srli	r4,r4,31
  80bba0:	280ad7fa 	srli	r5,r5,31
  80bba4:	11c01926 	beq	r2,r7,80bc0c <__gesf2+0x94>
  80bba8:	01c03fc4 	movi	r7,255
  80bbac:	19c00f26 	beq	r3,r7,80bbec <__gesf2+0x74>
  80bbb0:	1000061e 	bne	r2,zero,80bbcc <__gesf2+0x54>
  80bbb4:	400f003a 	cmpeq	r7,r8,zero
  80bbb8:	1800071e 	bne	r3,zero,80bbd8 <__gesf2+0x60>
  80bbbc:	3000061e 	bne	r6,zero,80bbd8 <__gesf2+0x60>
  80bbc0:	0005883a 	mov	r2,zero
  80bbc4:	40000e1e 	bne	r8,zero,80bc00 <__gesf2+0x88>
  80bbc8:	f800283a 	ret
  80bbcc:	18000a1e 	bne	r3,zero,80bbf8 <__gesf2+0x80>
  80bbd0:	30000b26 	beq	r6,zero,80bc00 <__gesf2+0x88>
  80bbd4:	000f883a 	mov	r7,zero
  80bbd8:	29403fcc 	andi	r5,r5,255
  80bbdc:	38000726 	beq	r7,zero,80bbfc <__gesf2+0x84>
  80bbe0:	28000826 	beq	r5,zero,80bc04 <__gesf2+0x8c>
  80bbe4:	00800044 	movi	r2,1
  80bbe8:	f800283a 	ret
  80bbec:	303ff026 	beq	r6,zero,80bbb0 <__alt_data_end+0xfff0bbb0>
  80bbf0:	00bfff84 	movi	r2,-2
  80bbf4:	f800283a 	ret
  80bbf8:	29403fcc 	andi	r5,r5,255
  80bbfc:	21400526 	beq	r4,r5,80bc14 <__gesf2+0x9c>
  80bc00:	203ff826 	beq	r4,zero,80bbe4 <__alt_data_end+0xfff0bbe4>
  80bc04:	00bfffc4 	movi	r2,-1
  80bc08:	f800283a 	ret
  80bc0c:	403fe626 	beq	r8,zero,80bba8 <__alt_data_end+0xfff0bba8>
  80bc10:	003ff706 	br	80bbf0 <__alt_data_end+0xfff0bbf0>
  80bc14:	18bffa16 	blt	r3,r2,80bc00 <__alt_data_end+0xfff0bc00>
  80bc18:	10c00216 	blt	r2,r3,80bc24 <__gesf2+0xac>
  80bc1c:	323ff836 	bltu	r6,r8,80bc00 <__alt_data_end+0xfff0bc00>
  80bc20:	4180022e 	bgeu	r8,r6,80bc2c <__gesf2+0xb4>
  80bc24:	203fef1e 	bne	r4,zero,80bbe4 <__alt_data_end+0xfff0bbe4>
  80bc28:	003ff606 	br	80bc04 <__alt_data_end+0xfff0bc04>
  80bc2c:	0005883a 	mov	r2,zero
  80bc30:	f800283a 	ret

0080bc34 <__mulsf3>:
  80bc34:	defff504 	addi	sp,sp,-44
  80bc38:	dc000115 	stw	r16,4(sp)
  80bc3c:	2020d5fa 	srli	r16,r4,23
  80bc40:	dd400615 	stw	r21,24(sp)
  80bc44:	202ad7fa 	srli	r21,r4,31
  80bc48:	dc800315 	stw	r18,12(sp)
  80bc4c:	04802034 	movhi	r18,128
  80bc50:	df000915 	stw	fp,36(sp)
  80bc54:	dd000515 	stw	r20,20(sp)
  80bc58:	94bfffc4 	addi	r18,r18,-1
  80bc5c:	dfc00a15 	stw	ra,40(sp)
  80bc60:	ddc00815 	stw	r23,32(sp)
  80bc64:	dd800715 	stw	r22,28(sp)
  80bc68:	dcc00415 	stw	r19,16(sp)
  80bc6c:	dc400215 	stw	r17,8(sp)
  80bc70:	84003fcc 	andi	r16,r16,255
  80bc74:	9124703a 	and	r18,r18,r4
  80bc78:	a829883a 	mov	r20,r21
  80bc7c:	af003fcc 	andi	fp,r21,255
  80bc80:	80005426 	beq	r16,zero,80bdd4 <__mulsf3+0x1a0>
  80bc84:	00803fc4 	movi	r2,255
  80bc88:	80802f26 	beq	r16,r2,80bd48 <__mulsf3+0x114>
  80bc8c:	91002034 	orhi	r4,r18,128
  80bc90:	202490fa 	slli	r18,r4,3
  80bc94:	843fe044 	addi	r16,r16,-127
  80bc98:	0023883a 	mov	r17,zero
  80bc9c:	002f883a 	mov	r23,zero
  80bca0:	2804d5fa 	srli	r2,r5,23
  80bca4:	282cd7fa 	srli	r22,r5,31
  80bca8:	01002034 	movhi	r4,128
  80bcac:	213fffc4 	addi	r4,r4,-1
  80bcb0:	10803fcc 	andi	r2,r2,255
  80bcb4:	2166703a 	and	r19,r4,r5
  80bcb8:	b1803fcc 	andi	r6,r22,255
  80bcbc:	10004c26 	beq	r2,zero,80bdf0 <__mulsf3+0x1bc>
  80bcc0:	00c03fc4 	movi	r3,255
  80bcc4:	10c04726 	beq	r2,r3,80bde4 <__mulsf3+0x1b0>
  80bcc8:	99002034 	orhi	r4,r19,128
  80bccc:	202690fa 	slli	r19,r4,3
  80bcd0:	10bfe044 	addi	r2,r2,-127
  80bcd4:	0007883a 	mov	r3,zero
  80bcd8:	80a1883a 	add	r16,r16,r2
  80bcdc:	010003c4 	movi	r4,15
  80bce0:	1c44b03a 	or	r2,r3,r17
  80bce4:	b56af03a 	xor	r21,r22,r21
  80bce8:	81c00044 	addi	r7,r16,1
  80bcec:	20806b36 	bltu	r4,r2,80be9c <__mulsf3+0x268>
  80bcf0:	100490ba 	slli	r2,r2,2
  80bcf4:	01002074 	movhi	r4,129
  80bcf8:	212f4204 	addi	r4,r4,-17144
  80bcfc:	1105883a 	add	r2,r2,r4
  80bd00:	10800017 	ldw	r2,0(r2)
  80bd04:	1000683a 	jmp	r2
  80bd08:	0080be9c 	xori	r2,zero,762
  80bd0c:	0080bd5c 	xori	r2,zero,757
  80bd10:	0080bd5c 	xori	r2,zero,757
  80bd14:	0080bd58 	cmpnei	r2,zero,757
  80bd18:	0080be80 	call	80be8 <__alt_mem_onchip_flash+0xbe8>
  80bd1c:	0080be80 	call	80be8 <__alt_mem_onchip_flash+0xbe8>
  80bd20:	0080be6c 	andhi	r2,zero,761
  80bd24:	0080bd58 	cmpnei	r2,zero,757
  80bd28:	0080be80 	call	80be8 <__alt_mem_onchip_flash+0xbe8>
  80bd2c:	0080be6c 	andhi	r2,zero,761
  80bd30:	0080be80 	call	80be8 <__alt_mem_onchip_flash+0xbe8>
  80bd34:	0080bd58 	cmpnei	r2,zero,757
  80bd38:	0080be8c 	andi	r2,zero,762
  80bd3c:	0080be8c 	andi	r2,zero,762
  80bd40:	0080be8c 	andi	r2,zero,762
  80bd44:	0080bf9c 	xori	r2,zero,766
  80bd48:	90003b1e 	bne	r18,zero,80be38 <__mulsf3+0x204>
  80bd4c:	04400204 	movi	r17,8
  80bd50:	05c00084 	movi	r23,2
  80bd54:	003fd206 	br	80bca0 <__alt_data_end+0xfff0bca0>
  80bd58:	302b883a 	mov	r21,r6
  80bd5c:	00800084 	movi	r2,2
  80bd60:	18802626 	beq	r3,r2,80bdfc <__mulsf3+0x1c8>
  80bd64:	008000c4 	movi	r2,3
  80bd68:	1880b826 	beq	r3,r2,80c04c <__mulsf3+0x418>
  80bd6c:	00800044 	movi	r2,1
  80bd70:	1880af1e 	bne	r3,r2,80c030 <__mulsf3+0x3fc>
  80bd74:	a829883a 	mov	r20,r21
  80bd78:	0007883a 	mov	r3,zero
  80bd7c:	0009883a 	mov	r4,zero
  80bd80:	18803fcc 	andi	r2,r3,255
  80bd84:	100695fa 	slli	r3,r2,23
  80bd88:	a0803fcc 	andi	r2,r20,255
  80bd8c:	100a97fa 	slli	r5,r2,31
  80bd90:	00802034 	movhi	r2,128
  80bd94:	10bfffc4 	addi	r2,r2,-1
  80bd98:	2084703a 	and	r2,r4,r2
  80bd9c:	10c4b03a 	or	r2,r2,r3
  80bda0:	1144b03a 	or	r2,r2,r5
  80bda4:	dfc00a17 	ldw	ra,40(sp)
  80bda8:	df000917 	ldw	fp,36(sp)
  80bdac:	ddc00817 	ldw	r23,32(sp)
  80bdb0:	dd800717 	ldw	r22,28(sp)
  80bdb4:	dd400617 	ldw	r21,24(sp)
  80bdb8:	dd000517 	ldw	r20,20(sp)
  80bdbc:	dcc00417 	ldw	r19,16(sp)
  80bdc0:	dc800317 	ldw	r18,12(sp)
  80bdc4:	dc400217 	ldw	r17,8(sp)
  80bdc8:	dc000117 	ldw	r16,4(sp)
  80bdcc:	dec00b04 	addi	sp,sp,44
  80bdd0:	f800283a 	ret
  80bdd4:	90000d1e 	bne	r18,zero,80be0c <__mulsf3+0x1d8>
  80bdd8:	04400104 	movi	r17,4
  80bddc:	05c00044 	movi	r23,1
  80bde0:	003faf06 	br	80bca0 <__alt_data_end+0xfff0bca0>
  80bde4:	9806c03a 	cmpne	r3,r19,zero
  80bde8:	18c00084 	addi	r3,r3,2
  80bdec:	003fba06 	br	80bcd8 <__alt_data_end+0xfff0bcd8>
  80bdf0:	9800141e 	bne	r19,zero,80be44 <__mulsf3+0x210>
  80bdf4:	00c00044 	movi	r3,1
  80bdf8:	003fb706 	br	80bcd8 <__alt_data_end+0xfff0bcd8>
  80bdfc:	a829883a 	mov	r20,r21
  80be00:	00ffffc4 	movi	r3,-1
  80be04:	0009883a 	mov	r4,zero
  80be08:	003fdd06 	br	80bd80 <__alt_data_end+0xfff0bd80>
  80be0c:	9009883a 	mov	r4,r18
  80be10:	d9400015 	stw	r5,0(sp)
  80be14:	080f21c0 	call	80f21c <__clzsi2>
  80be18:	10fffec4 	addi	r3,r2,-5
  80be1c:	10801d84 	addi	r2,r2,118
  80be20:	90e4983a 	sll	r18,r18,r3
  80be24:	00a1c83a 	sub	r16,zero,r2
  80be28:	0023883a 	mov	r17,zero
  80be2c:	002f883a 	mov	r23,zero
  80be30:	d9400017 	ldw	r5,0(sp)
  80be34:	003f9a06 	br	80bca0 <__alt_data_end+0xfff0bca0>
  80be38:	04400304 	movi	r17,12
  80be3c:	05c000c4 	movi	r23,3
  80be40:	003f9706 	br	80bca0 <__alt_data_end+0xfff0bca0>
  80be44:	9809883a 	mov	r4,r19
  80be48:	d9800015 	stw	r6,0(sp)
  80be4c:	080f21c0 	call	80f21c <__clzsi2>
  80be50:	10fffec4 	addi	r3,r2,-5
  80be54:	10801d84 	addi	r2,r2,118
  80be58:	98e6983a 	sll	r19,r19,r3
  80be5c:	0085c83a 	sub	r2,zero,r2
  80be60:	0007883a 	mov	r3,zero
  80be64:	d9800017 	ldw	r6,0(sp)
  80be68:	003f9b06 	br	80bcd8 <__alt_data_end+0xfff0bcd8>
  80be6c:	01002034 	movhi	r4,128
  80be70:	0029883a 	mov	r20,zero
  80be74:	213fffc4 	addi	r4,r4,-1
  80be78:	00ffffc4 	movi	r3,-1
  80be7c:	003fc006 	br	80bd80 <__alt_data_end+0xfff0bd80>
  80be80:	9027883a 	mov	r19,r18
  80be84:	b807883a 	mov	r3,r23
  80be88:	003fb406 	br	80bd5c <__alt_data_end+0xfff0bd5c>
  80be8c:	9027883a 	mov	r19,r18
  80be90:	e02b883a 	mov	r21,fp
  80be94:	b807883a 	mov	r3,r23
  80be98:	003fb006 	br	80bd5c <__alt_data_end+0xfff0bd5c>
  80be9c:	9028d43a 	srli	r20,r18,16
  80bea0:	982cd43a 	srli	r22,r19,16
  80bea4:	94bfffcc 	andi	r18,r18,65535
  80bea8:	9cffffcc 	andi	r19,r19,65535
  80beac:	980b883a 	mov	r5,r19
  80beb0:	9009883a 	mov	r4,r18
  80beb4:	d9c00015 	stw	r7,0(sp)
  80beb8:	080b2480 	call	80b248 <__mulsi3>
  80bebc:	a00b883a 	mov	r5,r20
  80bec0:	9809883a 	mov	r4,r19
  80bec4:	1023883a 	mov	r17,r2
  80bec8:	080b2480 	call	80b248 <__mulsi3>
  80becc:	a009883a 	mov	r4,r20
  80bed0:	b00b883a 	mov	r5,r22
  80bed4:	1027883a 	mov	r19,r2
  80bed8:	080b2480 	call	80b248 <__mulsi3>
  80bedc:	b00b883a 	mov	r5,r22
  80bee0:	9009883a 	mov	r4,r18
  80bee4:	1029883a 	mov	r20,r2
  80bee8:	080b2480 	call	80b248 <__mulsi3>
  80beec:	8806d43a 	srli	r3,r17,16
  80bef0:	14c5883a 	add	r2,r2,r19
  80bef4:	d9c00017 	ldw	r7,0(sp)
  80bef8:	1885883a 	add	r2,r3,r2
  80befc:	14c0022e 	bgeu	r2,r19,80bf08 <__mulsf3+0x2d4>
  80bf00:	00c00074 	movhi	r3,1
  80bf04:	a0e9883a 	add	r20,r20,r3
  80bf08:	1026943a 	slli	r19,r2,16
  80bf0c:	8c7fffcc 	andi	r17,r17,65535
  80bf10:	1004d43a 	srli	r2,r2,16
  80bf14:	9c63883a 	add	r17,r19,r17
  80bf18:	882691ba 	slli	r19,r17,6
  80bf1c:	1505883a 	add	r2,r2,r20
  80bf20:	8822d6ba 	srli	r17,r17,26
  80bf24:	100891ba 	slli	r4,r2,6
  80bf28:	9826c03a 	cmpne	r19,r19,zero
  80bf2c:	9c62b03a 	or	r17,r19,r17
  80bf30:	8926b03a 	or	r19,r17,r4
  80bf34:	9882002c 	andhi	r2,r19,2048
  80bf38:	10000426 	beq	r2,zero,80bf4c <__mulsf3+0x318>
  80bf3c:	9804d07a 	srli	r2,r19,1
  80bf40:	9900004c 	andi	r4,r19,1
  80bf44:	3821883a 	mov	r16,r7
  80bf48:	1126b03a 	or	r19,r2,r4
  80bf4c:	80c01fc4 	addi	r3,r16,127
  80bf50:	00c0210e 	bge	zero,r3,80bfd8 <__mulsf3+0x3a4>
  80bf54:	988001cc 	andi	r2,r19,7
  80bf58:	10000426 	beq	r2,zero,80bf6c <__mulsf3+0x338>
  80bf5c:	988003cc 	andi	r2,r19,15
  80bf60:	01000104 	movi	r4,4
  80bf64:	11000126 	beq	r2,r4,80bf6c <__mulsf3+0x338>
  80bf68:	9927883a 	add	r19,r19,r4
  80bf6c:	9882002c 	andhi	r2,r19,2048
  80bf70:	10000426 	beq	r2,zero,80bf84 <__mulsf3+0x350>
  80bf74:	00be0034 	movhi	r2,63488
  80bf78:	10bfffc4 	addi	r2,r2,-1
  80bf7c:	80c02004 	addi	r3,r16,128
  80bf80:	98a6703a 	and	r19,r19,r2
  80bf84:	00803f84 	movi	r2,254
  80bf88:	10ff9c16 	blt	r2,r3,80bdfc <__alt_data_end+0xfff0bdfc>
  80bf8c:	980891ba 	slli	r4,r19,6
  80bf90:	a829883a 	mov	r20,r21
  80bf94:	2008d27a 	srli	r4,r4,9
  80bf98:	003f7906 	br	80bd80 <__alt_data_end+0xfff0bd80>
  80bf9c:	9080102c 	andhi	r2,r18,64
  80bfa0:	10000826 	beq	r2,zero,80bfc4 <__mulsf3+0x390>
  80bfa4:	9880102c 	andhi	r2,r19,64
  80bfa8:	1000061e 	bne	r2,zero,80bfc4 <__mulsf3+0x390>
  80bfac:	00802034 	movhi	r2,128
  80bfb0:	99001034 	orhi	r4,r19,64
  80bfb4:	10bfffc4 	addi	r2,r2,-1
  80bfb8:	b029883a 	mov	r20,r22
  80bfbc:	2088703a 	and	r4,r4,r2
  80bfc0:	003fad06 	br	80be78 <__alt_data_end+0xfff0be78>
  80bfc4:	00802034 	movhi	r2,128
  80bfc8:	91001034 	orhi	r4,r18,64
  80bfcc:	10bfffc4 	addi	r2,r2,-1
  80bfd0:	2088703a 	and	r4,r4,r2
  80bfd4:	003fa806 	br	80be78 <__alt_data_end+0xfff0be78>
  80bfd8:	00800044 	movi	r2,1
  80bfdc:	10c7c83a 	sub	r3,r2,r3
  80bfe0:	008006c4 	movi	r2,27
  80bfe4:	10ff6316 	blt	r2,r3,80bd74 <__alt_data_end+0xfff0bd74>
  80bfe8:	00800804 	movi	r2,32
  80bfec:	10c5c83a 	sub	r2,r2,r3
  80bff0:	9884983a 	sll	r2,r19,r2
  80bff4:	98c6d83a 	srl	r3,r19,r3
  80bff8:	1004c03a 	cmpne	r2,r2,zero
  80bffc:	1884b03a 	or	r2,r3,r2
  80c000:	10c001cc 	andi	r3,r2,7
  80c004:	18000426 	beq	r3,zero,80c018 <__mulsf3+0x3e4>
  80c008:	10c003cc 	andi	r3,r2,15
  80c00c:	01000104 	movi	r4,4
  80c010:	19000126 	beq	r3,r4,80c018 <__mulsf3+0x3e4>
  80c014:	1105883a 	add	r2,r2,r4
  80c018:	10c1002c 	andhi	r3,r2,1024
  80c01c:	18000626 	beq	r3,zero,80c038 <__mulsf3+0x404>
  80c020:	a829883a 	mov	r20,r21
  80c024:	00c00044 	movi	r3,1
  80c028:	0009883a 	mov	r4,zero
  80c02c:	003f5406 	br	80bd80 <__alt_data_end+0xfff0bd80>
  80c030:	3821883a 	mov	r16,r7
  80c034:	003fc506 	br	80bf4c <__alt_data_end+0xfff0bf4c>
  80c038:	100491ba 	slli	r2,r2,6
  80c03c:	a829883a 	mov	r20,r21
  80c040:	0007883a 	mov	r3,zero
  80c044:	1008d27a 	srli	r4,r2,9
  80c048:	003f4d06 	br	80bd80 <__alt_data_end+0xfff0bd80>
  80c04c:	00802034 	movhi	r2,128
  80c050:	99001034 	orhi	r4,r19,64
  80c054:	10bfffc4 	addi	r2,r2,-1
  80c058:	a829883a 	mov	r20,r21
  80c05c:	2088703a 	and	r4,r4,r2
  80c060:	003f8506 	br	80be78 <__alt_data_end+0xfff0be78>

0080c064 <__subsf3>:
  80c064:	defffc04 	addi	sp,sp,-16
  80c068:	280cd5fa 	srli	r6,r5,23
  80c06c:	dc000015 	stw	r16,0(sp)
  80c070:	01c02034 	movhi	r7,128
  80c074:	2020d5fa 	srli	r16,r4,23
  80c078:	39ffffc4 	addi	r7,r7,-1
  80c07c:	3906703a 	and	r3,r7,r4
  80c080:	dc400115 	stw	r17,4(sp)
  80c084:	394e703a 	and	r7,r7,r5
  80c088:	2022d7fa 	srli	r17,r4,31
  80c08c:	dfc00315 	stw	ra,12(sp)
  80c090:	dc800215 	stw	r18,8(sp)
  80c094:	31803fcc 	andi	r6,r6,255
  80c098:	01003fc4 	movi	r4,255
  80c09c:	84003fcc 	andi	r16,r16,255
  80c0a0:	180690fa 	slli	r3,r3,3
  80c0a4:	2804d7fa 	srli	r2,r5,31
  80c0a8:	380e90fa 	slli	r7,r7,3
  80c0ac:	31006d26 	beq	r6,r4,80c264 <__subsf3+0x200>
  80c0b0:	1080005c 	xori	r2,r2,1
  80c0b4:	8189c83a 	sub	r4,r16,r6
  80c0b8:	14404f26 	beq	r2,r17,80c1f8 <__subsf3+0x194>
  80c0bc:	0100770e 	bge	zero,r4,80c29c <__subsf3+0x238>
  80c0c0:	30001e1e 	bne	r6,zero,80c13c <__subsf3+0xd8>
  80c0c4:	38006a1e 	bne	r7,zero,80c270 <__subsf3+0x20c>
  80c0c8:	188001cc 	andi	r2,r3,7
  80c0cc:	10000426 	beq	r2,zero,80c0e0 <__subsf3+0x7c>
  80c0d0:	188003cc 	andi	r2,r3,15
  80c0d4:	01000104 	movi	r4,4
  80c0d8:	11000126 	beq	r2,r4,80c0e0 <__subsf3+0x7c>
  80c0dc:	1907883a 	add	r3,r3,r4
  80c0e0:	1881002c 	andhi	r2,r3,1024
  80c0e4:	10003926 	beq	r2,zero,80c1cc <__subsf3+0x168>
  80c0e8:	84000044 	addi	r16,r16,1
  80c0ec:	00803fc4 	movi	r2,255
  80c0f0:	80807526 	beq	r16,r2,80c2c8 <__subsf3+0x264>
  80c0f4:	180691ba 	slli	r3,r3,6
  80c0f8:	8880004c 	andi	r2,r17,1
  80c0fc:	180ad27a 	srli	r5,r3,9
  80c100:	84003fcc 	andi	r16,r16,255
  80c104:	800695fa 	slli	r3,r16,23
  80c108:	10803fcc 	andi	r2,r2,255
  80c10c:	01002034 	movhi	r4,128
  80c110:	213fffc4 	addi	r4,r4,-1
  80c114:	100497fa 	slli	r2,r2,31
  80c118:	2920703a 	and	r16,r5,r4
  80c11c:	80e0b03a 	or	r16,r16,r3
  80c120:	8084b03a 	or	r2,r16,r2
  80c124:	dfc00317 	ldw	ra,12(sp)
  80c128:	dc800217 	ldw	r18,8(sp)
  80c12c:	dc400117 	ldw	r17,4(sp)
  80c130:	dc000017 	ldw	r16,0(sp)
  80c134:	dec00404 	addi	sp,sp,16
  80c138:	f800283a 	ret
  80c13c:	00803fc4 	movi	r2,255
  80c140:	80bfe126 	beq	r16,r2,80c0c8 <__alt_data_end+0xfff0c0c8>
  80c144:	39c10034 	orhi	r7,r7,1024
  80c148:	008006c4 	movi	r2,27
  80c14c:	11007416 	blt	r2,r4,80c320 <__subsf3+0x2bc>
  80c150:	00800804 	movi	r2,32
  80c154:	1105c83a 	sub	r2,r2,r4
  80c158:	3884983a 	sll	r2,r7,r2
  80c15c:	390ed83a 	srl	r7,r7,r4
  80c160:	1008c03a 	cmpne	r4,r2,zero
  80c164:	390eb03a 	or	r7,r7,r4
  80c168:	19c7c83a 	sub	r3,r3,r7
  80c16c:	1881002c 	andhi	r2,r3,1024
  80c170:	10001426 	beq	r2,zero,80c1c4 <__subsf3+0x160>
  80c174:	04810034 	movhi	r18,1024
  80c178:	94bfffc4 	addi	r18,r18,-1
  80c17c:	1ca4703a 	and	r18,r3,r18
  80c180:	9009883a 	mov	r4,r18
  80c184:	080f21c0 	call	80f21c <__clzsi2>
  80c188:	10bffec4 	addi	r2,r2,-5
  80c18c:	90a4983a 	sll	r18,r18,r2
  80c190:	14005116 	blt	r2,r16,80c2d8 <__subsf3+0x274>
  80c194:	1405c83a 	sub	r2,r2,r16
  80c198:	10c00044 	addi	r3,r2,1
  80c19c:	00800804 	movi	r2,32
  80c1a0:	10c5c83a 	sub	r2,r2,r3
  80c1a4:	9084983a 	sll	r2,r18,r2
  80c1a8:	90e4d83a 	srl	r18,r18,r3
  80c1ac:	0021883a 	mov	r16,zero
  80c1b0:	1006c03a 	cmpne	r3,r2,zero
  80c1b4:	90c6b03a 	or	r3,r18,r3
  80c1b8:	003fc306 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c1bc:	2000e026 	beq	r4,zero,80c540 <__subsf3+0x4dc>
  80c1c0:	2007883a 	mov	r3,r4
  80c1c4:	188001cc 	andi	r2,r3,7
  80c1c8:	103fc11e 	bne	r2,zero,80c0d0 <__alt_data_end+0xfff0c0d0>
  80c1cc:	180ad0fa 	srli	r5,r3,3
  80c1d0:	00c03fc4 	movi	r3,255
  80c1d4:	8880004c 	andi	r2,r17,1
  80c1d8:	80c0031e 	bne	r16,r3,80c1e8 <__subsf3+0x184>
  80c1dc:	28006d26 	beq	r5,zero,80c394 <__subsf3+0x330>
  80c1e0:	29401034 	orhi	r5,r5,64
  80c1e4:	043fffc4 	movi	r16,-1
  80c1e8:	00c02034 	movhi	r3,128
  80c1ec:	18ffffc4 	addi	r3,r3,-1
  80c1f0:	28ca703a 	and	r5,r5,r3
  80c1f4:	003fc206 	br	80c100 <__alt_data_end+0xfff0c100>
  80c1f8:	01003c0e 	bge	zero,r4,80c2ec <__subsf3+0x288>
  80c1fc:	30002126 	beq	r6,zero,80c284 <__subsf3+0x220>
  80c200:	01403fc4 	movi	r5,255
  80c204:	817fb026 	beq	r16,r5,80c0c8 <__alt_data_end+0xfff0c0c8>
  80c208:	39c10034 	orhi	r7,r7,1024
  80c20c:	014006c4 	movi	r5,27
  80c210:	29007416 	blt	r5,r4,80c3e4 <__subsf3+0x380>
  80c214:	01400804 	movi	r5,32
  80c218:	290bc83a 	sub	r5,r5,r4
  80c21c:	394a983a 	sll	r5,r7,r5
  80c220:	390ed83a 	srl	r7,r7,r4
  80c224:	2808c03a 	cmpne	r4,r5,zero
  80c228:	390eb03a 	or	r7,r7,r4
  80c22c:	19c7883a 	add	r3,r3,r7
  80c230:	1901002c 	andhi	r4,r3,1024
  80c234:	20003826 	beq	r4,zero,80c318 <__subsf3+0x2b4>
  80c238:	84000044 	addi	r16,r16,1
  80c23c:	01003fc4 	movi	r4,255
  80c240:	81005426 	beq	r16,r4,80c394 <__subsf3+0x330>
  80c244:	1023883a 	mov	r17,r2
  80c248:	00bf0034 	movhi	r2,64512
  80c24c:	10bfffc4 	addi	r2,r2,-1
  80c250:	1900004c 	andi	r4,r3,1
  80c254:	1886703a 	and	r3,r3,r2
  80c258:	1806d07a 	srli	r3,r3,1
  80c25c:	1906b03a 	or	r3,r3,r4
  80c260:	003f9906 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c264:	383f9226 	beq	r7,zero,80c0b0 <__alt_data_end+0xfff0c0b0>
  80c268:	10803fcc 	andi	r2,r2,255
  80c26c:	003f9106 	br	80c0b4 <__alt_data_end+0xfff0c0b4>
  80c270:	213fffc4 	addi	r4,r4,-1
  80c274:	203fbc26 	beq	r4,zero,80c168 <__alt_data_end+0xfff0c168>
  80c278:	00803fc4 	movi	r2,255
  80c27c:	80bfb21e 	bne	r16,r2,80c148 <__alt_data_end+0xfff0c148>
  80c280:	003f9106 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c284:	383f9026 	beq	r7,zero,80c0c8 <__alt_data_end+0xfff0c0c8>
  80c288:	213fffc4 	addi	r4,r4,-1
  80c28c:	203fe726 	beq	r4,zero,80c22c <__alt_data_end+0xfff0c22c>
  80c290:	01403fc4 	movi	r5,255
  80c294:	817fdd1e 	bne	r16,r5,80c20c <__alt_data_end+0xfff0c20c>
  80c298:	003f8b06 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c29c:	2000221e 	bne	r4,zero,80c328 <__subsf3+0x2c4>
  80c2a0:	81000044 	addi	r4,r16,1
  80c2a4:	21003fcc 	andi	r4,r4,255
  80c2a8:	01400044 	movi	r5,1
  80c2ac:	2900470e 	bge	r5,r4,80c3cc <__subsf3+0x368>
  80c2b0:	19e5c83a 	sub	r18,r3,r7
  80c2b4:	9141002c 	andhi	r5,r18,1024
  80c2b8:	28002d26 	beq	r5,zero,80c370 <__subsf3+0x30c>
  80c2bc:	38e5c83a 	sub	r18,r7,r3
  80c2c0:	1023883a 	mov	r17,r2
  80c2c4:	003fae06 	br	80c180 <__alt_data_end+0xfff0c180>
  80c2c8:	8880004c 	andi	r2,r17,1
  80c2cc:	043fffc4 	movi	r16,-1
  80c2d0:	000b883a 	mov	r5,zero
  80c2d4:	003f8a06 	br	80c100 <__alt_data_end+0xfff0c100>
  80c2d8:	00ff0034 	movhi	r3,64512
  80c2dc:	18ffffc4 	addi	r3,r3,-1
  80c2e0:	80a1c83a 	sub	r16,r16,r2
  80c2e4:	90c6703a 	and	r3,r18,r3
  80c2e8:	003f7706 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c2ec:	2000431e 	bne	r4,zero,80c3fc <__subsf3+0x398>
  80c2f0:	81000044 	addi	r4,r16,1
  80c2f4:	21803fcc 	andi	r6,r4,255
  80c2f8:	01400044 	movi	r5,1
  80c2fc:	2980280e 	bge	r5,r6,80c3a0 <__subsf3+0x33c>
  80c300:	01403fc4 	movi	r5,255
  80c304:	21402326 	beq	r4,r5,80c394 <__subsf3+0x330>
  80c308:	19c7883a 	add	r3,r3,r7
  80c30c:	1806d07a 	srli	r3,r3,1
  80c310:	2021883a 	mov	r16,r4
  80c314:	003f6c06 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c318:	1023883a 	mov	r17,r2
  80c31c:	003fa906 	br	80c1c4 <__alt_data_end+0xfff0c1c4>
  80c320:	01c00044 	movi	r7,1
  80c324:	003f9006 	br	80c168 <__alt_data_end+0xfff0c168>
  80c328:	8000151e 	bne	r16,zero,80c380 <__subsf3+0x31c>
  80c32c:	18002f26 	beq	r3,zero,80c3ec <__subsf3+0x388>
  80c330:	0108303a 	nor	r4,zero,r4
  80c334:	20000a26 	beq	r4,zero,80c360 <__subsf3+0x2fc>
  80c338:	01403fc4 	movi	r5,255
  80c33c:	31402b26 	beq	r6,r5,80c3ec <__subsf3+0x388>
  80c340:	014006c4 	movi	r5,27
  80c344:	29006e16 	blt	r5,r4,80c500 <__subsf3+0x49c>
  80c348:	01400804 	movi	r5,32
  80c34c:	290bc83a 	sub	r5,r5,r4
  80c350:	194a983a 	sll	r5,r3,r5
  80c354:	1908d83a 	srl	r4,r3,r4
  80c358:	2806c03a 	cmpne	r3,r5,zero
  80c35c:	20c6b03a 	or	r3,r4,r3
  80c360:	38c7c83a 	sub	r3,r7,r3
  80c364:	3021883a 	mov	r16,r6
  80c368:	1023883a 	mov	r17,r2
  80c36c:	003f7f06 	br	80c16c <__alt_data_end+0xfff0c16c>
  80c370:	903f831e 	bne	r18,zero,80c180 <__alt_data_end+0xfff0c180>
  80c374:	0005883a 	mov	r2,zero
  80c378:	0021883a 	mov	r16,zero
  80c37c:	003f9a06 	br	80c1e8 <__alt_data_end+0xfff0c1e8>
  80c380:	01403fc4 	movi	r5,255
  80c384:	31401926 	beq	r6,r5,80c3ec <__subsf3+0x388>
  80c388:	0109c83a 	sub	r4,zero,r4
  80c38c:	18c10034 	orhi	r3,r3,1024
  80c390:	003feb06 	br	80c340 <__alt_data_end+0xfff0c340>
  80c394:	043fffc4 	movi	r16,-1
  80c398:	000b883a 	mov	r5,zero
  80c39c:	003f5806 	br	80c100 <__alt_data_end+0xfff0c100>
  80c3a0:	8000481e 	bne	r16,zero,80c4c4 <__subsf3+0x460>
  80c3a4:	18006226 	beq	r3,zero,80c530 <__subsf3+0x4cc>
  80c3a8:	383f4726 	beq	r7,zero,80c0c8 <__alt_data_end+0xfff0c0c8>
  80c3ac:	19c7883a 	add	r3,r3,r7
  80c3b0:	1881002c 	andhi	r2,r3,1024
  80c3b4:	103f8326 	beq	r2,zero,80c1c4 <__alt_data_end+0xfff0c1c4>
  80c3b8:	00bf0034 	movhi	r2,64512
  80c3bc:	10bfffc4 	addi	r2,r2,-1
  80c3c0:	2821883a 	mov	r16,r5
  80c3c4:	1886703a 	and	r3,r3,r2
  80c3c8:	003f3f06 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c3cc:	80001c1e 	bne	r16,zero,80c440 <__subsf3+0x3dc>
  80c3d0:	1800261e 	bne	r3,zero,80c46c <__subsf3+0x408>
  80c3d4:	38004c26 	beq	r7,zero,80c508 <__subsf3+0x4a4>
  80c3d8:	3807883a 	mov	r3,r7
  80c3dc:	1023883a 	mov	r17,r2
  80c3e0:	003f3906 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c3e4:	01c00044 	movi	r7,1
  80c3e8:	003f9006 	br	80c22c <__alt_data_end+0xfff0c22c>
  80c3ec:	3807883a 	mov	r3,r7
  80c3f0:	3021883a 	mov	r16,r6
  80c3f4:	1023883a 	mov	r17,r2
  80c3f8:	003f3306 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c3fc:	8000161e 	bne	r16,zero,80c458 <__subsf3+0x3f4>
  80c400:	18002d26 	beq	r3,zero,80c4b8 <__subsf3+0x454>
  80c404:	0108303a 	nor	r4,zero,r4
  80c408:	20000a26 	beq	r4,zero,80c434 <__subsf3+0x3d0>
  80c40c:	01403fc4 	movi	r5,255
  80c410:	31402926 	beq	r6,r5,80c4b8 <__subsf3+0x454>
  80c414:	014006c4 	movi	r5,27
  80c418:	29004716 	blt	r5,r4,80c538 <__subsf3+0x4d4>
  80c41c:	01400804 	movi	r5,32
  80c420:	290bc83a 	sub	r5,r5,r4
  80c424:	194a983a 	sll	r5,r3,r5
  80c428:	1908d83a 	srl	r4,r3,r4
  80c42c:	2806c03a 	cmpne	r3,r5,zero
  80c430:	20c6b03a 	or	r3,r4,r3
  80c434:	19c7883a 	add	r3,r3,r7
  80c438:	3021883a 	mov	r16,r6
  80c43c:	003f7c06 	br	80c230 <__alt_data_end+0xfff0c230>
  80c440:	1800111e 	bne	r3,zero,80c488 <__subsf3+0x424>
  80c444:	38003326 	beq	r7,zero,80c514 <__subsf3+0x4b0>
  80c448:	3807883a 	mov	r3,r7
  80c44c:	1023883a 	mov	r17,r2
  80c450:	04003fc4 	movi	r16,255
  80c454:	003f1c06 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c458:	01403fc4 	movi	r5,255
  80c45c:	31401626 	beq	r6,r5,80c4b8 <__subsf3+0x454>
  80c460:	0109c83a 	sub	r4,zero,r4
  80c464:	18c10034 	orhi	r3,r3,1024
  80c468:	003fea06 	br	80c414 <__alt_data_end+0xfff0c414>
  80c46c:	383f1626 	beq	r7,zero,80c0c8 <__alt_data_end+0xfff0c0c8>
  80c470:	19c9c83a 	sub	r4,r3,r7
  80c474:	2141002c 	andhi	r5,r4,1024
  80c478:	283f5026 	beq	r5,zero,80c1bc <__alt_data_end+0xfff0c1bc>
  80c47c:	38c7c83a 	sub	r3,r7,r3
  80c480:	1023883a 	mov	r17,r2
  80c484:	003f1006 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c488:	38001b26 	beq	r7,zero,80c4f8 <__subsf3+0x494>
  80c48c:	1806d0fa 	srli	r3,r3,3
  80c490:	1900102c 	andhi	r4,r3,64
  80c494:	20000526 	beq	r4,zero,80c4ac <__subsf3+0x448>
  80c498:	380ed0fa 	srli	r7,r7,3
  80c49c:	3900102c 	andhi	r4,r7,64
  80c4a0:	2000021e 	bne	r4,zero,80c4ac <__subsf3+0x448>
  80c4a4:	3807883a 	mov	r3,r7
  80c4a8:	1023883a 	mov	r17,r2
  80c4ac:	180690fa 	slli	r3,r3,3
  80c4b0:	04003fc4 	movi	r16,255
  80c4b4:	003f0406 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c4b8:	3807883a 	mov	r3,r7
  80c4bc:	3021883a 	mov	r16,r6
  80c4c0:	003f0106 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c4c4:	18001726 	beq	r3,zero,80c524 <__subsf3+0x4c0>
  80c4c8:	38000b26 	beq	r7,zero,80c4f8 <__subsf3+0x494>
  80c4cc:	1806d0fa 	srli	r3,r3,3
  80c4d0:	1900102c 	andhi	r4,r3,64
  80c4d4:	20000426 	beq	r4,zero,80c4e8 <__subsf3+0x484>
  80c4d8:	380ed0fa 	srli	r7,r7,3
  80c4dc:	3900102c 	andhi	r4,r7,64
  80c4e0:	2000011e 	bne	r4,zero,80c4e8 <__subsf3+0x484>
  80c4e4:	3807883a 	mov	r3,r7
  80c4e8:	180690fa 	slli	r3,r3,3
  80c4ec:	1023883a 	mov	r17,r2
  80c4f0:	04003fc4 	movi	r16,255
  80c4f4:	003ef406 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c4f8:	04003fc4 	movi	r16,255
  80c4fc:	003ef206 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c500:	00c00044 	movi	r3,1
  80c504:	003f9606 	br	80c360 <__alt_data_end+0xfff0c360>
  80c508:	000b883a 	mov	r5,zero
  80c50c:	0005883a 	mov	r2,zero
  80c510:	003f3506 	br	80c1e8 <__alt_data_end+0xfff0c1e8>
  80c514:	01402034 	movhi	r5,128
  80c518:	297fffc4 	addi	r5,r5,-1
  80c51c:	0005883a 	mov	r2,zero
  80c520:	003f2f06 	br	80c1e0 <__alt_data_end+0xfff0c1e0>
  80c524:	3807883a 	mov	r3,r7
  80c528:	04003fc4 	movi	r16,255
  80c52c:	003ee606 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c530:	3807883a 	mov	r3,r7
  80c534:	003ee406 	br	80c0c8 <__alt_data_end+0xfff0c0c8>
  80c538:	00c00044 	movi	r3,1
  80c53c:	003fbd06 	br	80c434 <__alt_data_end+0xfff0c434>
  80c540:	0005883a 	mov	r2,zero
  80c544:	003f2806 	br	80c1e8 <__alt_data_end+0xfff0c1e8>

0080c548 <__fixsfsi>:
  80c548:	200ad5fa 	srli	r5,r4,23
  80c54c:	00c02034 	movhi	r3,128
  80c550:	18ffffc4 	addi	r3,r3,-1
  80c554:	29403fcc 	andi	r5,r5,255
  80c558:	00801f84 	movi	r2,126
  80c55c:	1906703a 	and	r3,r3,r4
  80c560:	2008d7fa 	srli	r4,r4,31
  80c564:	11400e0e 	bge	r2,r5,80c5a0 <__fixsfsi+0x58>
  80c568:	00802744 	movi	r2,157
  80c56c:	11400816 	blt	r2,r5,80c590 <__fixsfsi+0x48>
  80c570:	00802544 	movi	r2,149
  80c574:	18c02034 	orhi	r3,r3,128
  80c578:	11400b0e 	bge	r2,r5,80c5a8 <__fixsfsi+0x60>
  80c57c:	28bfda84 	addi	r2,r5,-150
  80c580:	1884983a 	sll	r2,r3,r2
  80c584:	20000726 	beq	r4,zero,80c5a4 <__fixsfsi+0x5c>
  80c588:	0085c83a 	sub	r2,zero,r2
  80c58c:	f800283a 	ret
  80c590:	00a00034 	movhi	r2,32768
  80c594:	10bfffc4 	addi	r2,r2,-1
  80c598:	2085883a 	add	r2,r4,r2
  80c59c:	f800283a 	ret
  80c5a0:	0005883a 	mov	r2,zero
  80c5a4:	f800283a 	ret
  80c5a8:	00802584 	movi	r2,150
  80c5ac:	1145c83a 	sub	r2,r2,r5
  80c5b0:	1884d83a 	srl	r2,r3,r2
  80c5b4:	003ff306 	br	80c584 <__alt_data_end+0xfff0c584>

0080c5b8 <__floatsisf>:
  80c5b8:	defffd04 	addi	sp,sp,-12
  80c5bc:	dfc00215 	stw	ra,8(sp)
  80c5c0:	dc400115 	stw	r17,4(sp)
  80c5c4:	dc000015 	stw	r16,0(sp)
  80c5c8:	20003526 	beq	r4,zero,80c6a0 <__floatsisf+0xe8>
  80c5cc:	2021883a 	mov	r16,r4
  80c5d0:	2022d7fa 	srli	r17,r4,31
  80c5d4:	20003616 	blt	r4,zero,80c6b0 <__floatsisf+0xf8>
  80c5d8:	8009883a 	mov	r4,r16
  80c5dc:	080f21c0 	call	80f21c <__clzsi2>
  80c5e0:	00c02784 	movi	r3,158
  80c5e4:	1887c83a 	sub	r3,r3,r2
  80c5e8:	01002584 	movi	r4,150
  80c5ec:	20c01416 	blt	r4,r3,80c640 <__floatsisf+0x88>
  80c5f0:	20c9c83a 	sub	r4,r4,r3
  80c5f4:	8120983a 	sll	r16,r16,r4
  80c5f8:	00802034 	movhi	r2,128
  80c5fc:	10bfffc4 	addi	r2,r2,-1
  80c600:	8809883a 	mov	r4,r17
  80c604:	80a0703a 	and	r16,r16,r2
  80c608:	18803fcc 	andi	r2,r3,255
  80c60c:	100695fa 	slli	r3,r2,23
  80c610:	20803fcc 	andi	r2,r4,255
  80c614:	100897fa 	slli	r4,r2,31
  80c618:	00802034 	movhi	r2,128
  80c61c:	10bfffc4 	addi	r2,r2,-1
  80c620:	8084703a 	and	r2,r16,r2
  80c624:	10c4b03a 	or	r2,r2,r3
  80c628:	1104b03a 	or	r2,r2,r4
  80c62c:	dfc00217 	ldw	ra,8(sp)
  80c630:	dc400117 	ldw	r17,4(sp)
  80c634:	dc000017 	ldw	r16,0(sp)
  80c638:	dec00304 	addi	sp,sp,12
  80c63c:	f800283a 	ret
  80c640:	01002644 	movi	r4,153
  80c644:	20c01c16 	blt	r4,r3,80c6b8 <__floatsisf+0x100>
  80c648:	20c9c83a 	sub	r4,r4,r3
  80c64c:	8120983a 	sll	r16,r16,r4
  80c650:	013f0034 	movhi	r4,64512
  80c654:	213fffc4 	addi	r4,r4,-1
  80c658:	814001cc 	andi	r5,r16,7
  80c65c:	8108703a 	and	r4,r16,r4
  80c660:	28000426 	beq	r5,zero,80c674 <__floatsisf+0xbc>
  80c664:	840003cc 	andi	r16,r16,15
  80c668:	01400104 	movi	r5,4
  80c66c:	81400126 	beq	r16,r5,80c674 <__floatsisf+0xbc>
  80c670:	2149883a 	add	r4,r4,r5
  80c674:	2141002c 	andhi	r5,r4,1024
  80c678:	28000526 	beq	r5,zero,80c690 <__floatsisf+0xd8>
  80c67c:	00c027c4 	movi	r3,159
  80c680:	1887c83a 	sub	r3,r3,r2
  80c684:	00bf0034 	movhi	r2,64512
  80c688:	10bfffc4 	addi	r2,r2,-1
  80c68c:	2088703a 	and	r4,r4,r2
  80c690:	202091ba 	slli	r16,r4,6
  80c694:	8809883a 	mov	r4,r17
  80c698:	8020d27a 	srli	r16,r16,9
  80c69c:	003fda06 	br	80c608 <__alt_data_end+0xfff0c608>
  80c6a0:	0009883a 	mov	r4,zero
  80c6a4:	0007883a 	mov	r3,zero
  80c6a8:	0021883a 	mov	r16,zero
  80c6ac:	003fd606 	br	80c608 <__alt_data_end+0xfff0c608>
  80c6b0:	0121c83a 	sub	r16,zero,r4
  80c6b4:	003fc806 	br	80c5d8 <__alt_data_end+0xfff0c5d8>
  80c6b8:	01002e44 	movi	r4,185
  80c6bc:	20c9c83a 	sub	r4,r4,r3
  80c6c0:	01400144 	movi	r5,5
  80c6c4:	8108983a 	sll	r4,r16,r4
  80c6c8:	288bc83a 	sub	r5,r5,r2
  80c6cc:	8160d83a 	srl	r16,r16,r5
  80c6d0:	2008c03a 	cmpne	r4,r4,zero
  80c6d4:	8120b03a 	or	r16,r16,r4
  80c6d8:	003fdd06 	br	80c650 <__alt_data_end+0xfff0c650>

0080c6dc <__floatunsisf>:
  80c6dc:	defffe04 	addi	sp,sp,-8
  80c6e0:	dfc00115 	stw	ra,4(sp)
  80c6e4:	dc000015 	stw	r16,0(sp)
  80c6e8:	20002c26 	beq	r4,zero,80c79c <__floatunsisf+0xc0>
  80c6ec:	2021883a 	mov	r16,r4
  80c6f0:	080f21c0 	call	80f21c <__clzsi2>
  80c6f4:	00c02784 	movi	r3,158
  80c6f8:	1887c83a 	sub	r3,r3,r2
  80c6fc:	01002584 	movi	r4,150
  80c700:	20c00f16 	blt	r4,r3,80c740 <__floatunsisf+0x64>
  80c704:	20c9c83a 	sub	r4,r4,r3
  80c708:	8108983a 	sll	r4,r16,r4
  80c70c:	00802034 	movhi	r2,128
  80c710:	10bfffc4 	addi	r2,r2,-1
  80c714:	2088703a 	and	r4,r4,r2
  80c718:	18803fcc 	andi	r2,r3,255
  80c71c:	100695fa 	slli	r3,r2,23
  80c720:	00802034 	movhi	r2,128
  80c724:	10bfffc4 	addi	r2,r2,-1
  80c728:	2084703a 	and	r2,r4,r2
  80c72c:	10c4b03a 	or	r2,r2,r3
  80c730:	dfc00117 	ldw	ra,4(sp)
  80c734:	dc000017 	ldw	r16,0(sp)
  80c738:	dec00204 	addi	sp,sp,8
  80c73c:	f800283a 	ret
  80c740:	01002644 	movi	r4,153
  80c744:	20c01816 	blt	r4,r3,80c7a8 <__floatunsisf+0xcc>
  80c748:	20c9c83a 	sub	r4,r4,r3
  80c74c:	8108983a 	sll	r4,r16,r4
  80c750:	017f0034 	movhi	r5,64512
  80c754:	297fffc4 	addi	r5,r5,-1
  80c758:	218001cc 	andi	r6,r4,7
  80c75c:	214a703a 	and	r5,r4,r5
  80c760:	30000426 	beq	r6,zero,80c774 <__floatunsisf+0x98>
  80c764:	210003cc 	andi	r4,r4,15
  80c768:	01800104 	movi	r6,4
  80c76c:	21800126 	beq	r4,r6,80c774 <__floatunsisf+0x98>
  80c770:	298b883a 	add	r5,r5,r6
  80c774:	2901002c 	andhi	r4,r5,1024
  80c778:	20000526 	beq	r4,zero,80c790 <__floatunsisf+0xb4>
  80c77c:	00c027c4 	movi	r3,159
  80c780:	1887c83a 	sub	r3,r3,r2
  80c784:	00bf0034 	movhi	r2,64512
  80c788:	10bfffc4 	addi	r2,r2,-1
  80c78c:	288a703a 	and	r5,r5,r2
  80c790:	280891ba 	slli	r4,r5,6
  80c794:	2008d27a 	srli	r4,r4,9
  80c798:	003fdf06 	br	80c718 <__alt_data_end+0xfff0c718>
  80c79c:	0007883a 	mov	r3,zero
  80c7a0:	0009883a 	mov	r4,zero
  80c7a4:	003fdc06 	br	80c718 <__alt_data_end+0xfff0c718>
  80c7a8:	01402e44 	movi	r5,185
  80c7ac:	28cbc83a 	sub	r5,r5,r3
  80c7b0:	01000144 	movi	r4,5
  80c7b4:	2089c83a 	sub	r4,r4,r2
  80c7b8:	814a983a 	sll	r5,r16,r5
  80c7bc:	8108d83a 	srl	r4,r16,r4
  80c7c0:	2820c03a 	cmpne	r16,r5,zero
  80c7c4:	2408b03a 	or	r4,r4,r16
  80c7c8:	003fe106 	br	80c750 <__alt_data_end+0xfff0c750>

0080c7cc <__adddf3>:
  80c7cc:	02c00434 	movhi	r11,16
  80c7d0:	5affffc4 	addi	r11,r11,-1
  80c7d4:	2806d7fa 	srli	r3,r5,31
  80c7d8:	2ad4703a 	and	r10,r5,r11
  80c7dc:	3ad2703a 	and	r9,r7,r11
  80c7e0:	3804d53a 	srli	r2,r7,20
  80c7e4:	3018d77a 	srli	r12,r6,29
  80c7e8:	280ad53a 	srli	r5,r5,20
  80c7ec:	501490fa 	slli	r10,r10,3
  80c7f0:	2010d77a 	srli	r8,r4,29
  80c7f4:	481290fa 	slli	r9,r9,3
  80c7f8:	380ed7fa 	srli	r7,r7,31
  80c7fc:	defffb04 	addi	sp,sp,-20
  80c800:	dc800215 	stw	r18,8(sp)
  80c804:	dc400115 	stw	r17,4(sp)
  80c808:	dc000015 	stw	r16,0(sp)
  80c80c:	dfc00415 	stw	ra,16(sp)
  80c810:	dcc00315 	stw	r19,12(sp)
  80c814:	1c803fcc 	andi	r18,r3,255
  80c818:	2c01ffcc 	andi	r16,r5,2047
  80c81c:	5210b03a 	or	r8,r10,r8
  80c820:	202290fa 	slli	r17,r4,3
  80c824:	1081ffcc 	andi	r2,r2,2047
  80c828:	4b12b03a 	or	r9,r9,r12
  80c82c:	300c90fa 	slli	r6,r6,3
  80c830:	91c07526 	beq	r18,r7,80ca08 <__adddf3+0x23c>
  80c834:	8087c83a 	sub	r3,r16,r2
  80c838:	00c0ab0e 	bge	zero,r3,80cae8 <__adddf3+0x31c>
  80c83c:	10002a1e 	bne	r2,zero,80c8e8 <__adddf3+0x11c>
  80c840:	4984b03a 	or	r2,r9,r6
  80c844:	1000961e 	bne	r2,zero,80caa0 <__adddf3+0x2d4>
  80c848:	888001cc 	andi	r2,r17,7
  80c84c:	10000726 	beq	r2,zero,80c86c <__adddf3+0xa0>
  80c850:	888003cc 	andi	r2,r17,15
  80c854:	00c00104 	movi	r3,4
  80c858:	10c00426 	beq	r2,r3,80c86c <__adddf3+0xa0>
  80c85c:	88c7883a 	add	r3,r17,r3
  80c860:	1c63803a 	cmpltu	r17,r3,r17
  80c864:	4451883a 	add	r8,r8,r17
  80c868:	1823883a 	mov	r17,r3
  80c86c:	4080202c 	andhi	r2,r8,128
  80c870:	10005926 	beq	r2,zero,80c9d8 <__adddf3+0x20c>
  80c874:	84000044 	addi	r16,r16,1
  80c878:	0081ffc4 	movi	r2,2047
  80c87c:	8080ba26 	beq	r16,r2,80cb68 <__adddf3+0x39c>
  80c880:	00bfe034 	movhi	r2,65408
  80c884:	10bfffc4 	addi	r2,r2,-1
  80c888:	4090703a 	and	r8,r8,r2
  80c88c:	4004977a 	slli	r2,r8,29
  80c890:	4010927a 	slli	r8,r8,9
  80c894:	8822d0fa 	srli	r17,r17,3
  80c898:	8401ffcc 	andi	r16,r16,2047
  80c89c:	4010d33a 	srli	r8,r8,12
  80c8a0:	9007883a 	mov	r3,r18
  80c8a4:	1444b03a 	or	r2,r2,r17
  80c8a8:	8401ffcc 	andi	r16,r16,2047
  80c8ac:	8020953a 	slli	r16,r16,20
  80c8b0:	18c03fcc 	andi	r3,r3,255
  80c8b4:	01000434 	movhi	r4,16
  80c8b8:	213fffc4 	addi	r4,r4,-1
  80c8bc:	180697fa 	slli	r3,r3,31
  80c8c0:	4110703a 	and	r8,r8,r4
  80c8c4:	4410b03a 	or	r8,r8,r16
  80c8c8:	40c6b03a 	or	r3,r8,r3
  80c8cc:	dfc00417 	ldw	ra,16(sp)
  80c8d0:	dcc00317 	ldw	r19,12(sp)
  80c8d4:	dc800217 	ldw	r18,8(sp)
  80c8d8:	dc400117 	ldw	r17,4(sp)
  80c8dc:	dc000017 	ldw	r16,0(sp)
  80c8e0:	dec00504 	addi	sp,sp,20
  80c8e4:	f800283a 	ret
  80c8e8:	0081ffc4 	movi	r2,2047
  80c8ec:	80bfd626 	beq	r16,r2,80c848 <__alt_data_end+0xfff0c848>
  80c8f0:	4a402034 	orhi	r9,r9,128
  80c8f4:	00800e04 	movi	r2,56
  80c8f8:	10c09f16 	blt	r2,r3,80cb78 <__adddf3+0x3ac>
  80c8fc:	008007c4 	movi	r2,31
  80c900:	10c0c216 	blt	r2,r3,80cc0c <__adddf3+0x440>
  80c904:	00800804 	movi	r2,32
  80c908:	10c5c83a 	sub	r2,r2,r3
  80c90c:	488a983a 	sll	r5,r9,r2
  80c910:	30c8d83a 	srl	r4,r6,r3
  80c914:	3084983a 	sll	r2,r6,r2
  80c918:	48c6d83a 	srl	r3,r9,r3
  80c91c:	290cb03a 	or	r6,r5,r4
  80c920:	1004c03a 	cmpne	r2,r2,zero
  80c924:	308cb03a 	or	r6,r6,r2
  80c928:	898dc83a 	sub	r6,r17,r6
  80c92c:	89a3803a 	cmpltu	r17,r17,r6
  80c930:	40d1c83a 	sub	r8,r8,r3
  80c934:	4451c83a 	sub	r8,r8,r17
  80c938:	3023883a 	mov	r17,r6
  80c93c:	4080202c 	andhi	r2,r8,128
  80c940:	10002326 	beq	r2,zero,80c9d0 <__adddf3+0x204>
  80c944:	04c02034 	movhi	r19,128
  80c948:	9cffffc4 	addi	r19,r19,-1
  80c94c:	44e6703a 	and	r19,r8,r19
  80c950:	98007626 	beq	r19,zero,80cb2c <__adddf3+0x360>
  80c954:	9809883a 	mov	r4,r19
  80c958:	080f21c0 	call	80f21c <__clzsi2>
  80c95c:	10fffe04 	addi	r3,r2,-8
  80c960:	010007c4 	movi	r4,31
  80c964:	20c07716 	blt	r4,r3,80cb44 <__adddf3+0x378>
  80c968:	00800804 	movi	r2,32
  80c96c:	10c5c83a 	sub	r2,r2,r3
  80c970:	8884d83a 	srl	r2,r17,r2
  80c974:	98d0983a 	sll	r8,r19,r3
  80c978:	88e2983a 	sll	r17,r17,r3
  80c97c:	1204b03a 	or	r2,r2,r8
  80c980:	1c007416 	blt	r3,r16,80cb54 <__adddf3+0x388>
  80c984:	1c21c83a 	sub	r16,r3,r16
  80c988:	82000044 	addi	r8,r16,1
  80c98c:	00c007c4 	movi	r3,31
  80c990:	1a009116 	blt	r3,r8,80cbd8 <__adddf3+0x40c>
  80c994:	00c00804 	movi	r3,32
  80c998:	1a07c83a 	sub	r3,r3,r8
  80c99c:	8a08d83a 	srl	r4,r17,r8
  80c9a0:	88e2983a 	sll	r17,r17,r3
  80c9a4:	10c6983a 	sll	r3,r2,r3
  80c9a8:	1210d83a 	srl	r8,r2,r8
  80c9ac:	8804c03a 	cmpne	r2,r17,zero
  80c9b0:	1906b03a 	or	r3,r3,r4
  80c9b4:	18a2b03a 	or	r17,r3,r2
  80c9b8:	0021883a 	mov	r16,zero
  80c9bc:	003fa206 	br	80c848 <__alt_data_end+0xfff0c848>
  80c9c0:	1890b03a 	or	r8,r3,r2
  80c9c4:	40017d26 	beq	r8,zero,80cfbc <__adddf3+0x7f0>
  80c9c8:	1011883a 	mov	r8,r2
  80c9cc:	1823883a 	mov	r17,r3
  80c9d0:	888001cc 	andi	r2,r17,7
  80c9d4:	103f9e1e 	bne	r2,zero,80c850 <__alt_data_end+0xfff0c850>
  80c9d8:	4004977a 	slli	r2,r8,29
  80c9dc:	8822d0fa 	srli	r17,r17,3
  80c9e0:	4010d0fa 	srli	r8,r8,3
  80c9e4:	9007883a 	mov	r3,r18
  80c9e8:	1444b03a 	or	r2,r2,r17
  80c9ec:	0101ffc4 	movi	r4,2047
  80c9f0:	81002426 	beq	r16,r4,80ca84 <__adddf3+0x2b8>
  80c9f4:	8120703a 	and	r16,r16,r4
  80c9f8:	01000434 	movhi	r4,16
  80c9fc:	213fffc4 	addi	r4,r4,-1
  80ca00:	4110703a 	and	r8,r8,r4
  80ca04:	003fa806 	br	80c8a8 <__alt_data_end+0xfff0c8a8>
  80ca08:	8089c83a 	sub	r4,r16,r2
  80ca0c:	01005e0e 	bge	zero,r4,80cb88 <__adddf3+0x3bc>
  80ca10:	10002b26 	beq	r2,zero,80cac0 <__adddf3+0x2f4>
  80ca14:	0081ffc4 	movi	r2,2047
  80ca18:	80bf8b26 	beq	r16,r2,80c848 <__alt_data_end+0xfff0c848>
  80ca1c:	4a402034 	orhi	r9,r9,128
  80ca20:	00800e04 	movi	r2,56
  80ca24:	1100a40e 	bge	r2,r4,80ccb8 <__adddf3+0x4ec>
  80ca28:	498cb03a 	or	r6,r9,r6
  80ca2c:	300ac03a 	cmpne	r5,r6,zero
  80ca30:	0013883a 	mov	r9,zero
  80ca34:	2c4b883a 	add	r5,r5,r17
  80ca38:	2c63803a 	cmpltu	r17,r5,r17
  80ca3c:	4a11883a 	add	r8,r9,r8
  80ca40:	8a11883a 	add	r8,r17,r8
  80ca44:	2823883a 	mov	r17,r5
  80ca48:	4080202c 	andhi	r2,r8,128
  80ca4c:	103fe026 	beq	r2,zero,80c9d0 <__alt_data_end+0xfff0c9d0>
  80ca50:	84000044 	addi	r16,r16,1
  80ca54:	0081ffc4 	movi	r2,2047
  80ca58:	8080d226 	beq	r16,r2,80cda4 <__adddf3+0x5d8>
  80ca5c:	00bfe034 	movhi	r2,65408
  80ca60:	10bfffc4 	addi	r2,r2,-1
  80ca64:	4090703a 	and	r8,r8,r2
  80ca68:	880ad07a 	srli	r5,r17,1
  80ca6c:	400897fa 	slli	r4,r8,31
  80ca70:	88c0004c 	andi	r3,r17,1
  80ca74:	28e2b03a 	or	r17,r5,r3
  80ca78:	4010d07a 	srli	r8,r8,1
  80ca7c:	2462b03a 	or	r17,r4,r17
  80ca80:	003f7106 	br	80c848 <__alt_data_end+0xfff0c848>
  80ca84:	4088b03a 	or	r4,r8,r2
  80ca88:	20014526 	beq	r4,zero,80cfa0 <__adddf3+0x7d4>
  80ca8c:	01000434 	movhi	r4,16
  80ca90:	42000234 	orhi	r8,r8,8
  80ca94:	213fffc4 	addi	r4,r4,-1
  80ca98:	4110703a 	and	r8,r8,r4
  80ca9c:	003f8206 	br	80c8a8 <__alt_data_end+0xfff0c8a8>
  80caa0:	18ffffc4 	addi	r3,r3,-1
  80caa4:	1800491e 	bne	r3,zero,80cbcc <__adddf3+0x400>
  80caa8:	898bc83a 	sub	r5,r17,r6
  80caac:	8963803a 	cmpltu	r17,r17,r5
  80cab0:	4251c83a 	sub	r8,r8,r9
  80cab4:	4451c83a 	sub	r8,r8,r17
  80cab8:	2823883a 	mov	r17,r5
  80cabc:	003f9f06 	br	80c93c <__alt_data_end+0xfff0c93c>
  80cac0:	4984b03a 	or	r2,r9,r6
  80cac4:	103f6026 	beq	r2,zero,80c848 <__alt_data_end+0xfff0c848>
  80cac8:	213fffc4 	addi	r4,r4,-1
  80cacc:	2000931e 	bne	r4,zero,80cd1c <__adddf3+0x550>
  80cad0:	898d883a 	add	r6,r17,r6
  80cad4:	3463803a 	cmpltu	r17,r6,r17
  80cad8:	4251883a 	add	r8,r8,r9
  80cadc:	8a11883a 	add	r8,r17,r8
  80cae0:	3023883a 	mov	r17,r6
  80cae4:	003fd806 	br	80ca48 <__alt_data_end+0xfff0ca48>
  80cae8:	1800541e 	bne	r3,zero,80cc3c <__adddf3+0x470>
  80caec:	80800044 	addi	r2,r16,1
  80caf0:	1081ffcc 	andi	r2,r2,2047
  80caf4:	00c00044 	movi	r3,1
  80caf8:	1880a00e 	bge	r3,r2,80cd7c <__adddf3+0x5b0>
  80cafc:	8989c83a 	sub	r4,r17,r6
  80cb00:	8905803a 	cmpltu	r2,r17,r4
  80cb04:	4267c83a 	sub	r19,r8,r9
  80cb08:	98a7c83a 	sub	r19,r19,r2
  80cb0c:	9880202c 	andhi	r2,r19,128
  80cb10:	10006326 	beq	r2,zero,80cca0 <__adddf3+0x4d4>
  80cb14:	3463c83a 	sub	r17,r6,r17
  80cb18:	4a07c83a 	sub	r3,r9,r8
  80cb1c:	344d803a 	cmpltu	r6,r6,r17
  80cb20:	19a7c83a 	sub	r19,r3,r6
  80cb24:	3825883a 	mov	r18,r7
  80cb28:	983f8a1e 	bne	r19,zero,80c954 <__alt_data_end+0xfff0c954>
  80cb2c:	8809883a 	mov	r4,r17
  80cb30:	080f21c0 	call	80f21c <__clzsi2>
  80cb34:	10800804 	addi	r2,r2,32
  80cb38:	10fffe04 	addi	r3,r2,-8
  80cb3c:	010007c4 	movi	r4,31
  80cb40:	20ff890e 	bge	r4,r3,80c968 <__alt_data_end+0xfff0c968>
  80cb44:	10bff604 	addi	r2,r2,-40
  80cb48:	8884983a 	sll	r2,r17,r2
  80cb4c:	0023883a 	mov	r17,zero
  80cb50:	1c3f8c0e 	bge	r3,r16,80c984 <__alt_data_end+0xfff0c984>
  80cb54:	023fe034 	movhi	r8,65408
  80cb58:	423fffc4 	addi	r8,r8,-1
  80cb5c:	80e1c83a 	sub	r16,r16,r3
  80cb60:	1210703a 	and	r8,r2,r8
  80cb64:	003f3806 	br	80c848 <__alt_data_end+0xfff0c848>
  80cb68:	9007883a 	mov	r3,r18
  80cb6c:	0011883a 	mov	r8,zero
  80cb70:	0005883a 	mov	r2,zero
  80cb74:	003f4c06 	br	80c8a8 <__alt_data_end+0xfff0c8a8>
  80cb78:	498cb03a 	or	r6,r9,r6
  80cb7c:	300cc03a 	cmpne	r6,r6,zero
  80cb80:	0007883a 	mov	r3,zero
  80cb84:	003f6806 	br	80c928 <__alt_data_end+0xfff0c928>
  80cb88:	20009c1e 	bne	r4,zero,80cdfc <__adddf3+0x630>
  80cb8c:	80800044 	addi	r2,r16,1
  80cb90:	1141ffcc 	andi	r5,r2,2047
  80cb94:	01000044 	movi	r4,1
  80cb98:	2140670e 	bge	r4,r5,80cd38 <__adddf3+0x56c>
  80cb9c:	0101ffc4 	movi	r4,2047
  80cba0:	11007f26 	beq	r2,r4,80cda0 <__adddf3+0x5d4>
  80cba4:	898d883a 	add	r6,r17,r6
  80cba8:	4247883a 	add	r3,r8,r9
  80cbac:	3451803a 	cmpltu	r8,r6,r17
  80cbb0:	40d1883a 	add	r8,r8,r3
  80cbb4:	402297fa 	slli	r17,r8,31
  80cbb8:	300cd07a 	srli	r6,r6,1
  80cbbc:	4010d07a 	srli	r8,r8,1
  80cbc0:	1021883a 	mov	r16,r2
  80cbc4:	89a2b03a 	or	r17,r17,r6
  80cbc8:	003f1f06 	br	80c848 <__alt_data_end+0xfff0c848>
  80cbcc:	0081ffc4 	movi	r2,2047
  80cbd0:	80bf481e 	bne	r16,r2,80c8f4 <__alt_data_end+0xfff0c8f4>
  80cbd4:	003f1c06 	br	80c848 <__alt_data_end+0xfff0c848>
  80cbd8:	843ff844 	addi	r16,r16,-31
  80cbdc:	01000804 	movi	r4,32
  80cbe0:	1406d83a 	srl	r3,r2,r16
  80cbe4:	41005026 	beq	r8,r4,80cd28 <__adddf3+0x55c>
  80cbe8:	01001004 	movi	r4,64
  80cbec:	2211c83a 	sub	r8,r4,r8
  80cbf0:	1204983a 	sll	r2,r2,r8
  80cbf4:	88a2b03a 	or	r17,r17,r2
  80cbf8:	8822c03a 	cmpne	r17,r17,zero
  80cbfc:	1c62b03a 	or	r17,r3,r17
  80cc00:	0011883a 	mov	r8,zero
  80cc04:	0021883a 	mov	r16,zero
  80cc08:	003f7106 	br	80c9d0 <__alt_data_end+0xfff0c9d0>
  80cc0c:	193ff804 	addi	r4,r3,-32
  80cc10:	00800804 	movi	r2,32
  80cc14:	4908d83a 	srl	r4,r9,r4
  80cc18:	18804526 	beq	r3,r2,80cd30 <__adddf3+0x564>
  80cc1c:	00801004 	movi	r2,64
  80cc20:	10c5c83a 	sub	r2,r2,r3
  80cc24:	4886983a 	sll	r3,r9,r2
  80cc28:	198cb03a 	or	r6,r3,r6
  80cc2c:	300cc03a 	cmpne	r6,r6,zero
  80cc30:	218cb03a 	or	r6,r4,r6
  80cc34:	0007883a 	mov	r3,zero
  80cc38:	003f3b06 	br	80c928 <__alt_data_end+0xfff0c928>
  80cc3c:	80002a26 	beq	r16,zero,80cce8 <__adddf3+0x51c>
  80cc40:	0101ffc4 	movi	r4,2047
  80cc44:	11006826 	beq	r2,r4,80cde8 <__adddf3+0x61c>
  80cc48:	00c7c83a 	sub	r3,zero,r3
  80cc4c:	42002034 	orhi	r8,r8,128
  80cc50:	01000e04 	movi	r4,56
  80cc54:	20c07c16 	blt	r4,r3,80ce48 <__adddf3+0x67c>
  80cc58:	010007c4 	movi	r4,31
  80cc5c:	20c0da16 	blt	r4,r3,80cfc8 <__adddf3+0x7fc>
  80cc60:	01000804 	movi	r4,32
  80cc64:	20c9c83a 	sub	r4,r4,r3
  80cc68:	4114983a 	sll	r10,r8,r4
  80cc6c:	88cad83a 	srl	r5,r17,r3
  80cc70:	8908983a 	sll	r4,r17,r4
  80cc74:	40c6d83a 	srl	r3,r8,r3
  80cc78:	5162b03a 	or	r17,r10,r5
  80cc7c:	2008c03a 	cmpne	r4,r4,zero
  80cc80:	8922b03a 	or	r17,r17,r4
  80cc84:	3463c83a 	sub	r17,r6,r17
  80cc88:	48c7c83a 	sub	r3,r9,r3
  80cc8c:	344d803a 	cmpltu	r6,r6,r17
  80cc90:	1991c83a 	sub	r8,r3,r6
  80cc94:	1021883a 	mov	r16,r2
  80cc98:	3825883a 	mov	r18,r7
  80cc9c:	003f2706 	br	80c93c <__alt_data_end+0xfff0c93c>
  80cca0:	24d0b03a 	or	r8,r4,r19
  80cca4:	40001b1e 	bne	r8,zero,80cd14 <__adddf3+0x548>
  80cca8:	0005883a 	mov	r2,zero
  80ccac:	0007883a 	mov	r3,zero
  80ccb0:	0021883a 	mov	r16,zero
  80ccb4:	003f4d06 	br	80c9ec <__alt_data_end+0xfff0c9ec>
  80ccb8:	008007c4 	movi	r2,31
  80ccbc:	11003c16 	blt	r2,r4,80cdb0 <__adddf3+0x5e4>
  80ccc0:	00800804 	movi	r2,32
  80ccc4:	1105c83a 	sub	r2,r2,r4
  80ccc8:	488e983a 	sll	r7,r9,r2
  80cccc:	310ad83a 	srl	r5,r6,r4
  80ccd0:	3084983a 	sll	r2,r6,r2
  80ccd4:	4912d83a 	srl	r9,r9,r4
  80ccd8:	394ab03a 	or	r5,r7,r5
  80ccdc:	1004c03a 	cmpne	r2,r2,zero
  80cce0:	288ab03a 	or	r5,r5,r2
  80cce4:	003f5306 	br	80ca34 <__alt_data_end+0xfff0ca34>
  80cce8:	4448b03a 	or	r4,r8,r17
  80ccec:	20003e26 	beq	r4,zero,80cde8 <__adddf3+0x61c>
  80ccf0:	00c6303a 	nor	r3,zero,r3
  80ccf4:	18003a1e 	bne	r3,zero,80cde0 <__adddf3+0x614>
  80ccf8:	3463c83a 	sub	r17,r6,r17
  80ccfc:	4a07c83a 	sub	r3,r9,r8
  80cd00:	344d803a 	cmpltu	r6,r6,r17
  80cd04:	1991c83a 	sub	r8,r3,r6
  80cd08:	1021883a 	mov	r16,r2
  80cd0c:	3825883a 	mov	r18,r7
  80cd10:	003f0a06 	br	80c93c <__alt_data_end+0xfff0c93c>
  80cd14:	2023883a 	mov	r17,r4
  80cd18:	003f0d06 	br	80c950 <__alt_data_end+0xfff0c950>
  80cd1c:	0081ffc4 	movi	r2,2047
  80cd20:	80bf3f1e 	bne	r16,r2,80ca20 <__alt_data_end+0xfff0ca20>
  80cd24:	003ec806 	br	80c848 <__alt_data_end+0xfff0c848>
  80cd28:	0005883a 	mov	r2,zero
  80cd2c:	003fb106 	br	80cbf4 <__alt_data_end+0xfff0cbf4>
  80cd30:	0007883a 	mov	r3,zero
  80cd34:	003fbc06 	br	80cc28 <__alt_data_end+0xfff0cc28>
  80cd38:	4444b03a 	or	r2,r8,r17
  80cd3c:	8000871e 	bne	r16,zero,80cf5c <__adddf3+0x790>
  80cd40:	1000ba26 	beq	r2,zero,80d02c <__adddf3+0x860>
  80cd44:	4984b03a 	or	r2,r9,r6
  80cd48:	103ebf26 	beq	r2,zero,80c848 <__alt_data_end+0xfff0c848>
  80cd4c:	8985883a 	add	r2,r17,r6
  80cd50:	4247883a 	add	r3,r8,r9
  80cd54:	1451803a 	cmpltu	r8,r2,r17
  80cd58:	40d1883a 	add	r8,r8,r3
  80cd5c:	40c0202c 	andhi	r3,r8,128
  80cd60:	1023883a 	mov	r17,r2
  80cd64:	183f1a26 	beq	r3,zero,80c9d0 <__alt_data_end+0xfff0c9d0>
  80cd68:	00bfe034 	movhi	r2,65408
  80cd6c:	10bfffc4 	addi	r2,r2,-1
  80cd70:	2021883a 	mov	r16,r4
  80cd74:	4090703a 	and	r8,r8,r2
  80cd78:	003eb306 	br	80c848 <__alt_data_end+0xfff0c848>
  80cd7c:	4444b03a 	or	r2,r8,r17
  80cd80:	8000291e 	bne	r16,zero,80ce28 <__adddf3+0x65c>
  80cd84:	10004b1e 	bne	r2,zero,80ceb4 <__adddf3+0x6e8>
  80cd88:	4990b03a 	or	r8,r9,r6
  80cd8c:	40008b26 	beq	r8,zero,80cfbc <__adddf3+0x7f0>
  80cd90:	4811883a 	mov	r8,r9
  80cd94:	3023883a 	mov	r17,r6
  80cd98:	3825883a 	mov	r18,r7
  80cd9c:	003eaa06 	br	80c848 <__alt_data_end+0xfff0c848>
  80cda0:	1021883a 	mov	r16,r2
  80cda4:	0011883a 	mov	r8,zero
  80cda8:	0005883a 	mov	r2,zero
  80cdac:	003f0f06 	br	80c9ec <__alt_data_end+0xfff0c9ec>
  80cdb0:	217ff804 	addi	r5,r4,-32
  80cdb4:	00800804 	movi	r2,32
  80cdb8:	494ad83a 	srl	r5,r9,r5
  80cdbc:	20807d26 	beq	r4,r2,80cfb4 <__adddf3+0x7e8>
  80cdc0:	00801004 	movi	r2,64
  80cdc4:	1109c83a 	sub	r4,r2,r4
  80cdc8:	4912983a 	sll	r9,r9,r4
  80cdcc:	498cb03a 	or	r6,r9,r6
  80cdd0:	300cc03a 	cmpne	r6,r6,zero
  80cdd4:	298ab03a 	or	r5,r5,r6
  80cdd8:	0013883a 	mov	r9,zero
  80cddc:	003f1506 	br	80ca34 <__alt_data_end+0xfff0ca34>
  80cde0:	0101ffc4 	movi	r4,2047
  80cde4:	113f9a1e 	bne	r2,r4,80cc50 <__alt_data_end+0xfff0cc50>
  80cde8:	4811883a 	mov	r8,r9
  80cdec:	3023883a 	mov	r17,r6
  80cdf0:	1021883a 	mov	r16,r2
  80cdf4:	3825883a 	mov	r18,r7
  80cdf8:	003e9306 	br	80c848 <__alt_data_end+0xfff0c848>
  80cdfc:	8000161e 	bne	r16,zero,80ce58 <__adddf3+0x68c>
  80ce00:	444ab03a 	or	r5,r8,r17
  80ce04:	28005126 	beq	r5,zero,80cf4c <__adddf3+0x780>
  80ce08:	0108303a 	nor	r4,zero,r4
  80ce0c:	20004d1e 	bne	r4,zero,80cf44 <__adddf3+0x778>
  80ce10:	89a3883a 	add	r17,r17,r6
  80ce14:	4253883a 	add	r9,r8,r9
  80ce18:	898d803a 	cmpltu	r6,r17,r6
  80ce1c:	3251883a 	add	r8,r6,r9
  80ce20:	1021883a 	mov	r16,r2
  80ce24:	003f0806 	br	80ca48 <__alt_data_end+0xfff0ca48>
  80ce28:	1000301e 	bne	r2,zero,80ceec <__adddf3+0x720>
  80ce2c:	4984b03a 	or	r2,r9,r6
  80ce30:	10007126 	beq	r2,zero,80cff8 <__adddf3+0x82c>
  80ce34:	4811883a 	mov	r8,r9
  80ce38:	3023883a 	mov	r17,r6
  80ce3c:	3825883a 	mov	r18,r7
  80ce40:	0401ffc4 	movi	r16,2047
  80ce44:	003e8006 	br	80c848 <__alt_data_end+0xfff0c848>
  80ce48:	4462b03a 	or	r17,r8,r17
  80ce4c:	8822c03a 	cmpne	r17,r17,zero
  80ce50:	0007883a 	mov	r3,zero
  80ce54:	003f8b06 	br	80cc84 <__alt_data_end+0xfff0cc84>
  80ce58:	0141ffc4 	movi	r5,2047
  80ce5c:	11403b26 	beq	r2,r5,80cf4c <__adddf3+0x780>
  80ce60:	0109c83a 	sub	r4,zero,r4
  80ce64:	42002034 	orhi	r8,r8,128
  80ce68:	01400e04 	movi	r5,56
  80ce6c:	29006716 	blt	r5,r4,80d00c <__adddf3+0x840>
  80ce70:	014007c4 	movi	r5,31
  80ce74:	29007016 	blt	r5,r4,80d038 <__adddf3+0x86c>
  80ce78:	01400804 	movi	r5,32
  80ce7c:	290bc83a 	sub	r5,r5,r4
  80ce80:	4154983a 	sll	r10,r8,r5
  80ce84:	890ed83a 	srl	r7,r17,r4
  80ce88:	894a983a 	sll	r5,r17,r5
  80ce8c:	4108d83a 	srl	r4,r8,r4
  80ce90:	51e2b03a 	or	r17,r10,r7
  80ce94:	280ac03a 	cmpne	r5,r5,zero
  80ce98:	8962b03a 	or	r17,r17,r5
  80ce9c:	89a3883a 	add	r17,r17,r6
  80cea0:	2253883a 	add	r9,r4,r9
  80cea4:	898d803a 	cmpltu	r6,r17,r6
  80cea8:	3251883a 	add	r8,r6,r9
  80ceac:	1021883a 	mov	r16,r2
  80ceb0:	003ee506 	br	80ca48 <__alt_data_end+0xfff0ca48>
  80ceb4:	4984b03a 	or	r2,r9,r6
  80ceb8:	103e6326 	beq	r2,zero,80c848 <__alt_data_end+0xfff0c848>
  80cebc:	8987c83a 	sub	r3,r17,r6
  80cec0:	88c9803a 	cmpltu	r4,r17,r3
  80cec4:	4245c83a 	sub	r2,r8,r9
  80cec8:	1105c83a 	sub	r2,r2,r4
  80cecc:	1100202c 	andhi	r4,r2,128
  80ced0:	203ebb26 	beq	r4,zero,80c9c0 <__alt_data_end+0xfff0c9c0>
  80ced4:	3463c83a 	sub	r17,r6,r17
  80ced8:	4a07c83a 	sub	r3,r9,r8
  80cedc:	344d803a 	cmpltu	r6,r6,r17
  80cee0:	1991c83a 	sub	r8,r3,r6
  80cee4:	3825883a 	mov	r18,r7
  80cee8:	003e5706 	br	80c848 <__alt_data_end+0xfff0c848>
  80ceec:	4984b03a 	or	r2,r9,r6
  80cef0:	10002e26 	beq	r2,zero,80cfac <__adddf3+0x7e0>
  80cef4:	4004d0fa 	srli	r2,r8,3
  80cef8:	8822d0fa 	srli	r17,r17,3
  80cefc:	4010977a 	slli	r8,r8,29
  80cf00:	10c0022c 	andhi	r3,r2,8
  80cf04:	4462b03a 	or	r17,r8,r17
  80cf08:	18000826 	beq	r3,zero,80cf2c <__adddf3+0x760>
  80cf0c:	4808d0fa 	srli	r4,r9,3
  80cf10:	20c0022c 	andhi	r3,r4,8
  80cf14:	1800051e 	bne	r3,zero,80cf2c <__adddf3+0x760>
  80cf18:	300cd0fa 	srli	r6,r6,3
  80cf1c:	4806977a 	slli	r3,r9,29
  80cf20:	2005883a 	mov	r2,r4
  80cf24:	3825883a 	mov	r18,r7
  80cf28:	19a2b03a 	or	r17,r3,r6
  80cf2c:	8810d77a 	srli	r8,r17,29
  80cf30:	100490fa 	slli	r2,r2,3
  80cf34:	882290fa 	slli	r17,r17,3
  80cf38:	0401ffc4 	movi	r16,2047
  80cf3c:	4090b03a 	or	r8,r8,r2
  80cf40:	003e4106 	br	80c848 <__alt_data_end+0xfff0c848>
  80cf44:	0141ffc4 	movi	r5,2047
  80cf48:	117fc71e 	bne	r2,r5,80ce68 <__alt_data_end+0xfff0ce68>
  80cf4c:	4811883a 	mov	r8,r9
  80cf50:	3023883a 	mov	r17,r6
  80cf54:	1021883a 	mov	r16,r2
  80cf58:	003e3b06 	br	80c848 <__alt_data_end+0xfff0c848>
  80cf5c:	10002f26 	beq	r2,zero,80d01c <__adddf3+0x850>
  80cf60:	4984b03a 	or	r2,r9,r6
  80cf64:	10001126 	beq	r2,zero,80cfac <__adddf3+0x7e0>
  80cf68:	4004d0fa 	srli	r2,r8,3
  80cf6c:	8822d0fa 	srli	r17,r17,3
  80cf70:	4010977a 	slli	r8,r8,29
  80cf74:	10c0022c 	andhi	r3,r2,8
  80cf78:	4462b03a 	or	r17,r8,r17
  80cf7c:	183feb26 	beq	r3,zero,80cf2c <__alt_data_end+0xfff0cf2c>
  80cf80:	4808d0fa 	srli	r4,r9,3
  80cf84:	20c0022c 	andhi	r3,r4,8
  80cf88:	183fe81e 	bne	r3,zero,80cf2c <__alt_data_end+0xfff0cf2c>
  80cf8c:	300cd0fa 	srli	r6,r6,3
  80cf90:	4806977a 	slli	r3,r9,29
  80cf94:	2005883a 	mov	r2,r4
  80cf98:	19a2b03a 	or	r17,r3,r6
  80cf9c:	003fe306 	br	80cf2c <__alt_data_end+0xfff0cf2c>
  80cfa0:	0011883a 	mov	r8,zero
  80cfa4:	0005883a 	mov	r2,zero
  80cfa8:	003e3f06 	br	80c8a8 <__alt_data_end+0xfff0c8a8>
  80cfac:	0401ffc4 	movi	r16,2047
  80cfb0:	003e2506 	br	80c848 <__alt_data_end+0xfff0c848>
  80cfb4:	0013883a 	mov	r9,zero
  80cfb8:	003f8406 	br	80cdcc <__alt_data_end+0xfff0cdcc>
  80cfbc:	0005883a 	mov	r2,zero
  80cfc0:	0007883a 	mov	r3,zero
  80cfc4:	003e8906 	br	80c9ec <__alt_data_end+0xfff0c9ec>
  80cfc8:	197ff804 	addi	r5,r3,-32
  80cfcc:	01000804 	movi	r4,32
  80cfd0:	414ad83a 	srl	r5,r8,r5
  80cfd4:	19002426 	beq	r3,r4,80d068 <__adddf3+0x89c>
  80cfd8:	01001004 	movi	r4,64
  80cfdc:	20c7c83a 	sub	r3,r4,r3
  80cfe0:	40c6983a 	sll	r3,r8,r3
  80cfe4:	1c46b03a 	or	r3,r3,r17
  80cfe8:	1806c03a 	cmpne	r3,r3,zero
  80cfec:	28e2b03a 	or	r17,r5,r3
  80cff0:	0007883a 	mov	r3,zero
  80cff4:	003f2306 	br	80cc84 <__alt_data_end+0xfff0cc84>
  80cff8:	0007883a 	mov	r3,zero
  80cffc:	5811883a 	mov	r8,r11
  80d000:	00bfffc4 	movi	r2,-1
  80d004:	0401ffc4 	movi	r16,2047
  80d008:	003e7806 	br	80c9ec <__alt_data_end+0xfff0c9ec>
  80d00c:	4462b03a 	or	r17,r8,r17
  80d010:	8822c03a 	cmpne	r17,r17,zero
  80d014:	0009883a 	mov	r4,zero
  80d018:	003fa006 	br	80ce9c <__alt_data_end+0xfff0ce9c>
  80d01c:	4811883a 	mov	r8,r9
  80d020:	3023883a 	mov	r17,r6
  80d024:	0401ffc4 	movi	r16,2047
  80d028:	003e0706 	br	80c848 <__alt_data_end+0xfff0c848>
  80d02c:	4811883a 	mov	r8,r9
  80d030:	3023883a 	mov	r17,r6
  80d034:	003e0406 	br	80c848 <__alt_data_end+0xfff0c848>
  80d038:	21fff804 	addi	r7,r4,-32
  80d03c:	01400804 	movi	r5,32
  80d040:	41ced83a 	srl	r7,r8,r7
  80d044:	21400a26 	beq	r4,r5,80d070 <__adddf3+0x8a4>
  80d048:	01401004 	movi	r5,64
  80d04c:	2909c83a 	sub	r4,r5,r4
  80d050:	4108983a 	sll	r4,r8,r4
  80d054:	2448b03a 	or	r4,r4,r17
  80d058:	2008c03a 	cmpne	r4,r4,zero
  80d05c:	3922b03a 	or	r17,r7,r4
  80d060:	0009883a 	mov	r4,zero
  80d064:	003f8d06 	br	80ce9c <__alt_data_end+0xfff0ce9c>
  80d068:	0007883a 	mov	r3,zero
  80d06c:	003fdd06 	br	80cfe4 <__alt_data_end+0xfff0cfe4>
  80d070:	0009883a 	mov	r4,zero
  80d074:	003ff706 	br	80d054 <__alt_data_end+0xfff0d054>

0080d078 <__divdf3>:
  80d078:	defff004 	addi	sp,sp,-64
  80d07c:	dc800815 	stw	r18,32(sp)
  80d080:	2824d53a 	srli	r18,r5,20
  80d084:	dd800c15 	stw	r22,48(sp)
  80d088:	282cd7fa 	srli	r22,r5,31
  80d08c:	dc000615 	stw	r16,24(sp)
  80d090:	04000434 	movhi	r16,16
  80d094:	843fffc4 	addi	r16,r16,-1
  80d098:	dfc00f15 	stw	ra,60(sp)
  80d09c:	df000e15 	stw	fp,56(sp)
  80d0a0:	ddc00d15 	stw	r23,52(sp)
  80d0a4:	dd400b15 	stw	r21,44(sp)
  80d0a8:	dd000a15 	stw	r20,40(sp)
  80d0ac:	dcc00915 	stw	r19,36(sp)
  80d0b0:	dc400715 	stw	r17,28(sp)
  80d0b4:	9481ffcc 	andi	r18,r18,2047
  80d0b8:	2c20703a 	and	r16,r5,r16
  80d0bc:	b2003fcc 	andi	r8,r22,255
  80d0c0:	90006126 	beq	r18,zero,80d248 <__divdf3+0x1d0>
  80d0c4:	0081ffc4 	movi	r2,2047
  80d0c8:	202b883a 	mov	r21,r4
  80d0cc:	90803726 	beq	r18,r2,80d1ac <__divdf3+0x134>
  80d0d0:	80800434 	orhi	r2,r16,16
  80d0d4:	100490fa 	slli	r2,r2,3
  80d0d8:	2020d77a 	srli	r16,r4,29
  80d0dc:	202a90fa 	slli	r21,r4,3
  80d0e0:	94bf0044 	addi	r18,r18,-1023
  80d0e4:	80a0b03a 	or	r16,r16,r2
  80d0e8:	0013883a 	mov	r9,zero
  80d0ec:	000b883a 	mov	r5,zero
  80d0f0:	3806d53a 	srli	r3,r7,20
  80d0f4:	382ed7fa 	srli	r23,r7,31
  80d0f8:	04400434 	movhi	r17,16
  80d0fc:	8c7fffc4 	addi	r17,r17,-1
  80d100:	18c1ffcc 	andi	r3,r3,2047
  80d104:	3029883a 	mov	r20,r6
  80d108:	3c62703a 	and	r17,r7,r17
  80d10c:	bf003fcc 	andi	fp,r23,255
  80d110:	18006e26 	beq	r3,zero,80d2cc <__divdf3+0x254>
  80d114:	0081ffc4 	movi	r2,2047
  80d118:	18806626 	beq	r3,r2,80d2b4 <__divdf3+0x23c>
  80d11c:	88800434 	orhi	r2,r17,16
  80d120:	100490fa 	slli	r2,r2,3
  80d124:	3022d77a 	srli	r17,r6,29
  80d128:	302890fa 	slli	r20,r6,3
  80d12c:	18ff0044 	addi	r3,r3,-1023
  80d130:	88a2b03a 	or	r17,r17,r2
  80d134:	000f883a 	mov	r7,zero
  80d138:	b5e6f03a 	xor	r19,r22,r23
  80d13c:	3a4cb03a 	or	r6,r7,r9
  80d140:	008003c4 	movi	r2,15
  80d144:	9809883a 	mov	r4,r19
  80d148:	90c7c83a 	sub	r3,r18,r3
  80d14c:	9cc03fcc 	andi	r19,r19,255
  80d150:	11809636 	bltu	r2,r6,80d3ac <__divdf3+0x334>
  80d154:	300c90ba 	slli	r6,r6,2
  80d158:	00802074 	movhi	r2,129
  80d15c:	10b45b04 	addi	r2,r2,-11924
  80d160:	308d883a 	add	r6,r6,r2
  80d164:	30800017 	ldw	r2,0(r6)
  80d168:	1000683a 	jmp	r2
  80d16c:	0080d3ac 	andhi	r2,zero,846
  80d170:	0080d1e4 	muli	r2,zero,839
  80d174:	0080d39c 	xori	r2,zero,846
  80d178:	0080d1d8 	cmpnei	r2,zero,839
  80d17c:	0080d39c 	xori	r2,zero,846
  80d180:	0080d370 	cmpltui	r2,zero,845
  80d184:	0080d39c 	xori	r2,zero,846
  80d188:	0080d1d8 	cmpnei	r2,zero,839
  80d18c:	0080d1e4 	muli	r2,zero,839
  80d190:	0080d1e4 	muli	r2,zero,839
  80d194:	0080d370 	cmpltui	r2,zero,845
  80d198:	0080d1d8 	cmpnei	r2,zero,839
  80d19c:	0080d1c8 	cmpgei	r2,zero,839
  80d1a0:	0080d1c8 	cmpgei	r2,zero,839
  80d1a4:	0080d1c8 	cmpgei	r2,zero,839
  80d1a8:	0080d734 	movhi	r2,860
  80d1ac:	2404b03a 	or	r2,r4,r16
  80d1b0:	10006c1e 	bne	r2,zero,80d364 <__divdf3+0x2ec>
  80d1b4:	02400204 	movi	r9,8
  80d1b8:	0021883a 	mov	r16,zero
  80d1bc:	002b883a 	mov	r21,zero
  80d1c0:	01400084 	movi	r5,2
  80d1c4:	003fca06 	br	80d0f0 <__alt_data_end+0xfff0d0f0>
  80d1c8:	8023883a 	mov	r17,r16
  80d1cc:	a829883a 	mov	r20,r21
  80d1d0:	4039883a 	mov	fp,r8
  80d1d4:	280f883a 	mov	r7,r5
  80d1d8:	00800084 	movi	r2,2
  80d1dc:	3881601e 	bne	r7,r2,80d760 <__divdf3+0x6e8>
  80d1e0:	e027883a 	mov	r19,fp
  80d1e4:	9900004c 	andi	r4,r19,1
  80d1e8:	0081ffc4 	movi	r2,2047
  80d1ec:	0021883a 	mov	r16,zero
  80d1f0:	002b883a 	mov	r21,zero
  80d1f4:	1004953a 	slli	r2,r2,20
  80d1f8:	20c03fcc 	andi	r3,r4,255
  80d1fc:	01400434 	movhi	r5,16
  80d200:	297fffc4 	addi	r5,r5,-1
  80d204:	180697fa 	slli	r3,r3,31
  80d208:	8160703a 	and	r16,r16,r5
  80d20c:	80a0b03a 	or	r16,r16,r2
  80d210:	80c6b03a 	or	r3,r16,r3
  80d214:	a805883a 	mov	r2,r21
  80d218:	dfc00f17 	ldw	ra,60(sp)
  80d21c:	df000e17 	ldw	fp,56(sp)
  80d220:	ddc00d17 	ldw	r23,52(sp)
  80d224:	dd800c17 	ldw	r22,48(sp)
  80d228:	dd400b17 	ldw	r21,44(sp)
  80d22c:	dd000a17 	ldw	r20,40(sp)
  80d230:	dcc00917 	ldw	r19,36(sp)
  80d234:	dc800817 	ldw	r18,32(sp)
  80d238:	dc400717 	ldw	r17,28(sp)
  80d23c:	dc000617 	ldw	r16,24(sp)
  80d240:	dec01004 	addi	sp,sp,64
  80d244:	f800283a 	ret
  80d248:	2404b03a 	or	r2,r4,r16
  80d24c:	2023883a 	mov	r17,r4
  80d250:	10003f26 	beq	r2,zero,80d350 <__divdf3+0x2d8>
  80d254:	80015e26 	beq	r16,zero,80d7d0 <__divdf3+0x758>
  80d258:	8009883a 	mov	r4,r16
  80d25c:	d9800215 	stw	r6,8(sp)
  80d260:	d9c00515 	stw	r7,20(sp)
  80d264:	da000415 	stw	r8,16(sp)
  80d268:	080f21c0 	call	80f21c <__clzsi2>
  80d26c:	d9800217 	ldw	r6,8(sp)
  80d270:	d9c00517 	ldw	r7,20(sp)
  80d274:	da000417 	ldw	r8,16(sp)
  80d278:	113ffd44 	addi	r4,r2,-11
  80d27c:	00c00704 	movi	r3,28
  80d280:	19014f16 	blt	r3,r4,80d7c0 <__divdf3+0x748>
  80d284:	00c00744 	movi	r3,29
  80d288:	157ffe04 	addi	r21,r2,-8
  80d28c:	1907c83a 	sub	r3,r3,r4
  80d290:	8560983a 	sll	r16,r16,r21
  80d294:	88c6d83a 	srl	r3,r17,r3
  80d298:	8d6a983a 	sll	r21,r17,r21
  80d29c:	1c20b03a 	or	r16,r3,r16
  80d2a0:	1080fcc4 	addi	r2,r2,1011
  80d2a4:	00a5c83a 	sub	r18,zero,r2
  80d2a8:	0013883a 	mov	r9,zero
  80d2ac:	000b883a 	mov	r5,zero
  80d2b0:	003f8f06 	br	80d0f0 <__alt_data_end+0xfff0d0f0>
  80d2b4:	3444b03a 	or	r2,r6,r17
  80d2b8:	1000231e 	bne	r2,zero,80d348 <__divdf3+0x2d0>
  80d2bc:	0023883a 	mov	r17,zero
  80d2c0:	0029883a 	mov	r20,zero
  80d2c4:	01c00084 	movi	r7,2
  80d2c8:	003f9b06 	br	80d138 <__alt_data_end+0xfff0d138>
  80d2cc:	3444b03a 	or	r2,r6,r17
  80d2d0:	10001926 	beq	r2,zero,80d338 <__divdf3+0x2c0>
  80d2d4:	88014b26 	beq	r17,zero,80d804 <__divdf3+0x78c>
  80d2d8:	8809883a 	mov	r4,r17
  80d2dc:	d9400115 	stw	r5,4(sp)
  80d2e0:	d9800215 	stw	r6,8(sp)
  80d2e4:	da000415 	stw	r8,16(sp)
  80d2e8:	da400315 	stw	r9,12(sp)
  80d2ec:	080f21c0 	call	80f21c <__clzsi2>
  80d2f0:	d9400117 	ldw	r5,4(sp)
  80d2f4:	d9800217 	ldw	r6,8(sp)
  80d2f8:	da000417 	ldw	r8,16(sp)
  80d2fc:	da400317 	ldw	r9,12(sp)
  80d300:	113ffd44 	addi	r4,r2,-11
  80d304:	00c00704 	movi	r3,28
  80d308:	19013a16 	blt	r3,r4,80d7f4 <__divdf3+0x77c>
  80d30c:	00c00744 	movi	r3,29
  80d310:	153ffe04 	addi	r20,r2,-8
  80d314:	1907c83a 	sub	r3,r3,r4
  80d318:	8d22983a 	sll	r17,r17,r20
  80d31c:	30c6d83a 	srl	r3,r6,r3
  80d320:	3528983a 	sll	r20,r6,r20
  80d324:	1c62b03a 	or	r17,r3,r17
  80d328:	1080fcc4 	addi	r2,r2,1011
  80d32c:	0087c83a 	sub	r3,zero,r2
  80d330:	000f883a 	mov	r7,zero
  80d334:	003f8006 	br	80d138 <__alt_data_end+0xfff0d138>
  80d338:	0023883a 	mov	r17,zero
  80d33c:	0029883a 	mov	r20,zero
  80d340:	01c00044 	movi	r7,1
  80d344:	003f7c06 	br	80d138 <__alt_data_end+0xfff0d138>
  80d348:	01c000c4 	movi	r7,3
  80d34c:	003f7a06 	br	80d138 <__alt_data_end+0xfff0d138>
  80d350:	02400104 	movi	r9,4
  80d354:	0021883a 	mov	r16,zero
  80d358:	002b883a 	mov	r21,zero
  80d35c:	01400044 	movi	r5,1
  80d360:	003f6306 	br	80d0f0 <__alt_data_end+0xfff0d0f0>
  80d364:	02400304 	movi	r9,12
  80d368:	014000c4 	movi	r5,3
  80d36c:	003f6006 	br	80d0f0 <__alt_data_end+0xfff0d0f0>
  80d370:	04000434 	movhi	r16,16
  80d374:	0009883a 	mov	r4,zero
  80d378:	843fffc4 	addi	r16,r16,-1
  80d37c:	057fffc4 	movi	r21,-1
  80d380:	0081ffc4 	movi	r2,2047
  80d384:	003f9b06 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d388:	00c00044 	movi	r3,1
  80d38c:	1887c83a 	sub	r3,r3,r2
  80d390:	01000e04 	movi	r4,56
  80d394:	20c1530e 	bge	r4,r3,80d8e4 <__divdf3+0x86c>
  80d398:	9900004c 	andi	r4,r19,1
  80d39c:	0005883a 	mov	r2,zero
  80d3a0:	0021883a 	mov	r16,zero
  80d3a4:	002b883a 	mov	r21,zero
  80d3a8:	003f9206 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d3ac:	8c012e36 	bltu	r17,r16,80d868 <__divdf3+0x7f0>
  80d3b0:	84412c26 	beq	r16,r17,80d864 <__divdf3+0x7ec>
  80d3b4:	a82f883a 	mov	r23,r21
  80d3b8:	18ffffc4 	addi	r3,r3,-1
  80d3bc:	002b883a 	mov	r21,zero
  80d3c0:	a004d63a 	srli	r2,r20,24
  80d3c4:	8822923a 	slli	r17,r17,8
  80d3c8:	a028923a 	slli	r20,r20,8
  80d3cc:	8009883a 	mov	r4,r16
  80d3d0:	88acb03a 	or	r22,r17,r2
  80d3d4:	dd000015 	stw	r20,0(sp)
  80d3d8:	b028d43a 	srli	r20,r22,16
  80d3dc:	d8c00215 	stw	r3,8(sp)
  80d3e0:	b4bfffcc 	andi	r18,r22,65535
  80d3e4:	a00b883a 	mov	r5,r20
  80d3e8:	080f3780 	call	80f378 <__udivsi3>
  80d3ec:	100b883a 	mov	r5,r2
  80d3f0:	9009883a 	mov	r4,r18
  80d3f4:	1023883a 	mov	r17,r2
  80d3f8:	080b2480 	call	80b248 <__mulsi3>
  80d3fc:	8009883a 	mov	r4,r16
  80d400:	a00b883a 	mov	r5,r20
  80d404:	1039883a 	mov	fp,r2
  80d408:	080f3dc0 	call	80f3dc <__umodsi3>
  80d40c:	1004943a 	slli	r2,r2,16
  80d410:	b808d43a 	srli	r4,r23,16
  80d414:	d8c00217 	ldw	r3,8(sp)
  80d418:	2084b03a 	or	r2,r4,r2
  80d41c:	1700062e 	bgeu	r2,fp,80d438 <__divdf3+0x3c0>
  80d420:	1585883a 	add	r2,r2,r22
  80d424:	893fffc4 	addi	r4,r17,-1
  80d428:	15811d36 	bltu	r2,r22,80d8a0 <__divdf3+0x828>
  80d42c:	17011c2e 	bgeu	r2,fp,80d8a0 <__divdf3+0x828>
  80d430:	8c7fff84 	addi	r17,r17,-2
  80d434:	1585883a 	add	r2,r2,r22
  80d438:	1739c83a 	sub	fp,r2,fp
  80d43c:	a00b883a 	mov	r5,r20
  80d440:	e009883a 	mov	r4,fp
  80d444:	d8c00215 	stw	r3,8(sp)
  80d448:	080f3780 	call	80f378 <__udivsi3>
  80d44c:	100b883a 	mov	r5,r2
  80d450:	9009883a 	mov	r4,r18
  80d454:	1021883a 	mov	r16,r2
  80d458:	080b2480 	call	80b248 <__mulsi3>
  80d45c:	a00b883a 	mov	r5,r20
  80d460:	e009883a 	mov	r4,fp
  80d464:	d8800415 	stw	r2,16(sp)
  80d468:	080f3dc0 	call	80f3dc <__umodsi3>
  80d46c:	1004943a 	slli	r2,r2,16
  80d470:	da000417 	ldw	r8,16(sp)
  80d474:	bdffffcc 	andi	r23,r23,65535
  80d478:	b884b03a 	or	r2,r23,r2
  80d47c:	d8c00217 	ldw	r3,8(sp)
  80d480:	1200062e 	bgeu	r2,r8,80d49c <__divdf3+0x424>
  80d484:	1585883a 	add	r2,r2,r22
  80d488:	813fffc4 	addi	r4,r16,-1
  80d48c:	15810236 	bltu	r2,r22,80d898 <__divdf3+0x820>
  80d490:	1201012e 	bgeu	r2,r8,80d898 <__divdf3+0x820>
  80d494:	843fff84 	addi	r16,r16,-2
  80d498:	1585883a 	add	r2,r2,r22
  80d49c:	8822943a 	slli	r17,r17,16
  80d4a0:	d9800017 	ldw	r6,0(sp)
  80d4a4:	1211c83a 	sub	r8,r2,r8
  80d4a8:	8c22b03a 	or	r17,r17,r16
  80d4ac:	373fffcc 	andi	fp,r6,65535
  80d4b0:	8abfffcc 	andi	r10,r17,65535
  80d4b4:	8820d43a 	srli	r16,r17,16
  80d4b8:	5009883a 	mov	r4,r10
  80d4bc:	e00b883a 	mov	r5,fp
  80d4c0:	302ed43a 	srli	r23,r6,16
  80d4c4:	d8c00215 	stw	r3,8(sp)
  80d4c8:	da000415 	stw	r8,16(sp)
  80d4cc:	da800115 	stw	r10,4(sp)
  80d4d0:	080b2480 	call	80b248 <__mulsi3>
  80d4d4:	800b883a 	mov	r5,r16
  80d4d8:	e009883a 	mov	r4,fp
  80d4dc:	d8800515 	stw	r2,20(sp)
  80d4e0:	080b2480 	call	80b248 <__mulsi3>
  80d4e4:	8009883a 	mov	r4,r16
  80d4e8:	b80b883a 	mov	r5,r23
  80d4ec:	d8800315 	stw	r2,12(sp)
  80d4f0:	080b2480 	call	80b248 <__mulsi3>
  80d4f4:	da800117 	ldw	r10,4(sp)
  80d4f8:	b80b883a 	mov	r5,r23
  80d4fc:	1021883a 	mov	r16,r2
  80d500:	5009883a 	mov	r4,r10
  80d504:	080b2480 	call	80b248 <__mulsi3>
  80d508:	d9c00517 	ldw	r7,20(sp)
  80d50c:	da400317 	ldw	r9,12(sp)
  80d510:	d8c00217 	ldw	r3,8(sp)
  80d514:	3808d43a 	srli	r4,r7,16
  80d518:	1245883a 	add	r2,r2,r9
  80d51c:	da000417 	ldw	r8,16(sp)
  80d520:	2085883a 	add	r2,r4,r2
  80d524:	1240022e 	bgeu	r2,r9,80d530 <__divdf3+0x4b8>
  80d528:	01000074 	movhi	r4,1
  80d52c:	8121883a 	add	r16,r16,r4
  80d530:	1008d43a 	srli	r4,r2,16
  80d534:	1004943a 	slli	r2,r2,16
  80d538:	39ffffcc 	andi	r7,r7,65535
  80d53c:	2409883a 	add	r4,r4,r16
  80d540:	11c5883a 	add	r2,r2,r7
  80d544:	4100bb36 	bltu	r8,r4,80d834 <__divdf3+0x7bc>
  80d548:	4100d726 	beq	r8,r4,80d8a8 <__divdf3+0x830>
  80d54c:	4109c83a 	sub	r4,r8,r4
  80d550:	a8a1c83a 	sub	r16,r21,r2
  80d554:	ac2b803a 	cmpltu	r21,r21,r16
  80d558:	256bc83a 	sub	r21,r4,r21
  80d55c:	b540d926 	beq	r22,r21,80d8c4 <__divdf3+0x84c>
  80d560:	a00b883a 	mov	r5,r20
  80d564:	a809883a 	mov	r4,r21
  80d568:	d8c00215 	stw	r3,8(sp)
  80d56c:	080f3780 	call	80f378 <__udivsi3>
  80d570:	100b883a 	mov	r5,r2
  80d574:	9009883a 	mov	r4,r18
  80d578:	d8800515 	stw	r2,20(sp)
  80d57c:	080b2480 	call	80b248 <__mulsi3>
  80d580:	a809883a 	mov	r4,r21
  80d584:	a00b883a 	mov	r5,r20
  80d588:	d8800415 	stw	r2,16(sp)
  80d58c:	080f3dc0 	call	80f3dc <__umodsi3>
  80d590:	1004943a 	slli	r2,r2,16
  80d594:	8008d43a 	srli	r4,r16,16
  80d598:	da000417 	ldw	r8,16(sp)
  80d59c:	d8c00217 	ldw	r3,8(sp)
  80d5a0:	2084b03a 	or	r2,r4,r2
  80d5a4:	d9c00517 	ldw	r7,20(sp)
  80d5a8:	1200062e 	bgeu	r2,r8,80d5c4 <__divdf3+0x54c>
  80d5ac:	1585883a 	add	r2,r2,r22
  80d5b0:	393fffc4 	addi	r4,r7,-1
  80d5b4:	1580c536 	bltu	r2,r22,80d8cc <__divdf3+0x854>
  80d5b8:	1200c42e 	bgeu	r2,r8,80d8cc <__divdf3+0x854>
  80d5bc:	39ffff84 	addi	r7,r7,-2
  80d5c0:	1585883a 	add	r2,r2,r22
  80d5c4:	122bc83a 	sub	r21,r2,r8
  80d5c8:	a00b883a 	mov	r5,r20
  80d5cc:	a809883a 	mov	r4,r21
  80d5d0:	d8c00215 	stw	r3,8(sp)
  80d5d4:	d9c00515 	stw	r7,20(sp)
  80d5d8:	080f3780 	call	80f378 <__udivsi3>
  80d5dc:	9009883a 	mov	r4,r18
  80d5e0:	100b883a 	mov	r5,r2
  80d5e4:	d8800415 	stw	r2,16(sp)
  80d5e8:	080b2480 	call	80b248 <__mulsi3>
  80d5ec:	a809883a 	mov	r4,r21
  80d5f0:	a00b883a 	mov	r5,r20
  80d5f4:	1025883a 	mov	r18,r2
  80d5f8:	080f3dc0 	call	80f3dc <__umodsi3>
  80d5fc:	1004943a 	slli	r2,r2,16
  80d600:	813fffcc 	andi	r4,r16,65535
  80d604:	d8c00217 	ldw	r3,8(sp)
  80d608:	20a0b03a 	or	r16,r4,r2
  80d60c:	d9c00517 	ldw	r7,20(sp)
  80d610:	da000417 	ldw	r8,16(sp)
  80d614:	8480062e 	bgeu	r16,r18,80d630 <__divdf3+0x5b8>
  80d618:	85a1883a 	add	r16,r16,r22
  80d61c:	40bfffc4 	addi	r2,r8,-1
  80d620:	8580ac36 	bltu	r16,r22,80d8d4 <__divdf3+0x85c>
  80d624:	8480ab2e 	bgeu	r16,r18,80d8d4 <__divdf3+0x85c>
  80d628:	423fff84 	addi	r8,r8,-2
  80d62c:	85a1883a 	add	r16,r16,r22
  80d630:	3804943a 	slli	r2,r7,16
  80d634:	84a1c83a 	sub	r16,r16,r18
  80d638:	e009883a 	mov	r4,fp
  80d63c:	1228b03a 	or	r20,r2,r8
  80d640:	a1ffffcc 	andi	r7,r20,65535
  80d644:	a024d43a 	srli	r18,r20,16
  80d648:	380b883a 	mov	r5,r7
  80d64c:	d8c00215 	stw	r3,8(sp)
  80d650:	d9c00515 	stw	r7,20(sp)
  80d654:	080b2480 	call	80b248 <__mulsi3>
  80d658:	900b883a 	mov	r5,r18
  80d65c:	e009883a 	mov	r4,fp
  80d660:	102b883a 	mov	r21,r2
  80d664:	080b2480 	call	80b248 <__mulsi3>
  80d668:	900b883a 	mov	r5,r18
  80d66c:	b809883a 	mov	r4,r23
  80d670:	1039883a 	mov	fp,r2
  80d674:	080b2480 	call	80b248 <__mulsi3>
  80d678:	d9c00517 	ldw	r7,20(sp)
  80d67c:	b80b883a 	mov	r5,r23
  80d680:	1025883a 	mov	r18,r2
  80d684:	3809883a 	mov	r4,r7
  80d688:	080b2480 	call	80b248 <__mulsi3>
  80d68c:	a808d43a 	srli	r4,r21,16
  80d690:	1705883a 	add	r2,r2,fp
  80d694:	d8c00217 	ldw	r3,8(sp)
  80d698:	2085883a 	add	r2,r4,r2
  80d69c:	1700022e 	bgeu	r2,fp,80d6a8 <__divdf3+0x630>
  80d6a0:	01000074 	movhi	r4,1
  80d6a4:	9125883a 	add	r18,r18,r4
  80d6a8:	1008d43a 	srli	r4,r2,16
  80d6ac:	1004943a 	slli	r2,r2,16
  80d6b0:	ad7fffcc 	andi	r21,r21,65535
  80d6b4:	2489883a 	add	r4,r4,r18
  80d6b8:	1545883a 	add	r2,r2,r21
  80d6bc:	81003836 	bltu	r16,r4,80d7a0 <__divdf3+0x728>
  80d6c0:	81003626 	beq	r16,r4,80d79c <__divdf3+0x724>
  80d6c4:	a5000054 	ori	r20,r20,1
  80d6c8:	1880ffc4 	addi	r2,r3,1023
  80d6cc:	00bf2e0e 	bge	zero,r2,80d388 <__alt_data_end+0xfff0d388>
  80d6d0:	a10001cc 	andi	r4,r20,7
  80d6d4:	20000726 	beq	r4,zero,80d6f4 <__divdf3+0x67c>
  80d6d8:	a10003cc 	andi	r4,r20,15
  80d6dc:	01400104 	movi	r5,4
  80d6e0:	21400426 	beq	r4,r5,80d6f4 <__divdf3+0x67c>
  80d6e4:	a149883a 	add	r4,r20,r5
  80d6e8:	2529803a 	cmpltu	r20,r4,r20
  80d6ec:	8d23883a 	add	r17,r17,r20
  80d6f0:	2029883a 	mov	r20,r4
  80d6f4:	8900402c 	andhi	r4,r17,256
  80d6f8:	20000426 	beq	r4,zero,80d70c <__divdf3+0x694>
  80d6fc:	18810004 	addi	r2,r3,1024
  80d700:	00ffc034 	movhi	r3,65280
  80d704:	18ffffc4 	addi	r3,r3,-1
  80d708:	88e2703a 	and	r17,r17,r3
  80d70c:	00c1ff84 	movi	r3,2046
  80d710:	18beb416 	blt	r3,r2,80d1e4 <__alt_data_end+0xfff0d1e4>
  80d714:	a028d0fa 	srli	r20,r20,3
  80d718:	882a977a 	slli	r21,r17,29
  80d71c:	8820927a 	slli	r16,r17,9
  80d720:	1081ffcc 	andi	r2,r2,2047
  80d724:	ad2ab03a 	or	r21,r21,r20
  80d728:	8020d33a 	srli	r16,r16,12
  80d72c:	9900004c 	andi	r4,r19,1
  80d730:	003eb006 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d734:	8080022c 	andhi	r2,r16,8
  80d738:	10001226 	beq	r2,zero,80d784 <__divdf3+0x70c>
  80d73c:	8880022c 	andhi	r2,r17,8
  80d740:	1000101e 	bne	r2,zero,80d784 <__divdf3+0x70c>
  80d744:	00800434 	movhi	r2,16
  80d748:	8c000234 	orhi	r16,r17,8
  80d74c:	10bfffc4 	addi	r2,r2,-1
  80d750:	b809883a 	mov	r4,r23
  80d754:	80a0703a 	and	r16,r16,r2
  80d758:	a02b883a 	mov	r21,r20
  80d75c:	003f0806 	br	80d380 <__alt_data_end+0xfff0d380>
  80d760:	008000c4 	movi	r2,3
  80d764:	3880b126 	beq	r7,r2,80da2c <__divdf3+0x9b4>
  80d768:	00800044 	movi	r2,1
  80d76c:	38805b1e 	bne	r7,r2,80d8dc <__divdf3+0x864>
  80d770:	e009883a 	mov	r4,fp
  80d774:	0005883a 	mov	r2,zero
  80d778:	0021883a 	mov	r16,zero
  80d77c:	002b883a 	mov	r21,zero
  80d780:	003e9c06 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d784:	00800434 	movhi	r2,16
  80d788:	84000234 	orhi	r16,r16,8
  80d78c:	10bfffc4 	addi	r2,r2,-1
  80d790:	b009883a 	mov	r4,r22
  80d794:	80a0703a 	and	r16,r16,r2
  80d798:	003ef906 	br	80d380 <__alt_data_end+0xfff0d380>
  80d79c:	103fca26 	beq	r2,zero,80d6c8 <__alt_data_end+0xfff0d6c8>
  80d7a0:	b421883a 	add	r16,r22,r16
  80d7a4:	a17fffc4 	addi	r5,r20,-1
  80d7a8:	8580422e 	bgeu	r16,r22,80d8b4 <__divdf3+0x83c>
  80d7ac:	2829883a 	mov	r20,r5
  80d7b0:	813fc41e 	bne	r16,r4,80d6c4 <__alt_data_end+0xfff0d6c4>
  80d7b4:	d9800017 	ldw	r6,0(sp)
  80d7b8:	30bfc21e 	bne	r6,r2,80d6c4 <__alt_data_end+0xfff0d6c4>
  80d7bc:	003fc206 	br	80d6c8 <__alt_data_end+0xfff0d6c8>
  80d7c0:	143ff604 	addi	r16,r2,-40
  80d7c4:	8c20983a 	sll	r16,r17,r16
  80d7c8:	002b883a 	mov	r21,zero
  80d7cc:	003eb406 	br	80d2a0 <__alt_data_end+0xfff0d2a0>
  80d7d0:	d9800215 	stw	r6,8(sp)
  80d7d4:	d9c00515 	stw	r7,20(sp)
  80d7d8:	da000415 	stw	r8,16(sp)
  80d7dc:	080f21c0 	call	80f21c <__clzsi2>
  80d7e0:	10800804 	addi	r2,r2,32
  80d7e4:	da000417 	ldw	r8,16(sp)
  80d7e8:	d9c00517 	ldw	r7,20(sp)
  80d7ec:	d9800217 	ldw	r6,8(sp)
  80d7f0:	003ea106 	br	80d278 <__alt_data_end+0xfff0d278>
  80d7f4:	147ff604 	addi	r17,r2,-40
  80d7f8:	3462983a 	sll	r17,r6,r17
  80d7fc:	0029883a 	mov	r20,zero
  80d800:	003ec906 	br	80d328 <__alt_data_end+0xfff0d328>
  80d804:	3009883a 	mov	r4,r6
  80d808:	d9400115 	stw	r5,4(sp)
  80d80c:	d9800215 	stw	r6,8(sp)
  80d810:	da000415 	stw	r8,16(sp)
  80d814:	da400315 	stw	r9,12(sp)
  80d818:	080f21c0 	call	80f21c <__clzsi2>
  80d81c:	10800804 	addi	r2,r2,32
  80d820:	da400317 	ldw	r9,12(sp)
  80d824:	da000417 	ldw	r8,16(sp)
  80d828:	d9800217 	ldw	r6,8(sp)
  80d82c:	d9400117 	ldw	r5,4(sp)
  80d830:	003eb306 	br	80d300 <__alt_data_end+0xfff0d300>
  80d834:	d9800017 	ldw	r6,0(sp)
  80d838:	a9ab883a 	add	r21,r21,r6
  80d83c:	a98b803a 	cmpltu	r5,r21,r6
  80d840:	2d8b883a 	add	r5,r5,r22
  80d844:	2a11883a 	add	r8,r5,r8
  80d848:	897fffc4 	addi	r5,r17,-1
  80d84c:	b2000c2e 	bgeu	r22,r8,80d880 <__divdf3+0x808>
  80d850:	41003f36 	bltu	r8,r4,80d950 <__divdf3+0x8d8>
  80d854:	22006c26 	beq	r4,r8,80da08 <__divdf3+0x990>
  80d858:	4109c83a 	sub	r4,r8,r4
  80d85c:	2823883a 	mov	r17,r5
  80d860:	003f3b06 	br	80d550 <__alt_data_end+0xfff0d550>
  80d864:	ad3ed336 	bltu	r21,r20,80d3b4 <__alt_data_end+0xfff0d3b4>
  80d868:	a804d07a 	srli	r2,r21,1
  80d86c:	802e97fa 	slli	r23,r16,31
  80d870:	a82a97fa 	slli	r21,r21,31
  80d874:	8020d07a 	srli	r16,r16,1
  80d878:	b8aeb03a 	or	r23,r23,r2
  80d87c:	003ed006 	br	80d3c0 <__alt_data_end+0xfff0d3c0>
  80d880:	b23ff51e 	bne	r22,r8,80d858 <__alt_data_end+0xfff0d858>
  80d884:	d9800017 	ldw	r6,0(sp)
  80d888:	a9bff12e 	bgeu	r21,r6,80d850 <__alt_data_end+0xfff0d850>
  80d88c:	b109c83a 	sub	r4,r22,r4
  80d890:	2823883a 	mov	r17,r5
  80d894:	003f2e06 	br	80d550 <__alt_data_end+0xfff0d550>
  80d898:	2021883a 	mov	r16,r4
  80d89c:	003eff06 	br	80d49c <__alt_data_end+0xfff0d49c>
  80d8a0:	2023883a 	mov	r17,r4
  80d8a4:	003ee406 	br	80d438 <__alt_data_end+0xfff0d438>
  80d8a8:	a8bfe236 	bltu	r21,r2,80d834 <__alt_data_end+0xfff0d834>
  80d8ac:	0009883a 	mov	r4,zero
  80d8b0:	003f2706 	br	80d550 <__alt_data_end+0xfff0d550>
  80d8b4:	81002d36 	bltu	r16,r4,80d96c <__divdf3+0x8f4>
  80d8b8:	24005626 	beq	r4,r16,80da14 <__divdf3+0x99c>
  80d8bc:	2829883a 	mov	r20,r5
  80d8c0:	003f8006 	br	80d6c4 <__alt_data_end+0xfff0d6c4>
  80d8c4:	053fffc4 	movi	r20,-1
  80d8c8:	003f7f06 	br	80d6c8 <__alt_data_end+0xfff0d6c8>
  80d8cc:	200f883a 	mov	r7,r4
  80d8d0:	003f3c06 	br	80d5c4 <__alt_data_end+0xfff0d5c4>
  80d8d4:	1011883a 	mov	r8,r2
  80d8d8:	003f5506 	br	80d630 <__alt_data_end+0xfff0d630>
  80d8dc:	e027883a 	mov	r19,fp
  80d8e0:	003f7906 	br	80d6c8 <__alt_data_end+0xfff0d6c8>
  80d8e4:	010007c4 	movi	r4,31
  80d8e8:	20c02816 	blt	r4,r3,80d98c <__divdf3+0x914>
  80d8ec:	00800804 	movi	r2,32
  80d8f0:	10c5c83a 	sub	r2,r2,r3
  80d8f4:	888a983a 	sll	r5,r17,r2
  80d8f8:	a0c8d83a 	srl	r4,r20,r3
  80d8fc:	a084983a 	sll	r2,r20,r2
  80d900:	88e2d83a 	srl	r17,r17,r3
  80d904:	2906b03a 	or	r3,r5,r4
  80d908:	1004c03a 	cmpne	r2,r2,zero
  80d90c:	1886b03a 	or	r3,r3,r2
  80d910:	188001cc 	andi	r2,r3,7
  80d914:	10000726 	beq	r2,zero,80d934 <__divdf3+0x8bc>
  80d918:	188003cc 	andi	r2,r3,15
  80d91c:	01000104 	movi	r4,4
  80d920:	11000426 	beq	r2,r4,80d934 <__divdf3+0x8bc>
  80d924:	1805883a 	mov	r2,r3
  80d928:	10c00104 	addi	r3,r2,4
  80d92c:	1885803a 	cmpltu	r2,r3,r2
  80d930:	88a3883a 	add	r17,r17,r2
  80d934:	8880202c 	andhi	r2,r17,128
  80d938:	10002926 	beq	r2,zero,80d9e0 <__divdf3+0x968>
  80d93c:	9900004c 	andi	r4,r19,1
  80d940:	00800044 	movi	r2,1
  80d944:	0021883a 	mov	r16,zero
  80d948:	002b883a 	mov	r21,zero
  80d94c:	003e2906 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d950:	d9800017 	ldw	r6,0(sp)
  80d954:	8c7fff84 	addi	r17,r17,-2
  80d958:	a9ab883a 	add	r21,r21,r6
  80d95c:	a98b803a 	cmpltu	r5,r21,r6
  80d960:	2d8b883a 	add	r5,r5,r22
  80d964:	2a11883a 	add	r8,r5,r8
  80d968:	003ef806 	br	80d54c <__alt_data_end+0xfff0d54c>
  80d96c:	d9800017 	ldw	r6,0(sp)
  80d970:	318f883a 	add	r7,r6,r6
  80d974:	398b803a 	cmpltu	r5,r7,r6
  80d978:	2d8d883a 	add	r6,r5,r22
  80d97c:	81a1883a 	add	r16,r16,r6
  80d980:	a17fff84 	addi	r5,r20,-2
  80d984:	d9c00015 	stw	r7,0(sp)
  80d988:	003f8806 	br	80d7ac <__alt_data_end+0xfff0d7ac>
  80d98c:	013ff844 	movi	r4,-31
  80d990:	2085c83a 	sub	r2,r4,r2
  80d994:	8888d83a 	srl	r4,r17,r2
  80d998:	00800804 	movi	r2,32
  80d99c:	18802126 	beq	r3,r2,80da24 <__divdf3+0x9ac>
  80d9a0:	04001004 	movi	r16,64
  80d9a4:	80c7c83a 	sub	r3,r16,r3
  80d9a8:	88e0983a 	sll	r16,r17,r3
  80d9ac:	8504b03a 	or	r2,r16,r20
  80d9b0:	1004c03a 	cmpne	r2,r2,zero
  80d9b4:	2084b03a 	or	r2,r4,r2
  80d9b8:	144001cc 	andi	r17,r2,7
  80d9bc:	88000d1e 	bne	r17,zero,80d9f4 <__divdf3+0x97c>
  80d9c0:	0021883a 	mov	r16,zero
  80d9c4:	102ad0fa 	srli	r21,r2,3
  80d9c8:	9900004c 	andi	r4,r19,1
  80d9cc:	0005883a 	mov	r2,zero
  80d9d0:	ac6ab03a 	or	r21,r21,r17
  80d9d4:	003e0706 	br	80d1f4 <__alt_data_end+0xfff0d1f4>
  80d9d8:	1007883a 	mov	r3,r2
  80d9dc:	0023883a 	mov	r17,zero
  80d9e0:	8820927a 	slli	r16,r17,9
  80d9e4:	1805883a 	mov	r2,r3
  80d9e8:	8822977a 	slli	r17,r17,29
  80d9ec:	8020d33a 	srli	r16,r16,12
  80d9f0:	003ff406 	br	80d9c4 <__alt_data_end+0xfff0d9c4>
  80d9f4:	10c003cc 	andi	r3,r2,15
  80d9f8:	01000104 	movi	r4,4
  80d9fc:	193ff626 	beq	r3,r4,80d9d8 <__alt_data_end+0xfff0d9d8>
  80da00:	0023883a 	mov	r17,zero
  80da04:	003fc806 	br	80d928 <__alt_data_end+0xfff0d928>
  80da08:	a8bfd136 	bltu	r21,r2,80d950 <__alt_data_end+0xfff0d950>
  80da0c:	2823883a 	mov	r17,r5
  80da10:	003fa606 	br	80d8ac <__alt_data_end+0xfff0d8ac>
  80da14:	d9800017 	ldw	r6,0(sp)
  80da18:	30bfd436 	bltu	r6,r2,80d96c <__alt_data_end+0xfff0d96c>
  80da1c:	2829883a 	mov	r20,r5
  80da20:	003f6406 	br	80d7b4 <__alt_data_end+0xfff0d7b4>
  80da24:	0021883a 	mov	r16,zero
  80da28:	003fe006 	br	80d9ac <__alt_data_end+0xfff0d9ac>
  80da2c:	00800434 	movhi	r2,16
  80da30:	8c000234 	orhi	r16,r17,8
  80da34:	10bfffc4 	addi	r2,r2,-1
  80da38:	e009883a 	mov	r4,fp
  80da3c:	80a0703a 	and	r16,r16,r2
  80da40:	a02b883a 	mov	r21,r20
  80da44:	003e4e06 	br	80d380 <__alt_data_end+0xfff0d380>

0080da48 <__eqdf2>:
  80da48:	2804d53a 	srli	r2,r5,20
  80da4c:	3806d53a 	srli	r3,r7,20
  80da50:	02000434 	movhi	r8,16
  80da54:	423fffc4 	addi	r8,r8,-1
  80da58:	1081ffcc 	andi	r2,r2,2047
  80da5c:	0281ffc4 	movi	r10,2047
  80da60:	2a12703a 	and	r9,r5,r8
  80da64:	18c1ffcc 	andi	r3,r3,2047
  80da68:	3a10703a 	and	r8,r7,r8
  80da6c:	280ad7fa 	srli	r5,r5,31
  80da70:	380ed7fa 	srli	r7,r7,31
  80da74:	12801026 	beq	r2,r10,80dab8 <__eqdf2+0x70>
  80da78:	0281ffc4 	movi	r10,2047
  80da7c:	1a800a26 	beq	r3,r10,80daa8 <__eqdf2+0x60>
  80da80:	10c00226 	beq	r2,r3,80da8c <__eqdf2+0x44>
  80da84:	00800044 	movi	r2,1
  80da88:	f800283a 	ret
  80da8c:	4a3ffd1e 	bne	r9,r8,80da84 <__alt_data_end+0xfff0da84>
  80da90:	21bffc1e 	bne	r4,r6,80da84 <__alt_data_end+0xfff0da84>
  80da94:	29c00c26 	beq	r5,r7,80dac8 <__eqdf2+0x80>
  80da98:	103ffa1e 	bne	r2,zero,80da84 <__alt_data_end+0xfff0da84>
  80da9c:	2244b03a 	or	r2,r4,r9
  80daa0:	1004c03a 	cmpne	r2,r2,zero
  80daa4:	f800283a 	ret
  80daa8:	3214b03a 	or	r10,r6,r8
  80daac:	503ff426 	beq	r10,zero,80da80 <__alt_data_end+0xfff0da80>
  80dab0:	00800044 	movi	r2,1
  80dab4:	f800283a 	ret
  80dab8:	2254b03a 	or	r10,r4,r9
  80dabc:	503fee26 	beq	r10,zero,80da78 <__alt_data_end+0xfff0da78>
  80dac0:	00800044 	movi	r2,1
  80dac4:	f800283a 	ret
  80dac8:	0005883a 	mov	r2,zero
  80dacc:	f800283a 	ret

0080dad0 <__gedf2>:
  80dad0:	2804d53a 	srli	r2,r5,20
  80dad4:	3806d53a 	srli	r3,r7,20
  80dad8:	02000434 	movhi	r8,16
  80dadc:	423fffc4 	addi	r8,r8,-1
  80dae0:	1081ffcc 	andi	r2,r2,2047
  80dae4:	0241ffc4 	movi	r9,2047
  80dae8:	2a14703a 	and	r10,r5,r8
  80daec:	18c1ffcc 	andi	r3,r3,2047
  80daf0:	3a10703a 	and	r8,r7,r8
  80daf4:	280ad7fa 	srli	r5,r5,31
  80daf8:	380ed7fa 	srli	r7,r7,31
  80dafc:	12401d26 	beq	r2,r9,80db74 <__gedf2+0xa4>
  80db00:	0241ffc4 	movi	r9,2047
  80db04:	1a401226 	beq	r3,r9,80db50 <__gedf2+0x80>
  80db08:	1000081e 	bne	r2,zero,80db2c <__gedf2+0x5c>
  80db0c:	2296b03a 	or	r11,r4,r10
  80db10:	5813003a 	cmpeq	r9,r11,zero
  80db14:	1800091e 	bne	r3,zero,80db3c <__gedf2+0x6c>
  80db18:	3218b03a 	or	r12,r6,r8
  80db1c:	6000071e 	bne	r12,zero,80db3c <__gedf2+0x6c>
  80db20:	0005883a 	mov	r2,zero
  80db24:	5800101e 	bne	r11,zero,80db68 <__gedf2+0x98>
  80db28:	f800283a 	ret
  80db2c:	18000c1e 	bne	r3,zero,80db60 <__gedf2+0x90>
  80db30:	3212b03a 	or	r9,r6,r8
  80db34:	48000c26 	beq	r9,zero,80db68 <__gedf2+0x98>
  80db38:	0013883a 	mov	r9,zero
  80db3c:	39c03fcc 	andi	r7,r7,255
  80db40:	48000826 	beq	r9,zero,80db64 <__gedf2+0x94>
  80db44:	38000926 	beq	r7,zero,80db6c <__gedf2+0x9c>
  80db48:	00800044 	movi	r2,1
  80db4c:	f800283a 	ret
  80db50:	3212b03a 	or	r9,r6,r8
  80db54:	483fec26 	beq	r9,zero,80db08 <__alt_data_end+0xfff0db08>
  80db58:	00bfff84 	movi	r2,-2
  80db5c:	f800283a 	ret
  80db60:	39c03fcc 	andi	r7,r7,255
  80db64:	29c00626 	beq	r5,r7,80db80 <__gedf2+0xb0>
  80db68:	283ff726 	beq	r5,zero,80db48 <__alt_data_end+0xfff0db48>
  80db6c:	00bfffc4 	movi	r2,-1
  80db70:	f800283a 	ret
  80db74:	2292b03a 	or	r9,r4,r10
  80db78:	483fe126 	beq	r9,zero,80db00 <__alt_data_end+0xfff0db00>
  80db7c:	003ff606 	br	80db58 <__alt_data_end+0xfff0db58>
  80db80:	18bff916 	blt	r3,r2,80db68 <__alt_data_end+0xfff0db68>
  80db84:	10c00316 	blt	r2,r3,80db94 <__gedf2+0xc4>
  80db88:	42bff736 	bltu	r8,r10,80db68 <__alt_data_end+0xfff0db68>
  80db8c:	52000326 	beq	r10,r8,80db9c <__gedf2+0xcc>
  80db90:	5200042e 	bgeu	r10,r8,80dba4 <__gedf2+0xd4>
  80db94:	283fec1e 	bne	r5,zero,80db48 <__alt_data_end+0xfff0db48>
  80db98:	003ff406 	br	80db6c <__alt_data_end+0xfff0db6c>
  80db9c:	313ff236 	bltu	r6,r4,80db68 <__alt_data_end+0xfff0db68>
  80dba0:	21bffc36 	bltu	r4,r6,80db94 <__alt_data_end+0xfff0db94>
  80dba4:	0005883a 	mov	r2,zero
  80dba8:	f800283a 	ret

0080dbac <__ledf2>:
  80dbac:	2804d53a 	srli	r2,r5,20
  80dbb0:	3810d53a 	srli	r8,r7,20
  80dbb4:	00c00434 	movhi	r3,16
  80dbb8:	18ffffc4 	addi	r3,r3,-1
  80dbbc:	1081ffcc 	andi	r2,r2,2047
  80dbc0:	0241ffc4 	movi	r9,2047
  80dbc4:	28d4703a 	and	r10,r5,r3
  80dbc8:	4201ffcc 	andi	r8,r8,2047
  80dbcc:	38c6703a 	and	r3,r7,r3
  80dbd0:	280ad7fa 	srli	r5,r5,31
  80dbd4:	380ed7fa 	srli	r7,r7,31
  80dbd8:	12401f26 	beq	r2,r9,80dc58 <__ledf2+0xac>
  80dbdc:	0241ffc4 	movi	r9,2047
  80dbe0:	42401426 	beq	r8,r9,80dc34 <__ledf2+0x88>
  80dbe4:	1000091e 	bne	r2,zero,80dc0c <__ledf2+0x60>
  80dbe8:	2296b03a 	or	r11,r4,r10
  80dbec:	5813003a 	cmpeq	r9,r11,zero
  80dbf0:	29403fcc 	andi	r5,r5,255
  80dbf4:	40000a1e 	bne	r8,zero,80dc20 <__ledf2+0x74>
  80dbf8:	30d8b03a 	or	r12,r6,r3
  80dbfc:	6000081e 	bne	r12,zero,80dc20 <__ledf2+0x74>
  80dc00:	0005883a 	mov	r2,zero
  80dc04:	5800111e 	bne	r11,zero,80dc4c <__ledf2+0xa0>
  80dc08:	f800283a 	ret
  80dc0c:	29403fcc 	andi	r5,r5,255
  80dc10:	40000c1e 	bne	r8,zero,80dc44 <__ledf2+0x98>
  80dc14:	30d2b03a 	or	r9,r6,r3
  80dc18:	48000c26 	beq	r9,zero,80dc4c <__ledf2+0xa0>
  80dc1c:	0013883a 	mov	r9,zero
  80dc20:	39c03fcc 	andi	r7,r7,255
  80dc24:	48000826 	beq	r9,zero,80dc48 <__ledf2+0x9c>
  80dc28:	38001126 	beq	r7,zero,80dc70 <__ledf2+0xc4>
  80dc2c:	00800044 	movi	r2,1
  80dc30:	f800283a 	ret
  80dc34:	30d2b03a 	or	r9,r6,r3
  80dc38:	483fea26 	beq	r9,zero,80dbe4 <__alt_data_end+0xfff0dbe4>
  80dc3c:	00800084 	movi	r2,2
  80dc40:	f800283a 	ret
  80dc44:	39c03fcc 	andi	r7,r7,255
  80dc48:	39400726 	beq	r7,r5,80dc68 <__ledf2+0xbc>
  80dc4c:	2800081e 	bne	r5,zero,80dc70 <__ledf2+0xc4>
  80dc50:	00800044 	movi	r2,1
  80dc54:	f800283a 	ret
  80dc58:	2292b03a 	or	r9,r4,r10
  80dc5c:	483fdf26 	beq	r9,zero,80dbdc <__alt_data_end+0xfff0dbdc>
  80dc60:	00800084 	movi	r2,2
  80dc64:	f800283a 	ret
  80dc68:	4080030e 	bge	r8,r2,80dc78 <__ledf2+0xcc>
  80dc6c:	383fef26 	beq	r7,zero,80dc2c <__alt_data_end+0xfff0dc2c>
  80dc70:	00bfffc4 	movi	r2,-1
  80dc74:	f800283a 	ret
  80dc78:	123feb16 	blt	r2,r8,80dc28 <__alt_data_end+0xfff0dc28>
  80dc7c:	1abff336 	bltu	r3,r10,80dc4c <__alt_data_end+0xfff0dc4c>
  80dc80:	50c00326 	beq	r10,r3,80dc90 <__ledf2+0xe4>
  80dc84:	50c0042e 	bgeu	r10,r3,80dc98 <__ledf2+0xec>
  80dc88:	283fe81e 	bne	r5,zero,80dc2c <__alt_data_end+0xfff0dc2c>
  80dc8c:	003ff806 	br	80dc70 <__alt_data_end+0xfff0dc70>
  80dc90:	313fee36 	bltu	r6,r4,80dc4c <__alt_data_end+0xfff0dc4c>
  80dc94:	21bffc36 	bltu	r4,r6,80dc88 <__alt_data_end+0xfff0dc88>
  80dc98:	0005883a 	mov	r2,zero
  80dc9c:	f800283a 	ret

0080dca0 <__muldf3>:
  80dca0:	deffee04 	addi	sp,sp,-72
  80dca4:	dd000c15 	stw	r20,48(sp)
  80dca8:	2828d53a 	srli	r20,r5,20
  80dcac:	ddc00f15 	stw	r23,60(sp)
  80dcb0:	282ed7fa 	srli	r23,r5,31
  80dcb4:	dc000815 	stw	r16,32(sp)
  80dcb8:	04000434 	movhi	r16,16
  80dcbc:	dcc00b15 	stw	r19,44(sp)
  80dcc0:	843fffc4 	addi	r16,r16,-1
  80dcc4:	dfc01115 	stw	ra,68(sp)
  80dcc8:	df001015 	stw	fp,64(sp)
  80dccc:	dd800e15 	stw	r22,56(sp)
  80dcd0:	dd400d15 	stw	r21,52(sp)
  80dcd4:	dc800a15 	stw	r18,40(sp)
  80dcd8:	dc400915 	stw	r17,36(sp)
  80dcdc:	a501ffcc 	andi	r20,r20,2047
  80dce0:	2c20703a 	and	r16,r5,r16
  80dce4:	b827883a 	mov	r19,r23
  80dce8:	ba403fcc 	andi	r9,r23,255
  80dcec:	a0006026 	beq	r20,zero,80de70 <__muldf3+0x1d0>
  80dcf0:	0081ffc4 	movi	r2,2047
  80dcf4:	202d883a 	mov	r22,r4
  80dcf8:	a0803626 	beq	r20,r2,80ddd4 <__muldf3+0x134>
  80dcfc:	84000434 	orhi	r16,r16,16
  80dd00:	200ad77a 	srli	r5,r4,29
  80dd04:	800490fa 	slli	r2,r16,3
  80dd08:	202c90fa 	slli	r22,r4,3
  80dd0c:	a53f0044 	addi	r20,r20,-1023
  80dd10:	28a0b03a 	or	r16,r5,r2
  80dd14:	002b883a 	mov	r21,zero
  80dd18:	000b883a 	mov	r5,zero
  80dd1c:	3804d53a 	srli	r2,r7,20
  80dd20:	3838d7fa 	srli	fp,r7,31
  80dd24:	04400434 	movhi	r17,16
  80dd28:	8c7fffc4 	addi	r17,r17,-1
  80dd2c:	1081ffcc 	andi	r2,r2,2047
  80dd30:	3025883a 	mov	r18,r6
  80dd34:	3c62703a 	and	r17,r7,r17
  80dd38:	e2803fcc 	andi	r10,fp,255
  80dd3c:	10006d26 	beq	r2,zero,80def4 <__muldf3+0x254>
  80dd40:	00c1ffc4 	movi	r3,2047
  80dd44:	10c06526 	beq	r2,r3,80dedc <__muldf3+0x23c>
  80dd48:	8c400434 	orhi	r17,r17,16
  80dd4c:	300ed77a 	srli	r7,r6,29
  80dd50:	880690fa 	slli	r3,r17,3
  80dd54:	302490fa 	slli	r18,r6,3
  80dd58:	10bf0044 	addi	r2,r2,-1023
  80dd5c:	38e2b03a 	or	r17,r7,r3
  80dd60:	000f883a 	mov	r7,zero
  80dd64:	a087883a 	add	r3,r20,r2
  80dd68:	010003c4 	movi	r4,15
  80dd6c:	3d44b03a 	or	r2,r7,r21
  80dd70:	e5ccf03a 	xor	r6,fp,r23
  80dd74:	1a000044 	addi	r8,r3,1
  80dd78:	20809b36 	bltu	r4,r2,80dfe8 <__muldf3+0x348>
  80dd7c:	100490ba 	slli	r2,r2,2
  80dd80:	01002074 	movhi	r4,129
  80dd84:	21376504 	addi	r4,r4,-8812
  80dd88:	1105883a 	add	r2,r2,r4
  80dd8c:	10800017 	ldw	r2,0(r2)
  80dd90:	1000683a 	jmp	r2
  80dd94:	0080dfe8 	cmpgeui	r2,zero,895
  80dd98:	0080ddf4 	movhi	r2,887
  80dd9c:	0080ddf4 	movhi	r2,887
  80dda0:	0080ddf0 	cmpltui	r2,zero,887
  80dda4:	0080dfc4 	movi	r2,895
  80dda8:	0080dfc4 	movi	r2,895
  80ddac:	0080dfac 	andhi	r2,zero,894
  80ddb0:	0080ddf0 	cmpltui	r2,zero,887
  80ddb4:	0080dfc4 	movi	r2,895
  80ddb8:	0080dfac 	andhi	r2,zero,894
  80ddbc:	0080dfc4 	movi	r2,895
  80ddc0:	0080ddf0 	cmpltui	r2,zero,887
  80ddc4:	0080dfd4 	movui	r2,895
  80ddc8:	0080dfd4 	movui	r2,895
  80ddcc:	0080dfd4 	movui	r2,895
  80ddd0:	0080e334 	movhi	r2,908
  80ddd4:	2404b03a 	or	r2,r4,r16
  80ddd8:	1000711e 	bne	r2,zero,80dfa0 <__muldf3+0x300>
  80dddc:	05400204 	movi	r21,8
  80dde0:	0021883a 	mov	r16,zero
  80dde4:	002d883a 	mov	r22,zero
  80dde8:	01400084 	movi	r5,2
  80ddec:	003fcb06 	br	80dd1c <__alt_data_end+0xfff0dd1c>
  80ddf0:	500d883a 	mov	r6,r10
  80ddf4:	00800084 	movi	r2,2
  80ddf8:	38805926 	beq	r7,r2,80df60 <__muldf3+0x2c0>
  80ddfc:	008000c4 	movi	r2,3
  80de00:	3881bb26 	beq	r7,r2,80e4f0 <__muldf3+0x850>
  80de04:	00800044 	movi	r2,1
  80de08:	3881961e 	bne	r7,r2,80e464 <__muldf3+0x7c4>
  80de0c:	3027883a 	mov	r19,r6
  80de10:	0005883a 	mov	r2,zero
  80de14:	0021883a 	mov	r16,zero
  80de18:	002d883a 	mov	r22,zero
  80de1c:	1004953a 	slli	r2,r2,20
  80de20:	98c03fcc 	andi	r3,r19,255
  80de24:	04400434 	movhi	r17,16
  80de28:	8c7fffc4 	addi	r17,r17,-1
  80de2c:	180697fa 	slli	r3,r3,31
  80de30:	8460703a 	and	r16,r16,r17
  80de34:	80a0b03a 	or	r16,r16,r2
  80de38:	80c6b03a 	or	r3,r16,r3
  80de3c:	b005883a 	mov	r2,r22
  80de40:	dfc01117 	ldw	ra,68(sp)
  80de44:	df001017 	ldw	fp,64(sp)
  80de48:	ddc00f17 	ldw	r23,60(sp)
  80de4c:	dd800e17 	ldw	r22,56(sp)
  80de50:	dd400d17 	ldw	r21,52(sp)
  80de54:	dd000c17 	ldw	r20,48(sp)
  80de58:	dcc00b17 	ldw	r19,44(sp)
  80de5c:	dc800a17 	ldw	r18,40(sp)
  80de60:	dc400917 	ldw	r17,36(sp)
  80de64:	dc000817 	ldw	r16,32(sp)
  80de68:	dec01204 	addi	sp,sp,72
  80de6c:	f800283a 	ret
  80de70:	2404b03a 	or	r2,r4,r16
  80de74:	202b883a 	mov	r21,r4
  80de78:	10004426 	beq	r2,zero,80df8c <__muldf3+0x2ec>
  80de7c:	80015126 	beq	r16,zero,80e3c4 <__muldf3+0x724>
  80de80:	8009883a 	mov	r4,r16
  80de84:	d9800715 	stw	r6,28(sp)
  80de88:	d9c00215 	stw	r7,8(sp)
  80de8c:	da400415 	stw	r9,16(sp)
  80de90:	080f21c0 	call	80f21c <__clzsi2>
  80de94:	d9800717 	ldw	r6,28(sp)
  80de98:	d9c00217 	ldw	r7,8(sp)
  80de9c:	da400417 	ldw	r9,16(sp)
  80dea0:	113ffd44 	addi	r4,r2,-11
  80dea4:	00c00704 	movi	r3,28
  80dea8:	19014216 	blt	r3,r4,80e3b4 <__muldf3+0x714>
  80deac:	00c00744 	movi	r3,29
  80deb0:	15bffe04 	addi	r22,r2,-8
  80deb4:	1907c83a 	sub	r3,r3,r4
  80deb8:	85a0983a 	sll	r16,r16,r22
  80debc:	a8c6d83a 	srl	r3,r21,r3
  80dec0:	adac983a 	sll	r22,r21,r22
  80dec4:	1c20b03a 	or	r16,r3,r16
  80dec8:	1080fcc4 	addi	r2,r2,1011
  80decc:	00a9c83a 	sub	r20,zero,r2
  80ded0:	002b883a 	mov	r21,zero
  80ded4:	000b883a 	mov	r5,zero
  80ded8:	003f9006 	br	80dd1c <__alt_data_end+0xfff0dd1c>
  80dedc:	3446b03a 	or	r3,r6,r17
  80dee0:	1800281e 	bne	r3,zero,80df84 <__muldf3+0x2e4>
  80dee4:	0023883a 	mov	r17,zero
  80dee8:	0025883a 	mov	r18,zero
  80deec:	01c00084 	movi	r7,2
  80def0:	003f9c06 	br	80dd64 <__alt_data_end+0xfff0dd64>
  80def4:	3446b03a 	or	r3,r6,r17
  80def8:	18001e26 	beq	r3,zero,80df74 <__muldf3+0x2d4>
  80defc:	88012126 	beq	r17,zero,80e384 <__muldf3+0x6e4>
  80df00:	8809883a 	mov	r4,r17
  80df04:	d9400215 	stw	r5,8(sp)
  80df08:	d9800715 	stw	r6,28(sp)
  80df0c:	da400415 	stw	r9,16(sp)
  80df10:	da800315 	stw	r10,12(sp)
  80df14:	080f21c0 	call	80f21c <__clzsi2>
  80df18:	d9400217 	ldw	r5,8(sp)
  80df1c:	d9800717 	ldw	r6,28(sp)
  80df20:	da400417 	ldw	r9,16(sp)
  80df24:	da800317 	ldw	r10,12(sp)
  80df28:	113ffd44 	addi	r4,r2,-11
  80df2c:	00c00704 	movi	r3,28
  80df30:	19011016 	blt	r3,r4,80e374 <__muldf3+0x6d4>
  80df34:	00c00744 	movi	r3,29
  80df38:	14bffe04 	addi	r18,r2,-8
  80df3c:	1907c83a 	sub	r3,r3,r4
  80df40:	8ca2983a 	sll	r17,r17,r18
  80df44:	30c6d83a 	srl	r3,r6,r3
  80df48:	34a4983a 	sll	r18,r6,r18
  80df4c:	1c62b03a 	or	r17,r3,r17
  80df50:	1080fcc4 	addi	r2,r2,1011
  80df54:	0085c83a 	sub	r2,zero,r2
  80df58:	000f883a 	mov	r7,zero
  80df5c:	003f8106 	br	80dd64 <__alt_data_end+0xfff0dd64>
  80df60:	3027883a 	mov	r19,r6
  80df64:	0081ffc4 	movi	r2,2047
  80df68:	0021883a 	mov	r16,zero
  80df6c:	002d883a 	mov	r22,zero
  80df70:	003faa06 	br	80de1c <__alt_data_end+0xfff0de1c>
  80df74:	0023883a 	mov	r17,zero
  80df78:	0025883a 	mov	r18,zero
  80df7c:	01c00044 	movi	r7,1
  80df80:	003f7806 	br	80dd64 <__alt_data_end+0xfff0dd64>
  80df84:	01c000c4 	movi	r7,3
  80df88:	003f7606 	br	80dd64 <__alt_data_end+0xfff0dd64>
  80df8c:	05400104 	movi	r21,4
  80df90:	0021883a 	mov	r16,zero
  80df94:	002d883a 	mov	r22,zero
  80df98:	01400044 	movi	r5,1
  80df9c:	003f5f06 	br	80dd1c <__alt_data_end+0xfff0dd1c>
  80dfa0:	05400304 	movi	r21,12
  80dfa4:	014000c4 	movi	r5,3
  80dfa8:	003f5c06 	br	80dd1c <__alt_data_end+0xfff0dd1c>
  80dfac:	04000434 	movhi	r16,16
  80dfb0:	0027883a 	mov	r19,zero
  80dfb4:	843fffc4 	addi	r16,r16,-1
  80dfb8:	05bfffc4 	movi	r22,-1
  80dfbc:	0081ffc4 	movi	r2,2047
  80dfc0:	003f9606 	br	80de1c <__alt_data_end+0xfff0de1c>
  80dfc4:	8023883a 	mov	r17,r16
  80dfc8:	b025883a 	mov	r18,r22
  80dfcc:	280f883a 	mov	r7,r5
  80dfd0:	003f8806 	br	80ddf4 <__alt_data_end+0xfff0ddf4>
  80dfd4:	8023883a 	mov	r17,r16
  80dfd8:	b025883a 	mov	r18,r22
  80dfdc:	480d883a 	mov	r6,r9
  80dfe0:	280f883a 	mov	r7,r5
  80dfe4:	003f8306 	br	80ddf4 <__alt_data_end+0xfff0ddf4>
  80dfe8:	b026d43a 	srli	r19,r22,16
  80dfec:	902ed43a 	srli	r23,r18,16
  80dff0:	b5bfffcc 	andi	r22,r22,65535
  80dff4:	94bfffcc 	andi	r18,r18,65535
  80dff8:	b00b883a 	mov	r5,r22
  80dffc:	9009883a 	mov	r4,r18
  80e000:	d8c00515 	stw	r3,20(sp)
  80e004:	d9800715 	stw	r6,28(sp)
  80e008:	da000615 	stw	r8,24(sp)
  80e00c:	080b2480 	call	80b248 <__mulsi3>
  80e010:	980b883a 	mov	r5,r19
  80e014:	9009883a 	mov	r4,r18
  80e018:	1029883a 	mov	r20,r2
  80e01c:	080b2480 	call	80b248 <__mulsi3>
  80e020:	b80b883a 	mov	r5,r23
  80e024:	9809883a 	mov	r4,r19
  80e028:	102b883a 	mov	r21,r2
  80e02c:	080b2480 	call	80b248 <__mulsi3>
  80e030:	b809883a 	mov	r4,r23
  80e034:	b00b883a 	mov	r5,r22
  80e038:	1039883a 	mov	fp,r2
  80e03c:	080b2480 	call	80b248 <__mulsi3>
  80e040:	a008d43a 	srli	r4,r20,16
  80e044:	1545883a 	add	r2,r2,r21
  80e048:	d8c00517 	ldw	r3,20(sp)
  80e04c:	2085883a 	add	r2,r4,r2
  80e050:	d9800717 	ldw	r6,28(sp)
  80e054:	da000617 	ldw	r8,24(sp)
  80e058:	1540022e 	bgeu	r2,r21,80e064 <__muldf3+0x3c4>
  80e05c:	01000074 	movhi	r4,1
  80e060:	e139883a 	add	fp,fp,r4
  80e064:	100e943a 	slli	r7,r2,16
  80e068:	1004d43a 	srli	r2,r2,16
  80e06c:	882ad43a 	srli	r21,r17,16
  80e070:	a53fffcc 	andi	r20,r20,65535
  80e074:	8c7fffcc 	andi	r17,r17,65535
  80e078:	3d29883a 	add	r20,r7,r20
  80e07c:	b00b883a 	mov	r5,r22
  80e080:	8809883a 	mov	r4,r17
  80e084:	d8c00515 	stw	r3,20(sp)
  80e088:	d9800715 	stw	r6,28(sp)
  80e08c:	da000615 	stw	r8,24(sp)
  80e090:	dd000115 	stw	r20,4(sp)
  80e094:	d8800015 	stw	r2,0(sp)
  80e098:	080b2480 	call	80b248 <__mulsi3>
  80e09c:	980b883a 	mov	r5,r19
  80e0a0:	8809883a 	mov	r4,r17
  80e0a4:	d8800215 	stw	r2,8(sp)
  80e0a8:	080b2480 	call	80b248 <__mulsi3>
  80e0ac:	9809883a 	mov	r4,r19
  80e0b0:	a80b883a 	mov	r5,r21
  80e0b4:	1029883a 	mov	r20,r2
  80e0b8:	080b2480 	call	80b248 <__mulsi3>
  80e0bc:	b00b883a 	mov	r5,r22
  80e0c0:	a809883a 	mov	r4,r21
  80e0c4:	d8800415 	stw	r2,16(sp)
  80e0c8:	080b2480 	call	80b248 <__mulsi3>
  80e0cc:	d9c00217 	ldw	r7,8(sp)
  80e0d0:	1505883a 	add	r2,r2,r20
  80e0d4:	d8c00517 	ldw	r3,20(sp)
  80e0d8:	3826d43a 	srli	r19,r7,16
  80e0dc:	d9800717 	ldw	r6,28(sp)
  80e0e0:	da000617 	ldw	r8,24(sp)
  80e0e4:	9885883a 	add	r2,r19,r2
  80e0e8:	da400417 	ldw	r9,16(sp)
  80e0ec:	1500022e 	bgeu	r2,r20,80e0f8 <__muldf3+0x458>
  80e0f0:	01000074 	movhi	r4,1
  80e0f4:	4913883a 	add	r9,r9,r4
  80e0f8:	1028d43a 	srli	r20,r2,16
  80e0fc:	1004943a 	slli	r2,r2,16
  80e100:	802cd43a 	srli	r22,r16,16
  80e104:	843fffcc 	andi	r16,r16,65535
  80e108:	3cffffcc 	andi	r19,r7,65535
  80e10c:	9009883a 	mov	r4,r18
  80e110:	800b883a 	mov	r5,r16
  80e114:	a269883a 	add	r20,r20,r9
  80e118:	d8c00515 	stw	r3,20(sp)
  80e11c:	d9800715 	stw	r6,28(sp)
  80e120:	da000615 	stw	r8,24(sp)
  80e124:	14e7883a 	add	r19,r2,r19
  80e128:	080b2480 	call	80b248 <__mulsi3>
  80e12c:	9009883a 	mov	r4,r18
  80e130:	b00b883a 	mov	r5,r22
  80e134:	d8800315 	stw	r2,12(sp)
  80e138:	080b2480 	call	80b248 <__mulsi3>
  80e13c:	b809883a 	mov	r4,r23
  80e140:	b00b883a 	mov	r5,r22
  80e144:	d8800215 	stw	r2,8(sp)
  80e148:	080b2480 	call	80b248 <__mulsi3>
  80e14c:	b80b883a 	mov	r5,r23
  80e150:	8009883a 	mov	r4,r16
  80e154:	d8800415 	stw	r2,16(sp)
  80e158:	080b2480 	call	80b248 <__mulsi3>
  80e15c:	da800317 	ldw	r10,12(sp)
  80e160:	d9c00217 	ldw	r7,8(sp)
  80e164:	d9000017 	ldw	r4,0(sp)
  80e168:	502ed43a 	srli	r23,r10,16
  80e16c:	11c5883a 	add	r2,r2,r7
  80e170:	24e5883a 	add	r18,r4,r19
  80e174:	b885883a 	add	r2,r23,r2
  80e178:	d8c00517 	ldw	r3,20(sp)
  80e17c:	d9800717 	ldw	r6,28(sp)
  80e180:	da000617 	ldw	r8,24(sp)
  80e184:	da400417 	ldw	r9,16(sp)
  80e188:	11c0022e 	bgeu	r2,r7,80e194 <__muldf3+0x4f4>
  80e18c:	01000074 	movhi	r4,1
  80e190:	4913883a 	add	r9,r9,r4
  80e194:	100ed43a 	srli	r7,r2,16
  80e198:	1004943a 	slli	r2,r2,16
  80e19c:	55ffffcc 	andi	r23,r10,65535
  80e1a0:	3a53883a 	add	r9,r7,r9
  80e1a4:	8809883a 	mov	r4,r17
  80e1a8:	800b883a 	mov	r5,r16
  80e1ac:	d8c00515 	stw	r3,20(sp)
  80e1b0:	d9800715 	stw	r6,28(sp)
  80e1b4:	da000615 	stw	r8,24(sp)
  80e1b8:	da400415 	stw	r9,16(sp)
  80e1bc:	15ef883a 	add	r23,r2,r23
  80e1c0:	080b2480 	call	80b248 <__mulsi3>
  80e1c4:	8809883a 	mov	r4,r17
  80e1c8:	b00b883a 	mov	r5,r22
  80e1cc:	d8800215 	stw	r2,8(sp)
  80e1d0:	080b2480 	call	80b248 <__mulsi3>
  80e1d4:	b00b883a 	mov	r5,r22
  80e1d8:	a809883a 	mov	r4,r21
  80e1dc:	d8800315 	stw	r2,12(sp)
  80e1e0:	080b2480 	call	80b248 <__mulsi3>
  80e1e4:	8009883a 	mov	r4,r16
  80e1e8:	a80b883a 	mov	r5,r21
  80e1ec:	1023883a 	mov	r17,r2
  80e1f0:	080b2480 	call	80b248 <__mulsi3>
  80e1f4:	d9c00217 	ldw	r7,8(sp)
  80e1f8:	da800317 	ldw	r10,12(sp)
  80e1fc:	d8c00517 	ldw	r3,20(sp)
  80e200:	3808d43a 	srli	r4,r7,16
  80e204:	1285883a 	add	r2,r2,r10
  80e208:	d9800717 	ldw	r6,28(sp)
  80e20c:	2085883a 	add	r2,r4,r2
  80e210:	da000617 	ldw	r8,24(sp)
  80e214:	da400417 	ldw	r9,16(sp)
  80e218:	1280022e 	bgeu	r2,r10,80e224 <__muldf3+0x584>
  80e21c:	01000074 	movhi	r4,1
  80e220:	8923883a 	add	r17,r17,r4
  80e224:	1008943a 	slli	r4,r2,16
  80e228:	39ffffcc 	andi	r7,r7,65535
  80e22c:	e4b9883a 	add	fp,fp,r18
  80e230:	21cf883a 	add	r7,r4,r7
  80e234:	e4e7803a 	cmpltu	r19,fp,r19
  80e238:	3d0f883a 	add	r7,r7,r20
  80e23c:	bf39883a 	add	fp,r23,fp
  80e240:	99c9883a 	add	r4,r19,r7
  80e244:	e5ef803a 	cmpltu	r23,fp,r23
  80e248:	490b883a 	add	r5,r9,r4
  80e24c:	1004d43a 	srli	r2,r2,16
  80e250:	b965883a 	add	r18,r23,r5
  80e254:	24c9803a 	cmpltu	r4,r4,r19
  80e258:	3d29803a 	cmpltu	r20,r7,r20
  80e25c:	a128b03a 	or	r20,r20,r4
  80e260:	95ef803a 	cmpltu	r23,r18,r23
  80e264:	2a53803a 	cmpltu	r9,r5,r9
  80e268:	a0a9883a 	add	r20,r20,r2
  80e26c:	4deeb03a 	or	r23,r9,r23
  80e270:	a5ef883a 	add	r23,r20,r23
  80e274:	bc63883a 	add	r17,r23,r17
  80e278:	e004927a 	slli	r2,fp,9
  80e27c:	d9000117 	ldw	r4,4(sp)
  80e280:	882e927a 	slli	r23,r17,9
  80e284:	9022d5fa 	srli	r17,r18,23
  80e288:	e038d5fa 	srli	fp,fp,23
  80e28c:	1104b03a 	or	r2,r2,r4
  80e290:	9024927a 	slli	r18,r18,9
  80e294:	1004c03a 	cmpne	r2,r2,zero
  80e298:	bc62b03a 	or	r17,r23,r17
  80e29c:	1738b03a 	or	fp,r2,fp
  80e2a0:	8880402c 	andhi	r2,r17,256
  80e2a4:	e4a4b03a 	or	r18,fp,r18
  80e2a8:	10000726 	beq	r2,zero,80e2c8 <__muldf3+0x628>
  80e2ac:	9006d07a 	srli	r3,r18,1
  80e2b0:	880497fa 	slli	r2,r17,31
  80e2b4:	9480004c 	andi	r18,r18,1
  80e2b8:	8822d07a 	srli	r17,r17,1
  80e2bc:	1ca4b03a 	or	r18,r3,r18
  80e2c0:	14a4b03a 	or	r18,r2,r18
  80e2c4:	4007883a 	mov	r3,r8
  80e2c8:	1880ffc4 	addi	r2,r3,1023
  80e2cc:	0080460e 	bge	zero,r2,80e3e8 <__muldf3+0x748>
  80e2d0:	910001cc 	andi	r4,r18,7
  80e2d4:	20000726 	beq	r4,zero,80e2f4 <__muldf3+0x654>
  80e2d8:	910003cc 	andi	r4,r18,15
  80e2dc:	01400104 	movi	r5,4
  80e2e0:	21400426 	beq	r4,r5,80e2f4 <__muldf3+0x654>
  80e2e4:	9149883a 	add	r4,r18,r5
  80e2e8:	24a5803a 	cmpltu	r18,r4,r18
  80e2ec:	8ca3883a 	add	r17,r17,r18
  80e2f0:	2025883a 	mov	r18,r4
  80e2f4:	8900402c 	andhi	r4,r17,256
  80e2f8:	20000426 	beq	r4,zero,80e30c <__muldf3+0x66c>
  80e2fc:	18810004 	addi	r2,r3,1024
  80e300:	00ffc034 	movhi	r3,65280
  80e304:	18ffffc4 	addi	r3,r3,-1
  80e308:	88e2703a 	and	r17,r17,r3
  80e30c:	00c1ff84 	movi	r3,2046
  80e310:	18bf1316 	blt	r3,r2,80df60 <__alt_data_end+0xfff0df60>
  80e314:	882c977a 	slli	r22,r17,29
  80e318:	9024d0fa 	srli	r18,r18,3
  80e31c:	8822927a 	slli	r17,r17,9
  80e320:	1081ffcc 	andi	r2,r2,2047
  80e324:	b4acb03a 	or	r22,r22,r18
  80e328:	8820d33a 	srli	r16,r17,12
  80e32c:	3027883a 	mov	r19,r6
  80e330:	003eba06 	br	80de1c <__alt_data_end+0xfff0de1c>
  80e334:	8080022c 	andhi	r2,r16,8
  80e338:	10000926 	beq	r2,zero,80e360 <__muldf3+0x6c0>
  80e33c:	8880022c 	andhi	r2,r17,8
  80e340:	1000071e 	bne	r2,zero,80e360 <__muldf3+0x6c0>
  80e344:	00800434 	movhi	r2,16
  80e348:	8c000234 	orhi	r16,r17,8
  80e34c:	10bfffc4 	addi	r2,r2,-1
  80e350:	e027883a 	mov	r19,fp
  80e354:	80a0703a 	and	r16,r16,r2
  80e358:	902d883a 	mov	r22,r18
  80e35c:	003f1706 	br	80dfbc <__alt_data_end+0xfff0dfbc>
  80e360:	00800434 	movhi	r2,16
  80e364:	84000234 	orhi	r16,r16,8
  80e368:	10bfffc4 	addi	r2,r2,-1
  80e36c:	80a0703a 	and	r16,r16,r2
  80e370:	003f1206 	br	80dfbc <__alt_data_end+0xfff0dfbc>
  80e374:	147ff604 	addi	r17,r2,-40
  80e378:	3462983a 	sll	r17,r6,r17
  80e37c:	0025883a 	mov	r18,zero
  80e380:	003ef306 	br	80df50 <__alt_data_end+0xfff0df50>
  80e384:	3009883a 	mov	r4,r6
  80e388:	d9400215 	stw	r5,8(sp)
  80e38c:	d9800715 	stw	r6,28(sp)
  80e390:	da400415 	stw	r9,16(sp)
  80e394:	da800315 	stw	r10,12(sp)
  80e398:	080f21c0 	call	80f21c <__clzsi2>
  80e39c:	10800804 	addi	r2,r2,32
  80e3a0:	da800317 	ldw	r10,12(sp)
  80e3a4:	da400417 	ldw	r9,16(sp)
  80e3a8:	d9800717 	ldw	r6,28(sp)
  80e3ac:	d9400217 	ldw	r5,8(sp)
  80e3b0:	003edd06 	br	80df28 <__alt_data_end+0xfff0df28>
  80e3b4:	143ff604 	addi	r16,r2,-40
  80e3b8:	ac20983a 	sll	r16,r21,r16
  80e3bc:	002d883a 	mov	r22,zero
  80e3c0:	003ec106 	br	80dec8 <__alt_data_end+0xfff0dec8>
  80e3c4:	d9800715 	stw	r6,28(sp)
  80e3c8:	d9c00215 	stw	r7,8(sp)
  80e3cc:	da400415 	stw	r9,16(sp)
  80e3d0:	080f21c0 	call	80f21c <__clzsi2>
  80e3d4:	10800804 	addi	r2,r2,32
  80e3d8:	da400417 	ldw	r9,16(sp)
  80e3dc:	d9c00217 	ldw	r7,8(sp)
  80e3e0:	d9800717 	ldw	r6,28(sp)
  80e3e4:	003eae06 	br	80dea0 <__alt_data_end+0xfff0dea0>
  80e3e8:	00c00044 	movi	r3,1
  80e3ec:	1887c83a 	sub	r3,r3,r2
  80e3f0:	01000e04 	movi	r4,56
  80e3f4:	20fe8516 	blt	r4,r3,80de0c <__alt_data_end+0xfff0de0c>
  80e3f8:	010007c4 	movi	r4,31
  80e3fc:	20c01b16 	blt	r4,r3,80e46c <__muldf3+0x7cc>
  80e400:	00800804 	movi	r2,32
  80e404:	10c5c83a 	sub	r2,r2,r3
  80e408:	888a983a 	sll	r5,r17,r2
  80e40c:	90c8d83a 	srl	r4,r18,r3
  80e410:	9084983a 	sll	r2,r18,r2
  80e414:	88e2d83a 	srl	r17,r17,r3
  80e418:	2906b03a 	or	r3,r5,r4
  80e41c:	1004c03a 	cmpne	r2,r2,zero
  80e420:	1886b03a 	or	r3,r3,r2
  80e424:	188001cc 	andi	r2,r3,7
  80e428:	10000726 	beq	r2,zero,80e448 <__muldf3+0x7a8>
  80e42c:	188003cc 	andi	r2,r3,15
  80e430:	01000104 	movi	r4,4
  80e434:	11000426 	beq	r2,r4,80e448 <__muldf3+0x7a8>
  80e438:	1805883a 	mov	r2,r3
  80e43c:	10c00104 	addi	r3,r2,4
  80e440:	1885803a 	cmpltu	r2,r3,r2
  80e444:	88a3883a 	add	r17,r17,r2
  80e448:	8880202c 	andhi	r2,r17,128
  80e44c:	10001c26 	beq	r2,zero,80e4c0 <__muldf3+0x820>
  80e450:	3027883a 	mov	r19,r6
  80e454:	00800044 	movi	r2,1
  80e458:	0021883a 	mov	r16,zero
  80e45c:	002d883a 	mov	r22,zero
  80e460:	003e6e06 	br	80de1c <__alt_data_end+0xfff0de1c>
  80e464:	4007883a 	mov	r3,r8
  80e468:	003f9706 	br	80e2c8 <__alt_data_end+0xfff0e2c8>
  80e46c:	017ff844 	movi	r5,-31
  80e470:	2885c83a 	sub	r2,r5,r2
  80e474:	888ad83a 	srl	r5,r17,r2
  80e478:	00800804 	movi	r2,32
  80e47c:	18801a26 	beq	r3,r2,80e4e8 <__muldf3+0x848>
  80e480:	01001004 	movi	r4,64
  80e484:	20c7c83a 	sub	r3,r4,r3
  80e488:	88e2983a 	sll	r17,r17,r3
  80e48c:	8ca4b03a 	or	r18,r17,r18
  80e490:	9004c03a 	cmpne	r2,r18,zero
  80e494:	2884b03a 	or	r2,r5,r2
  80e498:	144001cc 	andi	r17,r2,7
  80e49c:	88000d1e 	bne	r17,zero,80e4d4 <__muldf3+0x834>
  80e4a0:	0021883a 	mov	r16,zero
  80e4a4:	102cd0fa 	srli	r22,r2,3
  80e4a8:	3027883a 	mov	r19,r6
  80e4ac:	0005883a 	mov	r2,zero
  80e4b0:	b46cb03a 	or	r22,r22,r17
  80e4b4:	003e5906 	br	80de1c <__alt_data_end+0xfff0de1c>
  80e4b8:	1007883a 	mov	r3,r2
  80e4bc:	0023883a 	mov	r17,zero
  80e4c0:	8820927a 	slli	r16,r17,9
  80e4c4:	1805883a 	mov	r2,r3
  80e4c8:	8822977a 	slli	r17,r17,29
  80e4cc:	8020d33a 	srli	r16,r16,12
  80e4d0:	003ff406 	br	80e4a4 <__alt_data_end+0xfff0e4a4>
  80e4d4:	10c003cc 	andi	r3,r2,15
  80e4d8:	01000104 	movi	r4,4
  80e4dc:	193ff626 	beq	r3,r4,80e4b8 <__alt_data_end+0xfff0e4b8>
  80e4e0:	0023883a 	mov	r17,zero
  80e4e4:	003fd506 	br	80e43c <__alt_data_end+0xfff0e43c>
  80e4e8:	0023883a 	mov	r17,zero
  80e4ec:	003fe706 	br	80e48c <__alt_data_end+0xfff0e48c>
  80e4f0:	00800434 	movhi	r2,16
  80e4f4:	8c000234 	orhi	r16,r17,8
  80e4f8:	10bfffc4 	addi	r2,r2,-1
  80e4fc:	3027883a 	mov	r19,r6
  80e500:	80a0703a 	and	r16,r16,r2
  80e504:	902d883a 	mov	r22,r18
  80e508:	003eac06 	br	80dfbc <__alt_data_end+0xfff0dfbc>

0080e50c <__subdf3>:
  80e50c:	02000434 	movhi	r8,16
  80e510:	423fffc4 	addi	r8,r8,-1
  80e514:	defffb04 	addi	sp,sp,-20
  80e518:	2a14703a 	and	r10,r5,r8
  80e51c:	3812d53a 	srli	r9,r7,20
  80e520:	3a10703a 	and	r8,r7,r8
  80e524:	2006d77a 	srli	r3,r4,29
  80e528:	3004d77a 	srli	r2,r6,29
  80e52c:	dc000015 	stw	r16,0(sp)
  80e530:	501490fa 	slli	r10,r10,3
  80e534:	2820d53a 	srli	r16,r5,20
  80e538:	401090fa 	slli	r8,r8,3
  80e53c:	dc800215 	stw	r18,8(sp)
  80e540:	dc400115 	stw	r17,4(sp)
  80e544:	dfc00415 	stw	ra,16(sp)
  80e548:	202290fa 	slli	r17,r4,3
  80e54c:	dcc00315 	stw	r19,12(sp)
  80e550:	4a41ffcc 	andi	r9,r9,2047
  80e554:	0101ffc4 	movi	r4,2047
  80e558:	2824d7fa 	srli	r18,r5,31
  80e55c:	8401ffcc 	andi	r16,r16,2047
  80e560:	50c6b03a 	or	r3,r10,r3
  80e564:	380ed7fa 	srli	r7,r7,31
  80e568:	408ab03a 	or	r5,r8,r2
  80e56c:	300c90fa 	slli	r6,r6,3
  80e570:	49009626 	beq	r9,r4,80e7cc <__subdf3+0x2c0>
  80e574:	39c0005c 	xori	r7,r7,1
  80e578:	8245c83a 	sub	r2,r16,r9
  80e57c:	3c807426 	beq	r7,r18,80e750 <__subdf3+0x244>
  80e580:	0080af0e 	bge	zero,r2,80e840 <__subdf3+0x334>
  80e584:	48002a1e 	bne	r9,zero,80e630 <__subdf3+0x124>
  80e588:	2988b03a 	or	r4,r5,r6
  80e58c:	20009a1e 	bne	r4,zero,80e7f8 <__subdf3+0x2ec>
  80e590:	888001cc 	andi	r2,r17,7
  80e594:	10000726 	beq	r2,zero,80e5b4 <__subdf3+0xa8>
  80e598:	888003cc 	andi	r2,r17,15
  80e59c:	01000104 	movi	r4,4
  80e5a0:	11000426 	beq	r2,r4,80e5b4 <__subdf3+0xa8>
  80e5a4:	890b883a 	add	r5,r17,r4
  80e5a8:	2c63803a 	cmpltu	r17,r5,r17
  80e5ac:	1c47883a 	add	r3,r3,r17
  80e5b0:	2823883a 	mov	r17,r5
  80e5b4:	1880202c 	andhi	r2,r3,128
  80e5b8:	10005926 	beq	r2,zero,80e720 <__subdf3+0x214>
  80e5bc:	84000044 	addi	r16,r16,1
  80e5c0:	0081ffc4 	movi	r2,2047
  80e5c4:	8080be26 	beq	r16,r2,80e8c0 <__subdf3+0x3b4>
  80e5c8:	017fe034 	movhi	r5,65408
  80e5cc:	297fffc4 	addi	r5,r5,-1
  80e5d0:	1946703a 	and	r3,r3,r5
  80e5d4:	1804977a 	slli	r2,r3,29
  80e5d8:	1806927a 	slli	r3,r3,9
  80e5dc:	8822d0fa 	srli	r17,r17,3
  80e5e0:	8401ffcc 	andi	r16,r16,2047
  80e5e4:	180ad33a 	srli	r5,r3,12
  80e5e8:	9100004c 	andi	r4,r18,1
  80e5ec:	1444b03a 	or	r2,r2,r17
  80e5f0:	80c1ffcc 	andi	r3,r16,2047
  80e5f4:	1820953a 	slli	r16,r3,20
  80e5f8:	20c03fcc 	andi	r3,r4,255
  80e5fc:	180897fa 	slli	r4,r3,31
  80e600:	00c00434 	movhi	r3,16
  80e604:	18ffffc4 	addi	r3,r3,-1
  80e608:	28c6703a 	and	r3,r5,r3
  80e60c:	1c06b03a 	or	r3,r3,r16
  80e610:	1906b03a 	or	r3,r3,r4
  80e614:	dfc00417 	ldw	ra,16(sp)
  80e618:	dcc00317 	ldw	r19,12(sp)
  80e61c:	dc800217 	ldw	r18,8(sp)
  80e620:	dc400117 	ldw	r17,4(sp)
  80e624:	dc000017 	ldw	r16,0(sp)
  80e628:	dec00504 	addi	sp,sp,20
  80e62c:	f800283a 	ret
  80e630:	0101ffc4 	movi	r4,2047
  80e634:	813fd626 	beq	r16,r4,80e590 <__alt_data_end+0xfff0e590>
  80e638:	29402034 	orhi	r5,r5,128
  80e63c:	01000e04 	movi	r4,56
  80e640:	2080a316 	blt	r4,r2,80e8d0 <__subdf3+0x3c4>
  80e644:	010007c4 	movi	r4,31
  80e648:	2080c616 	blt	r4,r2,80e964 <__subdf3+0x458>
  80e64c:	01000804 	movi	r4,32
  80e650:	2089c83a 	sub	r4,r4,r2
  80e654:	2910983a 	sll	r8,r5,r4
  80e658:	308ed83a 	srl	r7,r6,r2
  80e65c:	3108983a 	sll	r4,r6,r4
  80e660:	2884d83a 	srl	r2,r5,r2
  80e664:	41ccb03a 	or	r6,r8,r7
  80e668:	2008c03a 	cmpne	r4,r4,zero
  80e66c:	310cb03a 	or	r6,r6,r4
  80e670:	898dc83a 	sub	r6,r17,r6
  80e674:	89a3803a 	cmpltu	r17,r17,r6
  80e678:	1887c83a 	sub	r3,r3,r2
  80e67c:	1c47c83a 	sub	r3,r3,r17
  80e680:	3023883a 	mov	r17,r6
  80e684:	1880202c 	andhi	r2,r3,128
  80e688:	10002326 	beq	r2,zero,80e718 <__subdf3+0x20c>
  80e68c:	04c02034 	movhi	r19,128
  80e690:	9cffffc4 	addi	r19,r19,-1
  80e694:	1ce6703a 	and	r19,r3,r19
  80e698:	98007a26 	beq	r19,zero,80e884 <__subdf3+0x378>
  80e69c:	9809883a 	mov	r4,r19
  80e6a0:	080f21c0 	call	80f21c <__clzsi2>
  80e6a4:	113ffe04 	addi	r4,r2,-8
  80e6a8:	00c007c4 	movi	r3,31
  80e6ac:	19007b16 	blt	r3,r4,80e89c <__subdf3+0x390>
  80e6b0:	00800804 	movi	r2,32
  80e6b4:	1105c83a 	sub	r2,r2,r4
  80e6b8:	8884d83a 	srl	r2,r17,r2
  80e6bc:	9906983a 	sll	r3,r19,r4
  80e6c0:	8922983a 	sll	r17,r17,r4
  80e6c4:	10c4b03a 	or	r2,r2,r3
  80e6c8:	24007816 	blt	r4,r16,80e8ac <__subdf3+0x3a0>
  80e6cc:	2421c83a 	sub	r16,r4,r16
  80e6d0:	80c00044 	addi	r3,r16,1
  80e6d4:	010007c4 	movi	r4,31
  80e6d8:	20c09516 	blt	r4,r3,80e930 <__subdf3+0x424>
  80e6dc:	01400804 	movi	r5,32
  80e6e0:	28cbc83a 	sub	r5,r5,r3
  80e6e4:	88c8d83a 	srl	r4,r17,r3
  80e6e8:	8962983a 	sll	r17,r17,r5
  80e6ec:	114a983a 	sll	r5,r2,r5
  80e6f0:	10c6d83a 	srl	r3,r2,r3
  80e6f4:	8804c03a 	cmpne	r2,r17,zero
  80e6f8:	290ab03a 	or	r5,r5,r4
  80e6fc:	28a2b03a 	or	r17,r5,r2
  80e700:	0021883a 	mov	r16,zero
  80e704:	003fa206 	br	80e590 <__alt_data_end+0xfff0e590>
  80e708:	2090b03a 	or	r8,r4,r2
  80e70c:	40018e26 	beq	r8,zero,80ed48 <__subdf3+0x83c>
  80e710:	1007883a 	mov	r3,r2
  80e714:	2023883a 	mov	r17,r4
  80e718:	888001cc 	andi	r2,r17,7
  80e71c:	103f9e1e 	bne	r2,zero,80e598 <__alt_data_end+0xfff0e598>
  80e720:	1804977a 	slli	r2,r3,29
  80e724:	8822d0fa 	srli	r17,r17,3
  80e728:	1810d0fa 	srli	r8,r3,3
  80e72c:	9100004c 	andi	r4,r18,1
  80e730:	1444b03a 	or	r2,r2,r17
  80e734:	00c1ffc4 	movi	r3,2047
  80e738:	80c02826 	beq	r16,r3,80e7dc <__subdf3+0x2d0>
  80e73c:	01400434 	movhi	r5,16
  80e740:	297fffc4 	addi	r5,r5,-1
  80e744:	80e0703a 	and	r16,r16,r3
  80e748:	414a703a 	and	r5,r8,r5
  80e74c:	003fa806 	br	80e5f0 <__alt_data_end+0xfff0e5f0>
  80e750:	0080630e 	bge	zero,r2,80e8e0 <__subdf3+0x3d4>
  80e754:	48003026 	beq	r9,zero,80e818 <__subdf3+0x30c>
  80e758:	0101ffc4 	movi	r4,2047
  80e75c:	813f8c26 	beq	r16,r4,80e590 <__alt_data_end+0xfff0e590>
  80e760:	29402034 	orhi	r5,r5,128
  80e764:	01000e04 	movi	r4,56
  80e768:	2080a90e 	bge	r4,r2,80ea10 <__subdf3+0x504>
  80e76c:	298cb03a 	or	r6,r5,r6
  80e770:	3012c03a 	cmpne	r9,r6,zero
  80e774:	0005883a 	mov	r2,zero
  80e778:	4c53883a 	add	r9,r9,r17
  80e77c:	4c63803a 	cmpltu	r17,r9,r17
  80e780:	10c7883a 	add	r3,r2,r3
  80e784:	88c7883a 	add	r3,r17,r3
  80e788:	4823883a 	mov	r17,r9
  80e78c:	1880202c 	andhi	r2,r3,128
  80e790:	1000d026 	beq	r2,zero,80ead4 <__subdf3+0x5c8>
  80e794:	84000044 	addi	r16,r16,1
  80e798:	0081ffc4 	movi	r2,2047
  80e79c:	8080fe26 	beq	r16,r2,80eb98 <__subdf3+0x68c>
  80e7a0:	00bfe034 	movhi	r2,65408
  80e7a4:	10bfffc4 	addi	r2,r2,-1
  80e7a8:	1886703a 	and	r3,r3,r2
  80e7ac:	880ad07a 	srli	r5,r17,1
  80e7b0:	180497fa 	slli	r2,r3,31
  80e7b4:	8900004c 	andi	r4,r17,1
  80e7b8:	2922b03a 	or	r17,r5,r4
  80e7bc:	1806d07a 	srli	r3,r3,1
  80e7c0:	1462b03a 	or	r17,r2,r17
  80e7c4:	3825883a 	mov	r18,r7
  80e7c8:	003f7106 	br	80e590 <__alt_data_end+0xfff0e590>
  80e7cc:	2984b03a 	or	r2,r5,r6
  80e7d0:	103f6826 	beq	r2,zero,80e574 <__alt_data_end+0xfff0e574>
  80e7d4:	39c03fcc 	andi	r7,r7,255
  80e7d8:	003f6706 	br	80e578 <__alt_data_end+0xfff0e578>
  80e7dc:	4086b03a 	or	r3,r8,r2
  80e7e0:	18015226 	beq	r3,zero,80ed2c <__subdf3+0x820>
  80e7e4:	00c00434 	movhi	r3,16
  80e7e8:	41400234 	orhi	r5,r8,8
  80e7ec:	18ffffc4 	addi	r3,r3,-1
  80e7f0:	28ca703a 	and	r5,r5,r3
  80e7f4:	003f7e06 	br	80e5f0 <__alt_data_end+0xfff0e5f0>
  80e7f8:	10bfffc4 	addi	r2,r2,-1
  80e7fc:	1000491e 	bne	r2,zero,80e924 <__subdf3+0x418>
  80e800:	898fc83a 	sub	r7,r17,r6
  80e804:	89e3803a 	cmpltu	r17,r17,r7
  80e808:	1947c83a 	sub	r3,r3,r5
  80e80c:	1c47c83a 	sub	r3,r3,r17
  80e810:	3823883a 	mov	r17,r7
  80e814:	003f9b06 	br	80e684 <__alt_data_end+0xfff0e684>
  80e818:	2988b03a 	or	r4,r5,r6
  80e81c:	203f5c26 	beq	r4,zero,80e590 <__alt_data_end+0xfff0e590>
  80e820:	10bfffc4 	addi	r2,r2,-1
  80e824:	1000931e 	bne	r2,zero,80ea74 <__subdf3+0x568>
  80e828:	898d883a 	add	r6,r17,r6
  80e82c:	3463803a 	cmpltu	r17,r6,r17
  80e830:	1947883a 	add	r3,r3,r5
  80e834:	88c7883a 	add	r3,r17,r3
  80e838:	3023883a 	mov	r17,r6
  80e83c:	003fd306 	br	80e78c <__alt_data_end+0xfff0e78c>
  80e840:	1000541e 	bne	r2,zero,80e994 <__subdf3+0x488>
  80e844:	80800044 	addi	r2,r16,1
  80e848:	1081ffcc 	andi	r2,r2,2047
  80e84c:	01000044 	movi	r4,1
  80e850:	2080a20e 	bge	r4,r2,80eadc <__subdf3+0x5d0>
  80e854:	8989c83a 	sub	r4,r17,r6
  80e858:	8905803a 	cmpltu	r2,r17,r4
  80e85c:	1967c83a 	sub	r19,r3,r5
  80e860:	98a7c83a 	sub	r19,r19,r2
  80e864:	9880202c 	andhi	r2,r19,128
  80e868:	10006326 	beq	r2,zero,80e9f8 <__subdf3+0x4ec>
  80e86c:	3463c83a 	sub	r17,r6,r17
  80e870:	28c7c83a 	sub	r3,r5,r3
  80e874:	344d803a 	cmpltu	r6,r6,r17
  80e878:	19a7c83a 	sub	r19,r3,r6
  80e87c:	3825883a 	mov	r18,r7
  80e880:	983f861e 	bne	r19,zero,80e69c <__alt_data_end+0xfff0e69c>
  80e884:	8809883a 	mov	r4,r17
  80e888:	080f21c0 	call	80f21c <__clzsi2>
  80e88c:	10800804 	addi	r2,r2,32
  80e890:	113ffe04 	addi	r4,r2,-8
  80e894:	00c007c4 	movi	r3,31
  80e898:	193f850e 	bge	r3,r4,80e6b0 <__alt_data_end+0xfff0e6b0>
  80e89c:	10bff604 	addi	r2,r2,-40
  80e8a0:	8884983a 	sll	r2,r17,r2
  80e8a4:	0023883a 	mov	r17,zero
  80e8a8:	243f880e 	bge	r4,r16,80e6cc <__alt_data_end+0xfff0e6cc>
  80e8ac:	00ffe034 	movhi	r3,65408
  80e8b0:	18ffffc4 	addi	r3,r3,-1
  80e8b4:	8121c83a 	sub	r16,r16,r4
  80e8b8:	10c6703a 	and	r3,r2,r3
  80e8bc:	003f3406 	br	80e590 <__alt_data_end+0xfff0e590>
  80e8c0:	9100004c 	andi	r4,r18,1
  80e8c4:	000b883a 	mov	r5,zero
  80e8c8:	0005883a 	mov	r2,zero
  80e8cc:	003f4806 	br	80e5f0 <__alt_data_end+0xfff0e5f0>
  80e8d0:	298cb03a 	or	r6,r5,r6
  80e8d4:	300cc03a 	cmpne	r6,r6,zero
  80e8d8:	0005883a 	mov	r2,zero
  80e8dc:	003f6406 	br	80e670 <__alt_data_end+0xfff0e670>
  80e8e0:	10009a1e 	bne	r2,zero,80eb4c <__subdf3+0x640>
  80e8e4:	82400044 	addi	r9,r16,1
  80e8e8:	4881ffcc 	andi	r2,r9,2047
  80e8ec:	02800044 	movi	r10,1
  80e8f0:	5080670e 	bge	r10,r2,80ea90 <__subdf3+0x584>
  80e8f4:	0081ffc4 	movi	r2,2047
  80e8f8:	4880af26 	beq	r9,r2,80ebb8 <__subdf3+0x6ac>
  80e8fc:	898d883a 	add	r6,r17,r6
  80e900:	1945883a 	add	r2,r3,r5
  80e904:	3447803a 	cmpltu	r3,r6,r17
  80e908:	1887883a 	add	r3,r3,r2
  80e90c:	182297fa 	slli	r17,r3,31
  80e910:	300cd07a 	srli	r6,r6,1
  80e914:	1806d07a 	srli	r3,r3,1
  80e918:	4821883a 	mov	r16,r9
  80e91c:	89a2b03a 	or	r17,r17,r6
  80e920:	003f1b06 	br	80e590 <__alt_data_end+0xfff0e590>
  80e924:	0101ffc4 	movi	r4,2047
  80e928:	813f441e 	bne	r16,r4,80e63c <__alt_data_end+0xfff0e63c>
  80e92c:	003f1806 	br	80e590 <__alt_data_end+0xfff0e590>
  80e930:	843ff844 	addi	r16,r16,-31
  80e934:	01400804 	movi	r5,32
  80e938:	1408d83a 	srl	r4,r2,r16
  80e93c:	19405026 	beq	r3,r5,80ea80 <__subdf3+0x574>
  80e940:	01401004 	movi	r5,64
  80e944:	28c7c83a 	sub	r3,r5,r3
  80e948:	10c4983a 	sll	r2,r2,r3
  80e94c:	88a2b03a 	or	r17,r17,r2
  80e950:	8822c03a 	cmpne	r17,r17,zero
  80e954:	2462b03a 	or	r17,r4,r17
  80e958:	0007883a 	mov	r3,zero
  80e95c:	0021883a 	mov	r16,zero
  80e960:	003f6d06 	br	80e718 <__alt_data_end+0xfff0e718>
  80e964:	11fff804 	addi	r7,r2,-32
  80e968:	01000804 	movi	r4,32
  80e96c:	29ced83a 	srl	r7,r5,r7
  80e970:	11004526 	beq	r2,r4,80ea88 <__subdf3+0x57c>
  80e974:	01001004 	movi	r4,64
  80e978:	2089c83a 	sub	r4,r4,r2
  80e97c:	2904983a 	sll	r2,r5,r4
  80e980:	118cb03a 	or	r6,r2,r6
  80e984:	300cc03a 	cmpne	r6,r6,zero
  80e988:	398cb03a 	or	r6,r7,r6
  80e98c:	0005883a 	mov	r2,zero
  80e990:	003f3706 	br	80e670 <__alt_data_end+0xfff0e670>
  80e994:	80002a26 	beq	r16,zero,80ea40 <__subdf3+0x534>
  80e998:	0101ffc4 	movi	r4,2047
  80e99c:	49006626 	beq	r9,r4,80eb38 <__subdf3+0x62c>
  80e9a0:	0085c83a 	sub	r2,zero,r2
  80e9a4:	18c02034 	orhi	r3,r3,128
  80e9a8:	01000e04 	movi	r4,56
  80e9ac:	20807e16 	blt	r4,r2,80eba8 <__subdf3+0x69c>
  80e9b0:	010007c4 	movi	r4,31
  80e9b4:	2080e716 	blt	r4,r2,80ed54 <__subdf3+0x848>
  80e9b8:	01000804 	movi	r4,32
  80e9bc:	2089c83a 	sub	r4,r4,r2
  80e9c0:	1914983a 	sll	r10,r3,r4
  80e9c4:	8890d83a 	srl	r8,r17,r2
  80e9c8:	8908983a 	sll	r4,r17,r4
  80e9cc:	1884d83a 	srl	r2,r3,r2
  80e9d0:	5222b03a 	or	r17,r10,r8
  80e9d4:	2006c03a 	cmpne	r3,r4,zero
  80e9d8:	88e2b03a 	or	r17,r17,r3
  80e9dc:	3463c83a 	sub	r17,r6,r17
  80e9e0:	2885c83a 	sub	r2,r5,r2
  80e9e4:	344d803a 	cmpltu	r6,r6,r17
  80e9e8:	1187c83a 	sub	r3,r2,r6
  80e9ec:	4821883a 	mov	r16,r9
  80e9f0:	3825883a 	mov	r18,r7
  80e9f4:	003f2306 	br	80e684 <__alt_data_end+0xfff0e684>
  80e9f8:	24d0b03a 	or	r8,r4,r19
  80e9fc:	40001b1e 	bne	r8,zero,80ea6c <__subdf3+0x560>
  80ea00:	0005883a 	mov	r2,zero
  80ea04:	0009883a 	mov	r4,zero
  80ea08:	0021883a 	mov	r16,zero
  80ea0c:	003f4906 	br	80e734 <__alt_data_end+0xfff0e734>
  80ea10:	010007c4 	movi	r4,31
  80ea14:	20803a16 	blt	r4,r2,80eb00 <__subdf3+0x5f4>
  80ea18:	01000804 	movi	r4,32
  80ea1c:	2089c83a 	sub	r4,r4,r2
  80ea20:	2912983a 	sll	r9,r5,r4
  80ea24:	3090d83a 	srl	r8,r6,r2
  80ea28:	3108983a 	sll	r4,r6,r4
  80ea2c:	2884d83a 	srl	r2,r5,r2
  80ea30:	4a12b03a 	or	r9,r9,r8
  80ea34:	2008c03a 	cmpne	r4,r4,zero
  80ea38:	4912b03a 	or	r9,r9,r4
  80ea3c:	003f4e06 	br	80e778 <__alt_data_end+0xfff0e778>
  80ea40:	1c48b03a 	or	r4,r3,r17
  80ea44:	20003c26 	beq	r4,zero,80eb38 <__subdf3+0x62c>
  80ea48:	0084303a 	nor	r2,zero,r2
  80ea4c:	1000381e 	bne	r2,zero,80eb30 <__subdf3+0x624>
  80ea50:	3463c83a 	sub	r17,r6,r17
  80ea54:	28c5c83a 	sub	r2,r5,r3
  80ea58:	344d803a 	cmpltu	r6,r6,r17
  80ea5c:	1187c83a 	sub	r3,r2,r6
  80ea60:	4821883a 	mov	r16,r9
  80ea64:	3825883a 	mov	r18,r7
  80ea68:	003f0606 	br	80e684 <__alt_data_end+0xfff0e684>
  80ea6c:	2023883a 	mov	r17,r4
  80ea70:	003f0906 	br	80e698 <__alt_data_end+0xfff0e698>
  80ea74:	0101ffc4 	movi	r4,2047
  80ea78:	813f3a1e 	bne	r16,r4,80e764 <__alt_data_end+0xfff0e764>
  80ea7c:	003ec406 	br	80e590 <__alt_data_end+0xfff0e590>
  80ea80:	0005883a 	mov	r2,zero
  80ea84:	003fb106 	br	80e94c <__alt_data_end+0xfff0e94c>
  80ea88:	0005883a 	mov	r2,zero
  80ea8c:	003fbc06 	br	80e980 <__alt_data_end+0xfff0e980>
  80ea90:	1c44b03a 	or	r2,r3,r17
  80ea94:	80008e1e 	bne	r16,zero,80ecd0 <__subdf3+0x7c4>
  80ea98:	1000c826 	beq	r2,zero,80edbc <__subdf3+0x8b0>
  80ea9c:	2984b03a 	or	r2,r5,r6
  80eaa0:	103ebb26 	beq	r2,zero,80e590 <__alt_data_end+0xfff0e590>
  80eaa4:	8989883a 	add	r4,r17,r6
  80eaa8:	1945883a 	add	r2,r3,r5
  80eaac:	2447803a 	cmpltu	r3,r4,r17
  80eab0:	1887883a 	add	r3,r3,r2
  80eab4:	1880202c 	andhi	r2,r3,128
  80eab8:	2023883a 	mov	r17,r4
  80eabc:	103f1626 	beq	r2,zero,80e718 <__alt_data_end+0xfff0e718>
  80eac0:	00bfe034 	movhi	r2,65408
  80eac4:	10bfffc4 	addi	r2,r2,-1
  80eac8:	5021883a 	mov	r16,r10
  80eacc:	1886703a 	and	r3,r3,r2
  80ead0:	003eaf06 	br	80e590 <__alt_data_end+0xfff0e590>
  80ead4:	3825883a 	mov	r18,r7
  80ead8:	003f0f06 	br	80e718 <__alt_data_end+0xfff0e718>
  80eadc:	1c44b03a 	or	r2,r3,r17
  80eae0:	8000251e 	bne	r16,zero,80eb78 <__subdf3+0x66c>
  80eae4:	1000661e 	bne	r2,zero,80ec80 <__subdf3+0x774>
  80eae8:	2990b03a 	or	r8,r5,r6
  80eaec:	40009626 	beq	r8,zero,80ed48 <__subdf3+0x83c>
  80eaf0:	2807883a 	mov	r3,r5
  80eaf4:	3023883a 	mov	r17,r6
  80eaf8:	3825883a 	mov	r18,r7
  80eafc:	003ea406 	br	80e590 <__alt_data_end+0xfff0e590>
  80eb00:	127ff804 	addi	r9,r2,-32
  80eb04:	01000804 	movi	r4,32
  80eb08:	2a52d83a 	srl	r9,r5,r9
  80eb0c:	11008c26 	beq	r2,r4,80ed40 <__subdf3+0x834>
  80eb10:	01001004 	movi	r4,64
  80eb14:	2085c83a 	sub	r2,r4,r2
  80eb18:	2884983a 	sll	r2,r5,r2
  80eb1c:	118cb03a 	or	r6,r2,r6
  80eb20:	300cc03a 	cmpne	r6,r6,zero
  80eb24:	4992b03a 	or	r9,r9,r6
  80eb28:	0005883a 	mov	r2,zero
  80eb2c:	003f1206 	br	80e778 <__alt_data_end+0xfff0e778>
  80eb30:	0101ffc4 	movi	r4,2047
  80eb34:	493f9c1e 	bne	r9,r4,80e9a8 <__alt_data_end+0xfff0e9a8>
  80eb38:	2807883a 	mov	r3,r5
  80eb3c:	3023883a 	mov	r17,r6
  80eb40:	4821883a 	mov	r16,r9
  80eb44:	3825883a 	mov	r18,r7
  80eb48:	003e9106 	br	80e590 <__alt_data_end+0xfff0e590>
  80eb4c:	80001f1e 	bne	r16,zero,80ebcc <__subdf3+0x6c0>
  80eb50:	1c48b03a 	or	r4,r3,r17
  80eb54:	20005a26 	beq	r4,zero,80ecc0 <__subdf3+0x7b4>
  80eb58:	0084303a 	nor	r2,zero,r2
  80eb5c:	1000561e 	bne	r2,zero,80ecb8 <__subdf3+0x7ac>
  80eb60:	89a3883a 	add	r17,r17,r6
  80eb64:	1945883a 	add	r2,r3,r5
  80eb68:	898d803a 	cmpltu	r6,r17,r6
  80eb6c:	3087883a 	add	r3,r6,r2
  80eb70:	4821883a 	mov	r16,r9
  80eb74:	003f0506 	br	80e78c <__alt_data_end+0xfff0e78c>
  80eb78:	10002b1e 	bne	r2,zero,80ec28 <__subdf3+0x71c>
  80eb7c:	2984b03a 	or	r2,r5,r6
  80eb80:	10008026 	beq	r2,zero,80ed84 <__subdf3+0x878>
  80eb84:	2807883a 	mov	r3,r5
  80eb88:	3023883a 	mov	r17,r6
  80eb8c:	3825883a 	mov	r18,r7
  80eb90:	0401ffc4 	movi	r16,2047
  80eb94:	003e7e06 	br	80e590 <__alt_data_end+0xfff0e590>
  80eb98:	3809883a 	mov	r4,r7
  80eb9c:	0011883a 	mov	r8,zero
  80eba0:	0005883a 	mov	r2,zero
  80eba4:	003ee306 	br	80e734 <__alt_data_end+0xfff0e734>
  80eba8:	1c62b03a 	or	r17,r3,r17
  80ebac:	8822c03a 	cmpne	r17,r17,zero
  80ebb0:	0005883a 	mov	r2,zero
  80ebb4:	003f8906 	br	80e9dc <__alt_data_end+0xfff0e9dc>
  80ebb8:	3809883a 	mov	r4,r7
  80ebbc:	4821883a 	mov	r16,r9
  80ebc0:	0011883a 	mov	r8,zero
  80ebc4:	0005883a 	mov	r2,zero
  80ebc8:	003eda06 	br	80e734 <__alt_data_end+0xfff0e734>
  80ebcc:	0101ffc4 	movi	r4,2047
  80ebd0:	49003b26 	beq	r9,r4,80ecc0 <__subdf3+0x7b4>
  80ebd4:	0085c83a 	sub	r2,zero,r2
  80ebd8:	18c02034 	orhi	r3,r3,128
  80ebdc:	01000e04 	movi	r4,56
  80ebe0:	20806e16 	blt	r4,r2,80ed9c <__subdf3+0x890>
  80ebe4:	010007c4 	movi	r4,31
  80ebe8:	20807716 	blt	r4,r2,80edc8 <__subdf3+0x8bc>
  80ebec:	01000804 	movi	r4,32
  80ebf0:	2089c83a 	sub	r4,r4,r2
  80ebf4:	1914983a 	sll	r10,r3,r4
  80ebf8:	8890d83a 	srl	r8,r17,r2
  80ebfc:	8908983a 	sll	r4,r17,r4
  80ec00:	1884d83a 	srl	r2,r3,r2
  80ec04:	5222b03a 	or	r17,r10,r8
  80ec08:	2006c03a 	cmpne	r3,r4,zero
  80ec0c:	88e2b03a 	or	r17,r17,r3
  80ec10:	89a3883a 	add	r17,r17,r6
  80ec14:	1145883a 	add	r2,r2,r5
  80ec18:	898d803a 	cmpltu	r6,r17,r6
  80ec1c:	3087883a 	add	r3,r6,r2
  80ec20:	4821883a 	mov	r16,r9
  80ec24:	003ed906 	br	80e78c <__alt_data_end+0xfff0e78c>
  80ec28:	2984b03a 	or	r2,r5,r6
  80ec2c:	10004226 	beq	r2,zero,80ed38 <__subdf3+0x82c>
  80ec30:	1808d0fa 	srli	r4,r3,3
  80ec34:	8822d0fa 	srli	r17,r17,3
  80ec38:	1806977a 	slli	r3,r3,29
  80ec3c:	2080022c 	andhi	r2,r4,8
  80ec40:	1c62b03a 	or	r17,r3,r17
  80ec44:	10000826 	beq	r2,zero,80ec68 <__subdf3+0x75c>
  80ec48:	2812d0fa 	srli	r9,r5,3
  80ec4c:	4880022c 	andhi	r2,r9,8
  80ec50:	1000051e 	bne	r2,zero,80ec68 <__subdf3+0x75c>
  80ec54:	300cd0fa 	srli	r6,r6,3
  80ec58:	2804977a 	slli	r2,r5,29
  80ec5c:	4809883a 	mov	r4,r9
  80ec60:	3825883a 	mov	r18,r7
  80ec64:	11a2b03a 	or	r17,r2,r6
  80ec68:	8806d77a 	srli	r3,r17,29
  80ec6c:	200890fa 	slli	r4,r4,3
  80ec70:	882290fa 	slli	r17,r17,3
  80ec74:	0401ffc4 	movi	r16,2047
  80ec78:	1906b03a 	or	r3,r3,r4
  80ec7c:	003e4406 	br	80e590 <__alt_data_end+0xfff0e590>
  80ec80:	2984b03a 	or	r2,r5,r6
  80ec84:	103e4226 	beq	r2,zero,80e590 <__alt_data_end+0xfff0e590>
  80ec88:	8989c83a 	sub	r4,r17,r6
  80ec8c:	8911803a 	cmpltu	r8,r17,r4
  80ec90:	1945c83a 	sub	r2,r3,r5
  80ec94:	1205c83a 	sub	r2,r2,r8
  80ec98:	1200202c 	andhi	r8,r2,128
  80ec9c:	403e9a26 	beq	r8,zero,80e708 <__alt_data_end+0xfff0e708>
  80eca0:	3463c83a 	sub	r17,r6,r17
  80eca4:	28c5c83a 	sub	r2,r5,r3
  80eca8:	344d803a 	cmpltu	r6,r6,r17
  80ecac:	1187c83a 	sub	r3,r2,r6
  80ecb0:	3825883a 	mov	r18,r7
  80ecb4:	003e3606 	br	80e590 <__alt_data_end+0xfff0e590>
  80ecb8:	0101ffc4 	movi	r4,2047
  80ecbc:	493fc71e 	bne	r9,r4,80ebdc <__alt_data_end+0xfff0ebdc>
  80ecc0:	2807883a 	mov	r3,r5
  80ecc4:	3023883a 	mov	r17,r6
  80ecc8:	4821883a 	mov	r16,r9
  80eccc:	003e3006 	br	80e590 <__alt_data_end+0xfff0e590>
  80ecd0:	10003626 	beq	r2,zero,80edac <__subdf3+0x8a0>
  80ecd4:	2984b03a 	or	r2,r5,r6
  80ecd8:	10001726 	beq	r2,zero,80ed38 <__subdf3+0x82c>
  80ecdc:	1808d0fa 	srli	r4,r3,3
  80ece0:	8822d0fa 	srli	r17,r17,3
  80ece4:	1806977a 	slli	r3,r3,29
  80ece8:	2080022c 	andhi	r2,r4,8
  80ecec:	1c62b03a 	or	r17,r3,r17
  80ecf0:	10000726 	beq	r2,zero,80ed10 <__subdf3+0x804>
  80ecf4:	2812d0fa 	srli	r9,r5,3
  80ecf8:	4880022c 	andhi	r2,r9,8
  80ecfc:	1000041e 	bne	r2,zero,80ed10 <__subdf3+0x804>
  80ed00:	300cd0fa 	srli	r6,r6,3
  80ed04:	2804977a 	slli	r2,r5,29
  80ed08:	4809883a 	mov	r4,r9
  80ed0c:	11a2b03a 	or	r17,r2,r6
  80ed10:	8806d77a 	srli	r3,r17,29
  80ed14:	200890fa 	slli	r4,r4,3
  80ed18:	882290fa 	slli	r17,r17,3
  80ed1c:	3825883a 	mov	r18,r7
  80ed20:	1906b03a 	or	r3,r3,r4
  80ed24:	0401ffc4 	movi	r16,2047
  80ed28:	003e1906 	br	80e590 <__alt_data_end+0xfff0e590>
  80ed2c:	000b883a 	mov	r5,zero
  80ed30:	0005883a 	mov	r2,zero
  80ed34:	003e2e06 	br	80e5f0 <__alt_data_end+0xfff0e5f0>
  80ed38:	0401ffc4 	movi	r16,2047
  80ed3c:	003e1406 	br	80e590 <__alt_data_end+0xfff0e590>
  80ed40:	0005883a 	mov	r2,zero
  80ed44:	003f7506 	br	80eb1c <__alt_data_end+0xfff0eb1c>
  80ed48:	0005883a 	mov	r2,zero
  80ed4c:	0009883a 	mov	r4,zero
  80ed50:	003e7806 	br	80e734 <__alt_data_end+0xfff0e734>
  80ed54:	123ff804 	addi	r8,r2,-32
  80ed58:	01000804 	movi	r4,32
  80ed5c:	1a10d83a 	srl	r8,r3,r8
  80ed60:	11002526 	beq	r2,r4,80edf8 <__subdf3+0x8ec>
  80ed64:	01001004 	movi	r4,64
  80ed68:	2085c83a 	sub	r2,r4,r2
  80ed6c:	1884983a 	sll	r2,r3,r2
  80ed70:	1444b03a 	or	r2,r2,r17
  80ed74:	1004c03a 	cmpne	r2,r2,zero
  80ed78:	40a2b03a 	or	r17,r8,r2
  80ed7c:	0005883a 	mov	r2,zero
  80ed80:	003f1606 	br	80e9dc <__alt_data_end+0xfff0e9dc>
  80ed84:	02000434 	movhi	r8,16
  80ed88:	0009883a 	mov	r4,zero
  80ed8c:	423fffc4 	addi	r8,r8,-1
  80ed90:	00bfffc4 	movi	r2,-1
  80ed94:	0401ffc4 	movi	r16,2047
  80ed98:	003e6606 	br	80e734 <__alt_data_end+0xfff0e734>
  80ed9c:	1c62b03a 	or	r17,r3,r17
  80eda0:	8822c03a 	cmpne	r17,r17,zero
  80eda4:	0005883a 	mov	r2,zero
  80eda8:	003f9906 	br	80ec10 <__alt_data_end+0xfff0ec10>
  80edac:	2807883a 	mov	r3,r5
  80edb0:	3023883a 	mov	r17,r6
  80edb4:	0401ffc4 	movi	r16,2047
  80edb8:	003df506 	br	80e590 <__alt_data_end+0xfff0e590>
  80edbc:	2807883a 	mov	r3,r5
  80edc0:	3023883a 	mov	r17,r6
  80edc4:	003df206 	br	80e590 <__alt_data_end+0xfff0e590>
  80edc8:	123ff804 	addi	r8,r2,-32
  80edcc:	01000804 	movi	r4,32
  80edd0:	1a10d83a 	srl	r8,r3,r8
  80edd4:	11000a26 	beq	r2,r4,80ee00 <__subdf3+0x8f4>
  80edd8:	01001004 	movi	r4,64
  80eddc:	2085c83a 	sub	r2,r4,r2
  80ede0:	1884983a 	sll	r2,r3,r2
  80ede4:	1444b03a 	or	r2,r2,r17
  80ede8:	1004c03a 	cmpne	r2,r2,zero
  80edec:	40a2b03a 	or	r17,r8,r2
  80edf0:	0005883a 	mov	r2,zero
  80edf4:	003f8606 	br	80ec10 <__alt_data_end+0xfff0ec10>
  80edf8:	0005883a 	mov	r2,zero
  80edfc:	003fdc06 	br	80ed70 <__alt_data_end+0xfff0ed70>
  80ee00:	0005883a 	mov	r2,zero
  80ee04:	003ff706 	br	80ede4 <__alt_data_end+0xfff0ede4>

0080ee08 <__fixdfsi>:
  80ee08:	280cd53a 	srli	r6,r5,20
  80ee0c:	00c00434 	movhi	r3,16
  80ee10:	18ffffc4 	addi	r3,r3,-1
  80ee14:	3181ffcc 	andi	r6,r6,2047
  80ee18:	01c0ff84 	movi	r7,1022
  80ee1c:	28c6703a 	and	r3,r5,r3
  80ee20:	280ad7fa 	srli	r5,r5,31
  80ee24:	3980120e 	bge	r7,r6,80ee70 <__fixdfsi+0x68>
  80ee28:	00810744 	movi	r2,1053
  80ee2c:	11800c16 	blt	r2,r6,80ee60 <__fixdfsi+0x58>
  80ee30:	00810cc4 	movi	r2,1075
  80ee34:	1185c83a 	sub	r2,r2,r6
  80ee38:	01c007c4 	movi	r7,31
  80ee3c:	18c00434 	orhi	r3,r3,16
  80ee40:	38800d16 	blt	r7,r2,80ee78 <__fixdfsi+0x70>
  80ee44:	31befb44 	addi	r6,r6,-1043
  80ee48:	2084d83a 	srl	r2,r4,r2
  80ee4c:	1986983a 	sll	r3,r3,r6
  80ee50:	1884b03a 	or	r2,r3,r2
  80ee54:	28000726 	beq	r5,zero,80ee74 <__fixdfsi+0x6c>
  80ee58:	0085c83a 	sub	r2,zero,r2
  80ee5c:	f800283a 	ret
  80ee60:	00a00034 	movhi	r2,32768
  80ee64:	10bfffc4 	addi	r2,r2,-1
  80ee68:	2885883a 	add	r2,r5,r2
  80ee6c:	f800283a 	ret
  80ee70:	0005883a 	mov	r2,zero
  80ee74:	f800283a 	ret
  80ee78:	008104c4 	movi	r2,1043
  80ee7c:	1185c83a 	sub	r2,r2,r6
  80ee80:	1884d83a 	srl	r2,r3,r2
  80ee84:	003ff306 	br	80ee54 <__alt_data_end+0xfff0ee54>

0080ee88 <__floatsidf>:
  80ee88:	defffd04 	addi	sp,sp,-12
  80ee8c:	dfc00215 	stw	ra,8(sp)
  80ee90:	dc400115 	stw	r17,4(sp)
  80ee94:	dc000015 	stw	r16,0(sp)
  80ee98:	20002b26 	beq	r4,zero,80ef48 <__floatsidf+0xc0>
  80ee9c:	2023883a 	mov	r17,r4
  80eea0:	2020d7fa 	srli	r16,r4,31
  80eea4:	20002d16 	blt	r4,zero,80ef5c <__floatsidf+0xd4>
  80eea8:	8809883a 	mov	r4,r17
  80eeac:	080f21c0 	call	80f21c <__clzsi2>
  80eeb0:	01410784 	movi	r5,1054
  80eeb4:	288bc83a 	sub	r5,r5,r2
  80eeb8:	01010cc4 	movi	r4,1075
  80eebc:	2149c83a 	sub	r4,r4,r5
  80eec0:	00c007c4 	movi	r3,31
  80eec4:	1900160e 	bge	r3,r4,80ef20 <__floatsidf+0x98>
  80eec8:	00c104c4 	movi	r3,1043
  80eecc:	1947c83a 	sub	r3,r3,r5
  80eed0:	88c6983a 	sll	r3,r17,r3
  80eed4:	00800434 	movhi	r2,16
  80eed8:	10bfffc4 	addi	r2,r2,-1
  80eedc:	1886703a 	and	r3,r3,r2
  80eee0:	2941ffcc 	andi	r5,r5,2047
  80eee4:	800d883a 	mov	r6,r16
  80eee8:	0005883a 	mov	r2,zero
  80eeec:	280a953a 	slli	r5,r5,20
  80eef0:	31803fcc 	andi	r6,r6,255
  80eef4:	01000434 	movhi	r4,16
  80eef8:	300c97fa 	slli	r6,r6,31
  80eefc:	213fffc4 	addi	r4,r4,-1
  80ef00:	1906703a 	and	r3,r3,r4
  80ef04:	1946b03a 	or	r3,r3,r5
  80ef08:	1986b03a 	or	r3,r3,r6
  80ef0c:	dfc00217 	ldw	ra,8(sp)
  80ef10:	dc400117 	ldw	r17,4(sp)
  80ef14:	dc000017 	ldw	r16,0(sp)
  80ef18:	dec00304 	addi	sp,sp,12
  80ef1c:	f800283a 	ret
  80ef20:	00c002c4 	movi	r3,11
  80ef24:	1887c83a 	sub	r3,r3,r2
  80ef28:	88c6d83a 	srl	r3,r17,r3
  80ef2c:	8904983a 	sll	r2,r17,r4
  80ef30:	01000434 	movhi	r4,16
  80ef34:	213fffc4 	addi	r4,r4,-1
  80ef38:	2941ffcc 	andi	r5,r5,2047
  80ef3c:	1906703a 	and	r3,r3,r4
  80ef40:	800d883a 	mov	r6,r16
  80ef44:	003fe906 	br	80eeec <__alt_data_end+0xfff0eeec>
  80ef48:	000d883a 	mov	r6,zero
  80ef4c:	000b883a 	mov	r5,zero
  80ef50:	0007883a 	mov	r3,zero
  80ef54:	0005883a 	mov	r2,zero
  80ef58:	003fe406 	br	80eeec <__alt_data_end+0xfff0eeec>
  80ef5c:	0123c83a 	sub	r17,zero,r4
  80ef60:	003fd106 	br	80eea8 <__alt_data_end+0xfff0eea8>

0080ef64 <__extendsfdf2>:
  80ef64:	200ad5fa 	srli	r5,r4,23
  80ef68:	defffd04 	addi	sp,sp,-12
  80ef6c:	dc400115 	stw	r17,4(sp)
  80ef70:	29403fcc 	andi	r5,r5,255
  80ef74:	29800044 	addi	r6,r5,1
  80ef78:	04402034 	movhi	r17,128
  80ef7c:	dc000015 	stw	r16,0(sp)
  80ef80:	8c7fffc4 	addi	r17,r17,-1
  80ef84:	dfc00215 	stw	ra,8(sp)
  80ef88:	31803fcc 	andi	r6,r6,255
  80ef8c:	00800044 	movi	r2,1
  80ef90:	8922703a 	and	r17,r17,r4
  80ef94:	2020d7fa 	srli	r16,r4,31
  80ef98:	1180110e 	bge	r2,r6,80efe0 <__extendsfdf2+0x7c>
  80ef9c:	880cd0fa 	srli	r6,r17,3
  80efa0:	8822977a 	slli	r17,r17,29
  80efa4:	2940e004 	addi	r5,r5,896
  80efa8:	2941ffcc 	andi	r5,r5,2047
  80efac:	2804953a 	slli	r2,r5,20
  80efb0:	01400434 	movhi	r5,16
  80efb4:	800697fa 	slli	r3,r16,31
  80efb8:	297fffc4 	addi	r5,r5,-1
  80efbc:	314a703a 	and	r5,r6,r5
  80efc0:	288ab03a 	or	r5,r5,r2
  80efc4:	28c6b03a 	or	r3,r5,r3
  80efc8:	8805883a 	mov	r2,r17
  80efcc:	dfc00217 	ldw	ra,8(sp)
  80efd0:	dc400117 	ldw	r17,4(sp)
  80efd4:	dc000017 	ldw	r16,0(sp)
  80efd8:	dec00304 	addi	sp,sp,12
  80efdc:	f800283a 	ret
  80efe0:	2800111e 	bne	r5,zero,80f028 <__extendsfdf2+0xc4>
  80efe4:	88001c26 	beq	r17,zero,80f058 <__extendsfdf2+0xf4>
  80efe8:	8809883a 	mov	r4,r17
  80efec:	080f21c0 	call	80f21c <__clzsi2>
  80eff0:	00c00284 	movi	r3,10
  80eff4:	18801b16 	blt	r3,r2,80f064 <__extendsfdf2+0x100>
  80eff8:	018002c4 	movi	r6,11
  80effc:	308dc83a 	sub	r6,r6,r2
  80f000:	11000544 	addi	r4,r2,21
  80f004:	8986d83a 	srl	r3,r17,r6
  80f008:	8922983a 	sll	r17,r17,r4
  80f00c:	0180e244 	movi	r6,905
  80f010:	01400434 	movhi	r5,16
  80f014:	3085c83a 	sub	r2,r6,r2
  80f018:	297fffc4 	addi	r5,r5,-1
  80f01c:	194c703a 	and	r6,r3,r5
  80f020:	1141ffcc 	andi	r5,r2,2047
  80f024:	003fe006 	br	80efa8 <__alt_data_end+0xfff0efa8>
  80f028:	88000826 	beq	r17,zero,80f04c <__extendsfdf2+0xe8>
  80f02c:	880cd0fa 	srli	r6,r17,3
  80f030:	00800434 	movhi	r2,16
  80f034:	10bfffc4 	addi	r2,r2,-1
  80f038:	31800234 	orhi	r6,r6,8
  80f03c:	8822977a 	slli	r17,r17,29
  80f040:	308c703a 	and	r6,r6,r2
  80f044:	0141ffc4 	movi	r5,2047
  80f048:	003fd706 	br	80efa8 <__alt_data_end+0xfff0efa8>
  80f04c:	0141ffc4 	movi	r5,2047
  80f050:	000d883a 	mov	r6,zero
  80f054:	003fd406 	br	80efa8 <__alt_data_end+0xfff0efa8>
  80f058:	000b883a 	mov	r5,zero
  80f05c:	000d883a 	mov	r6,zero
  80f060:	003fd106 	br	80efa8 <__alt_data_end+0xfff0efa8>
  80f064:	11bffd44 	addi	r6,r2,-11
  80f068:	8986983a 	sll	r3,r17,r6
  80f06c:	0023883a 	mov	r17,zero
  80f070:	003fe606 	br	80f00c <__alt_data_end+0xfff0f00c>

0080f074 <__truncdfsf2>:
  80f074:	2810d53a 	srli	r8,r5,20
  80f078:	01c00434 	movhi	r7,16
  80f07c:	39ffffc4 	addi	r7,r7,-1
  80f080:	29ce703a 	and	r7,r5,r7
  80f084:	4201ffcc 	andi	r8,r8,2047
  80f088:	380e90fa 	slli	r7,r7,3
  80f08c:	200cd77a 	srli	r6,r4,29
  80f090:	42400044 	addi	r9,r8,1
  80f094:	4a41ffcc 	andi	r9,r9,2047
  80f098:	00c00044 	movi	r3,1
  80f09c:	280ad7fa 	srli	r5,r5,31
  80f0a0:	31ceb03a 	or	r7,r6,r7
  80f0a4:	200490fa 	slli	r2,r4,3
  80f0a8:	1a40230e 	bge	r3,r9,80f138 <__truncdfsf2+0xc4>
  80f0ac:	40ff2004 	addi	r3,r8,-896
  80f0b0:	01803f84 	movi	r6,254
  80f0b4:	30c01516 	blt	r6,r3,80f10c <__truncdfsf2+0x98>
  80f0b8:	00c0380e 	bge	zero,r3,80f19c <__truncdfsf2+0x128>
  80f0bc:	200c91ba 	slli	r6,r4,6
  80f0c0:	380e90fa 	slli	r7,r7,3
  80f0c4:	1004d77a 	srli	r2,r2,29
  80f0c8:	300cc03a 	cmpne	r6,r6,zero
  80f0cc:	31ccb03a 	or	r6,r6,r7
  80f0d0:	308cb03a 	or	r6,r6,r2
  80f0d4:	308001cc 	andi	r2,r6,7
  80f0d8:	10000426 	beq	r2,zero,80f0ec <__truncdfsf2+0x78>
  80f0dc:	308003cc 	andi	r2,r6,15
  80f0e0:	01000104 	movi	r4,4
  80f0e4:	11000126 	beq	r2,r4,80f0ec <__truncdfsf2+0x78>
  80f0e8:	31800104 	addi	r6,r6,4
  80f0ec:	3081002c 	andhi	r2,r6,1024
  80f0f0:	10001626 	beq	r2,zero,80f14c <__truncdfsf2+0xd8>
  80f0f4:	18c00044 	addi	r3,r3,1
  80f0f8:	00803fc4 	movi	r2,255
  80f0fc:	18800326 	beq	r3,r2,80f10c <__truncdfsf2+0x98>
  80f100:	300c91ba 	slli	r6,r6,6
  80f104:	300cd27a 	srli	r6,r6,9
  80f108:	00000206 	br	80f114 <__truncdfsf2+0xa0>
  80f10c:	00ffffc4 	movi	r3,-1
  80f110:	000d883a 	mov	r6,zero
  80f114:	18c03fcc 	andi	r3,r3,255
  80f118:	180895fa 	slli	r4,r3,23
  80f11c:	00c02034 	movhi	r3,128
  80f120:	280a97fa 	slli	r5,r5,31
  80f124:	18ffffc4 	addi	r3,r3,-1
  80f128:	30c6703a 	and	r3,r6,r3
  80f12c:	1906b03a 	or	r3,r3,r4
  80f130:	1944b03a 	or	r2,r3,r5
  80f134:	f800283a 	ret
  80f138:	40000b1e 	bne	r8,zero,80f168 <__truncdfsf2+0xf4>
  80f13c:	388cb03a 	or	r6,r7,r2
  80f140:	0007883a 	mov	r3,zero
  80f144:	30000426 	beq	r6,zero,80f158 <__truncdfsf2+0xe4>
  80f148:	01800144 	movi	r6,5
  80f14c:	00803fc4 	movi	r2,255
  80f150:	300cd0fa 	srli	r6,r6,3
  80f154:	18800a26 	beq	r3,r2,80f180 <__truncdfsf2+0x10c>
  80f158:	00802034 	movhi	r2,128
  80f15c:	10bfffc4 	addi	r2,r2,-1
  80f160:	308c703a 	and	r6,r6,r2
  80f164:	003feb06 	br	80f114 <__alt_data_end+0xfff0f114>
  80f168:	3888b03a 	or	r4,r7,r2
  80f16c:	203fe726 	beq	r4,zero,80f10c <__alt_data_end+0xfff0f10c>
  80f170:	380c90fa 	slli	r6,r7,3
  80f174:	00c03fc4 	movi	r3,255
  80f178:	31808034 	orhi	r6,r6,512
  80f17c:	003fd506 	br	80f0d4 <__alt_data_end+0xfff0f0d4>
  80f180:	303fe226 	beq	r6,zero,80f10c <__alt_data_end+0xfff0f10c>
  80f184:	00802034 	movhi	r2,128
  80f188:	31801034 	orhi	r6,r6,64
  80f18c:	10bfffc4 	addi	r2,r2,-1
  80f190:	00ffffc4 	movi	r3,-1
  80f194:	308c703a 	and	r6,r6,r2
  80f198:	003fde06 	br	80f114 <__alt_data_end+0xfff0f114>
  80f19c:	013ffa44 	movi	r4,-23
  80f1a0:	19000e16 	blt	r3,r4,80f1dc <__truncdfsf2+0x168>
  80f1a4:	01000784 	movi	r4,30
  80f1a8:	20c9c83a 	sub	r4,r4,r3
  80f1ac:	018007c4 	movi	r6,31
  80f1b0:	39c02034 	orhi	r7,r7,128
  80f1b4:	31000b16 	blt	r6,r4,80f1e4 <__truncdfsf2+0x170>
  80f1b8:	423f2084 	addi	r8,r8,-894
  80f1bc:	120c983a 	sll	r6,r2,r8
  80f1c0:	3a0e983a 	sll	r7,r7,r8
  80f1c4:	1104d83a 	srl	r2,r2,r4
  80f1c8:	300cc03a 	cmpne	r6,r6,zero
  80f1cc:	31ceb03a 	or	r7,r6,r7
  80f1d0:	388cb03a 	or	r6,r7,r2
  80f1d4:	0007883a 	mov	r3,zero
  80f1d8:	003fbe06 	br	80f0d4 <__alt_data_end+0xfff0f0d4>
  80f1dc:	0007883a 	mov	r3,zero
  80f1e0:	003fd906 	br	80f148 <__alt_data_end+0xfff0f148>
  80f1e4:	01bfff84 	movi	r6,-2
  80f1e8:	30cdc83a 	sub	r6,r6,r3
  80f1ec:	00c00804 	movi	r3,32
  80f1f0:	398cd83a 	srl	r6,r7,r6
  80f1f4:	20c00726 	beq	r4,r3,80f214 <__truncdfsf2+0x1a0>
  80f1f8:	423f2884 	addi	r8,r8,-862
  80f1fc:	3a0e983a 	sll	r7,r7,r8
  80f200:	3884b03a 	or	r2,r7,r2
  80f204:	1004c03a 	cmpne	r2,r2,zero
  80f208:	118cb03a 	or	r6,r2,r6
  80f20c:	0007883a 	mov	r3,zero
  80f210:	003fb006 	br	80f0d4 <__alt_data_end+0xfff0f0d4>
  80f214:	000f883a 	mov	r7,zero
  80f218:	003ff906 	br	80f200 <__alt_data_end+0xfff0f200>

0080f21c <__clzsi2>:
  80f21c:	00bfffd4 	movui	r2,65535
  80f220:	11000536 	bltu	r2,r4,80f238 <__clzsi2+0x1c>
  80f224:	00803fc4 	movi	r2,255
  80f228:	11000f36 	bltu	r2,r4,80f268 <__clzsi2+0x4c>
  80f22c:	00800804 	movi	r2,32
  80f230:	0007883a 	mov	r3,zero
  80f234:	00000506 	br	80f24c <__clzsi2+0x30>
  80f238:	00804034 	movhi	r2,256
  80f23c:	10bfffc4 	addi	r2,r2,-1
  80f240:	11000c2e 	bgeu	r2,r4,80f274 <__clzsi2+0x58>
  80f244:	00800204 	movi	r2,8
  80f248:	00c00604 	movi	r3,24
  80f24c:	20c8d83a 	srl	r4,r4,r3
  80f250:	00c020b4 	movhi	r3,130
  80f254:	18e6ec04 	addi	r3,r3,-25680
  80f258:	1909883a 	add	r4,r3,r4
  80f25c:	20c00003 	ldbu	r3,0(r4)
  80f260:	10c5c83a 	sub	r2,r2,r3
  80f264:	f800283a 	ret
  80f268:	00800604 	movi	r2,24
  80f26c:	00c00204 	movi	r3,8
  80f270:	003ff606 	br	80f24c <__alt_data_end+0xfff0f24c>
  80f274:	00800404 	movi	r2,16
  80f278:	1007883a 	mov	r3,r2
  80f27c:	003ff306 	br	80f24c <__alt_data_end+0xfff0f24c>

0080f280 <__divsi3>:
  80f280:	20001b16 	blt	r4,zero,80f2f0 <__divsi3+0x70>
  80f284:	000f883a 	mov	r7,zero
  80f288:	28001616 	blt	r5,zero,80f2e4 <__divsi3+0x64>
  80f28c:	200d883a 	mov	r6,r4
  80f290:	29001a2e 	bgeu	r5,r4,80f2fc <__divsi3+0x7c>
  80f294:	00800804 	movi	r2,32
  80f298:	00c00044 	movi	r3,1
  80f29c:	00000106 	br	80f2a4 <__divsi3+0x24>
  80f2a0:	10000d26 	beq	r2,zero,80f2d8 <__divsi3+0x58>
  80f2a4:	294b883a 	add	r5,r5,r5
  80f2a8:	10bfffc4 	addi	r2,r2,-1
  80f2ac:	18c7883a 	add	r3,r3,r3
  80f2b0:	293ffb36 	bltu	r5,r4,80f2a0 <__alt_data_end+0xfff0f2a0>
  80f2b4:	0005883a 	mov	r2,zero
  80f2b8:	18000726 	beq	r3,zero,80f2d8 <__divsi3+0x58>
  80f2bc:	0005883a 	mov	r2,zero
  80f2c0:	31400236 	bltu	r6,r5,80f2cc <__divsi3+0x4c>
  80f2c4:	314dc83a 	sub	r6,r6,r5
  80f2c8:	10c4b03a 	or	r2,r2,r3
  80f2cc:	1806d07a 	srli	r3,r3,1
  80f2d0:	280ad07a 	srli	r5,r5,1
  80f2d4:	183ffa1e 	bne	r3,zero,80f2c0 <__alt_data_end+0xfff0f2c0>
  80f2d8:	38000126 	beq	r7,zero,80f2e0 <__divsi3+0x60>
  80f2dc:	0085c83a 	sub	r2,zero,r2
  80f2e0:	f800283a 	ret
  80f2e4:	014bc83a 	sub	r5,zero,r5
  80f2e8:	39c0005c 	xori	r7,r7,1
  80f2ec:	003fe706 	br	80f28c <__alt_data_end+0xfff0f28c>
  80f2f0:	0109c83a 	sub	r4,zero,r4
  80f2f4:	01c00044 	movi	r7,1
  80f2f8:	003fe306 	br	80f288 <__alt_data_end+0xfff0f288>
  80f2fc:	00c00044 	movi	r3,1
  80f300:	003fee06 	br	80f2bc <__alt_data_end+0xfff0f2bc>

0080f304 <__modsi3>:
  80f304:	20001716 	blt	r4,zero,80f364 <__modsi3+0x60>
  80f308:	000f883a 	mov	r7,zero
  80f30c:	2005883a 	mov	r2,r4
  80f310:	28001216 	blt	r5,zero,80f35c <__modsi3+0x58>
  80f314:	2900162e 	bgeu	r5,r4,80f370 <__modsi3+0x6c>
  80f318:	01800804 	movi	r6,32
  80f31c:	00c00044 	movi	r3,1
  80f320:	00000106 	br	80f328 <__modsi3+0x24>
  80f324:	30000a26 	beq	r6,zero,80f350 <__modsi3+0x4c>
  80f328:	294b883a 	add	r5,r5,r5
  80f32c:	31bfffc4 	addi	r6,r6,-1
  80f330:	18c7883a 	add	r3,r3,r3
  80f334:	293ffb36 	bltu	r5,r4,80f324 <__alt_data_end+0xfff0f324>
  80f338:	18000526 	beq	r3,zero,80f350 <__modsi3+0x4c>
  80f33c:	1806d07a 	srli	r3,r3,1
  80f340:	11400136 	bltu	r2,r5,80f348 <__modsi3+0x44>
  80f344:	1145c83a 	sub	r2,r2,r5
  80f348:	280ad07a 	srli	r5,r5,1
  80f34c:	183ffb1e 	bne	r3,zero,80f33c <__alt_data_end+0xfff0f33c>
  80f350:	38000126 	beq	r7,zero,80f358 <__modsi3+0x54>
  80f354:	0085c83a 	sub	r2,zero,r2
  80f358:	f800283a 	ret
  80f35c:	014bc83a 	sub	r5,zero,r5
  80f360:	003fec06 	br	80f314 <__alt_data_end+0xfff0f314>
  80f364:	0109c83a 	sub	r4,zero,r4
  80f368:	01c00044 	movi	r7,1
  80f36c:	003fe706 	br	80f30c <__alt_data_end+0xfff0f30c>
  80f370:	00c00044 	movi	r3,1
  80f374:	003ff106 	br	80f33c <__alt_data_end+0xfff0f33c>

0080f378 <__udivsi3>:
  80f378:	200d883a 	mov	r6,r4
  80f37c:	2900152e 	bgeu	r5,r4,80f3d4 <__udivsi3+0x5c>
  80f380:	28001416 	blt	r5,zero,80f3d4 <__udivsi3+0x5c>
  80f384:	00800804 	movi	r2,32
  80f388:	00c00044 	movi	r3,1
  80f38c:	00000206 	br	80f398 <__udivsi3+0x20>
  80f390:	10000e26 	beq	r2,zero,80f3cc <__udivsi3+0x54>
  80f394:	28000516 	blt	r5,zero,80f3ac <__udivsi3+0x34>
  80f398:	294b883a 	add	r5,r5,r5
  80f39c:	10bfffc4 	addi	r2,r2,-1
  80f3a0:	18c7883a 	add	r3,r3,r3
  80f3a4:	293ffa36 	bltu	r5,r4,80f390 <__alt_data_end+0xfff0f390>
  80f3a8:	18000826 	beq	r3,zero,80f3cc <__udivsi3+0x54>
  80f3ac:	0005883a 	mov	r2,zero
  80f3b0:	31400236 	bltu	r6,r5,80f3bc <__udivsi3+0x44>
  80f3b4:	314dc83a 	sub	r6,r6,r5
  80f3b8:	10c4b03a 	or	r2,r2,r3
  80f3bc:	1806d07a 	srli	r3,r3,1
  80f3c0:	280ad07a 	srli	r5,r5,1
  80f3c4:	183ffa1e 	bne	r3,zero,80f3b0 <__alt_data_end+0xfff0f3b0>
  80f3c8:	f800283a 	ret
  80f3cc:	0005883a 	mov	r2,zero
  80f3d0:	f800283a 	ret
  80f3d4:	00c00044 	movi	r3,1
  80f3d8:	003ff406 	br	80f3ac <__alt_data_end+0xfff0f3ac>

0080f3dc <__umodsi3>:
  80f3dc:	2005883a 	mov	r2,r4
  80f3e0:	2900122e 	bgeu	r5,r4,80f42c <__umodsi3+0x50>
  80f3e4:	28001116 	blt	r5,zero,80f42c <__umodsi3+0x50>
  80f3e8:	01800804 	movi	r6,32
  80f3ec:	00c00044 	movi	r3,1
  80f3f0:	00000206 	br	80f3fc <__umodsi3+0x20>
  80f3f4:	30000c26 	beq	r6,zero,80f428 <__umodsi3+0x4c>
  80f3f8:	28000516 	blt	r5,zero,80f410 <__umodsi3+0x34>
  80f3fc:	294b883a 	add	r5,r5,r5
  80f400:	31bfffc4 	addi	r6,r6,-1
  80f404:	18c7883a 	add	r3,r3,r3
  80f408:	293ffa36 	bltu	r5,r4,80f3f4 <__alt_data_end+0xfff0f3f4>
  80f40c:	18000626 	beq	r3,zero,80f428 <__umodsi3+0x4c>
  80f410:	1806d07a 	srli	r3,r3,1
  80f414:	11400136 	bltu	r2,r5,80f41c <__umodsi3+0x40>
  80f418:	1145c83a 	sub	r2,r2,r5
  80f41c:	280ad07a 	srli	r5,r5,1
  80f420:	183ffb1e 	bne	r3,zero,80f410 <__alt_data_end+0xfff0f410>
  80f424:	f800283a 	ret
  80f428:	f800283a 	ret
  80f42c:	00c00044 	movi	r3,1
  80f430:	003ff706 	br	80f410 <__alt_data_end+0xfff0f410>

0080f434 <__errno>:
  80f434:	008020b4 	movhi	r2,130
  80f438:	10ad4a04 	addi	r2,r2,-19160
  80f43c:	10800017 	ldw	r2,0(r2)
  80f440:	f800283a 	ret

0080f444 <memcpy>:
  80f444:	defffd04 	addi	sp,sp,-12
  80f448:	dfc00215 	stw	ra,8(sp)
  80f44c:	dc400115 	stw	r17,4(sp)
  80f450:	dc000015 	stw	r16,0(sp)
  80f454:	00c003c4 	movi	r3,15
  80f458:	2005883a 	mov	r2,r4
  80f45c:	1980452e 	bgeu	r3,r6,80f574 <memcpy+0x130>
  80f460:	2906b03a 	or	r3,r5,r4
  80f464:	18c000cc 	andi	r3,r3,3
  80f468:	1800441e 	bne	r3,zero,80f57c <memcpy+0x138>
  80f46c:	347ffc04 	addi	r17,r6,-16
  80f470:	8822d13a 	srli	r17,r17,4
  80f474:	28c00104 	addi	r3,r5,4
  80f478:	23400104 	addi	r13,r4,4
  80f47c:	8820913a 	slli	r16,r17,4
  80f480:	2b000204 	addi	r12,r5,8
  80f484:	22c00204 	addi	r11,r4,8
  80f488:	84000504 	addi	r16,r16,20
  80f48c:	2a800304 	addi	r10,r5,12
  80f490:	22400304 	addi	r9,r4,12
  80f494:	2c21883a 	add	r16,r5,r16
  80f498:	2811883a 	mov	r8,r5
  80f49c:	200f883a 	mov	r7,r4
  80f4a0:	41000017 	ldw	r4,0(r8)
  80f4a4:	1fc00017 	ldw	ra,0(r3)
  80f4a8:	63c00017 	ldw	r15,0(r12)
  80f4ac:	39000015 	stw	r4,0(r7)
  80f4b0:	53800017 	ldw	r14,0(r10)
  80f4b4:	6fc00015 	stw	ra,0(r13)
  80f4b8:	5bc00015 	stw	r15,0(r11)
  80f4bc:	4b800015 	stw	r14,0(r9)
  80f4c0:	18c00404 	addi	r3,r3,16
  80f4c4:	39c00404 	addi	r7,r7,16
  80f4c8:	42000404 	addi	r8,r8,16
  80f4cc:	6b400404 	addi	r13,r13,16
  80f4d0:	63000404 	addi	r12,r12,16
  80f4d4:	5ac00404 	addi	r11,r11,16
  80f4d8:	52800404 	addi	r10,r10,16
  80f4dc:	4a400404 	addi	r9,r9,16
  80f4e0:	1c3fef1e 	bne	r3,r16,80f4a0 <__alt_data_end+0xfff0f4a0>
  80f4e4:	89c00044 	addi	r7,r17,1
  80f4e8:	380e913a 	slli	r7,r7,4
  80f4ec:	310003cc 	andi	r4,r6,15
  80f4f0:	02c000c4 	movi	r11,3
  80f4f4:	11c7883a 	add	r3,r2,r7
  80f4f8:	29cb883a 	add	r5,r5,r7
  80f4fc:	5900212e 	bgeu	r11,r4,80f584 <memcpy+0x140>
  80f500:	1813883a 	mov	r9,r3
  80f504:	2811883a 	mov	r8,r5
  80f508:	200f883a 	mov	r7,r4
  80f50c:	42800017 	ldw	r10,0(r8)
  80f510:	4a400104 	addi	r9,r9,4
  80f514:	39ffff04 	addi	r7,r7,-4
  80f518:	4abfff15 	stw	r10,-4(r9)
  80f51c:	42000104 	addi	r8,r8,4
  80f520:	59fffa36 	bltu	r11,r7,80f50c <__alt_data_end+0xfff0f50c>
  80f524:	213fff04 	addi	r4,r4,-4
  80f528:	2008d0ba 	srli	r4,r4,2
  80f52c:	318000cc 	andi	r6,r6,3
  80f530:	21000044 	addi	r4,r4,1
  80f534:	2109883a 	add	r4,r4,r4
  80f538:	2109883a 	add	r4,r4,r4
  80f53c:	1907883a 	add	r3,r3,r4
  80f540:	290b883a 	add	r5,r5,r4
  80f544:	30000626 	beq	r6,zero,80f560 <memcpy+0x11c>
  80f548:	198d883a 	add	r6,r3,r6
  80f54c:	29c00003 	ldbu	r7,0(r5)
  80f550:	18c00044 	addi	r3,r3,1
  80f554:	29400044 	addi	r5,r5,1
  80f558:	19ffffc5 	stb	r7,-1(r3)
  80f55c:	19bffb1e 	bne	r3,r6,80f54c <__alt_data_end+0xfff0f54c>
  80f560:	dfc00217 	ldw	ra,8(sp)
  80f564:	dc400117 	ldw	r17,4(sp)
  80f568:	dc000017 	ldw	r16,0(sp)
  80f56c:	dec00304 	addi	sp,sp,12
  80f570:	f800283a 	ret
  80f574:	2007883a 	mov	r3,r4
  80f578:	003ff206 	br	80f544 <__alt_data_end+0xfff0f544>
  80f57c:	2007883a 	mov	r3,r4
  80f580:	003ff106 	br	80f548 <__alt_data_end+0xfff0f548>
  80f584:	200d883a 	mov	r6,r4
  80f588:	003fee06 	br	80f544 <__alt_data_end+0xfff0f544>

0080f58c <memset>:
  80f58c:	20c000cc 	andi	r3,r4,3
  80f590:	2005883a 	mov	r2,r4
  80f594:	18004426 	beq	r3,zero,80f6a8 <memset+0x11c>
  80f598:	31ffffc4 	addi	r7,r6,-1
  80f59c:	30004026 	beq	r6,zero,80f6a0 <memset+0x114>
  80f5a0:	2813883a 	mov	r9,r5
  80f5a4:	200d883a 	mov	r6,r4
  80f5a8:	2007883a 	mov	r3,r4
  80f5ac:	00000406 	br	80f5c0 <memset+0x34>
  80f5b0:	3a3fffc4 	addi	r8,r7,-1
  80f5b4:	31800044 	addi	r6,r6,1
  80f5b8:	38003926 	beq	r7,zero,80f6a0 <memset+0x114>
  80f5bc:	400f883a 	mov	r7,r8
  80f5c0:	18c00044 	addi	r3,r3,1
  80f5c4:	32400005 	stb	r9,0(r6)
  80f5c8:	1a0000cc 	andi	r8,r3,3
  80f5cc:	403ff81e 	bne	r8,zero,80f5b0 <__alt_data_end+0xfff0f5b0>
  80f5d0:	010000c4 	movi	r4,3
  80f5d4:	21c02d2e 	bgeu	r4,r7,80f68c <memset+0x100>
  80f5d8:	29003fcc 	andi	r4,r5,255
  80f5dc:	200c923a 	slli	r6,r4,8
  80f5e0:	3108b03a 	or	r4,r6,r4
  80f5e4:	200c943a 	slli	r6,r4,16
  80f5e8:	218cb03a 	or	r6,r4,r6
  80f5ec:	010003c4 	movi	r4,15
  80f5f0:	21c0182e 	bgeu	r4,r7,80f654 <memset+0xc8>
  80f5f4:	3b3ffc04 	addi	r12,r7,-16
  80f5f8:	6018d13a 	srli	r12,r12,4
  80f5fc:	1a000104 	addi	r8,r3,4
  80f600:	1ac00204 	addi	r11,r3,8
  80f604:	6008913a 	slli	r4,r12,4
  80f608:	1a800304 	addi	r10,r3,12
  80f60c:	1813883a 	mov	r9,r3
  80f610:	21000504 	addi	r4,r4,20
  80f614:	1909883a 	add	r4,r3,r4
  80f618:	49800015 	stw	r6,0(r9)
  80f61c:	41800015 	stw	r6,0(r8)
  80f620:	59800015 	stw	r6,0(r11)
  80f624:	51800015 	stw	r6,0(r10)
  80f628:	42000404 	addi	r8,r8,16
  80f62c:	4a400404 	addi	r9,r9,16
  80f630:	5ac00404 	addi	r11,r11,16
  80f634:	52800404 	addi	r10,r10,16
  80f638:	413ff71e 	bne	r8,r4,80f618 <__alt_data_end+0xfff0f618>
  80f63c:	63000044 	addi	r12,r12,1
  80f640:	6018913a 	slli	r12,r12,4
  80f644:	39c003cc 	andi	r7,r7,15
  80f648:	010000c4 	movi	r4,3
  80f64c:	1b07883a 	add	r3,r3,r12
  80f650:	21c00e2e 	bgeu	r4,r7,80f68c <memset+0x100>
  80f654:	1813883a 	mov	r9,r3
  80f658:	3811883a 	mov	r8,r7
  80f65c:	010000c4 	movi	r4,3
  80f660:	49800015 	stw	r6,0(r9)
  80f664:	423fff04 	addi	r8,r8,-4
  80f668:	4a400104 	addi	r9,r9,4
  80f66c:	223ffc36 	bltu	r4,r8,80f660 <__alt_data_end+0xfff0f660>
  80f670:	393fff04 	addi	r4,r7,-4
  80f674:	2008d0ba 	srli	r4,r4,2
  80f678:	39c000cc 	andi	r7,r7,3
  80f67c:	21000044 	addi	r4,r4,1
  80f680:	2109883a 	add	r4,r4,r4
  80f684:	2109883a 	add	r4,r4,r4
  80f688:	1907883a 	add	r3,r3,r4
  80f68c:	38000526 	beq	r7,zero,80f6a4 <memset+0x118>
  80f690:	19cf883a 	add	r7,r3,r7
  80f694:	19400005 	stb	r5,0(r3)
  80f698:	18c00044 	addi	r3,r3,1
  80f69c:	38fffd1e 	bne	r7,r3,80f694 <__alt_data_end+0xfff0f694>
  80f6a0:	f800283a 	ret
  80f6a4:	f800283a 	ret
  80f6a8:	2007883a 	mov	r3,r4
  80f6ac:	300f883a 	mov	r7,r6
  80f6b0:	003fc706 	br	80f5d0 <__alt_data_end+0xfff0f5d0>

0080f6b4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  80f6b4:	defff904 	addi	sp,sp,-28
  80f6b8:	dfc00615 	stw	ra,24(sp)
  80f6bc:	df000515 	stw	fp,20(sp)
  80f6c0:	df000504 	addi	fp,sp,20
  80f6c4:	e13ffc15 	stw	r4,-16(fp)
  80f6c8:	e17ffd15 	stw	r5,-12(fp)
  80f6cc:	e1bffe15 	stw	r6,-8(fp)
  80f6d0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  80f6d4:	e0800217 	ldw	r2,8(fp)
  80f6d8:	d8800015 	stw	r2,0(sp)
  80f6dc:	e1ffff17 	ldw	r7,-4(fp)
  80f6e0:	e1bffe17 	ldw	r6,-8(fp)
  80f6e4:	e17ffd17 	ldw	r5,-12(fp)
  80f6e8:	e13ffc17 	ldw	r4,-16(fp)
  80f6ec:	08008b80 	call	8008b8 <alt_iic_isr_register>
}  
  80f6f0:	e037883a 	mov	sp,fp
  80f6f4:	dfc00117 	ldw	ra,4(sp)
  80f6f8:	df000017 	ldw	fp,0(sp)
  80f6fc:	dec00204 	addi	sp,sp,8
  80f700:	f800283a 	ret

0080f704 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  80f704:	defff904 	addi	sp,sp,-28
  80f708:	df000615 	stw	fp,24(sp)
  80f70c:	df000604 	addi	fp,sp,24
  80f710:	e13ffe15 	stw	r4,-8(fp)
  80f714:	e17fff15 	stw	r5,-4(fp)
  80f718:	e0bfff17 	ldw	r2,-4(fp)
  80f71c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80f720:	0005303a 	rdctl	r2,status
  80f724:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80f728:	e0fffb17 	ldw	r3,-20(fp)
  80f72c:	00bfff84 	movi	r2,-2
  80f730:	1884703a 	and	r2,r3,r2
  80f734:	1001703a 	wrctl	status,r2
  
  return context;
  80f738:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  80f73c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  80f740:	00c00044 	movi	r3,1
  80f744:	e0bffa17 	ldw	r2,-24(fp)
  80f748:	1884983a 	sll	r2,r3,r2
  80f74c:	1007883a 	mov	r3,r2
  80f750:	d0a03d17 	ldw	r2,-32524(gp)
  80f754:	1884b03a 	or	r2,r3,r2
  80f758:	d0a03d15 	stw	r2,-32524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  80f75c:	d0a03d17 	ldw	r2,-32524(gp)
  80f760:	100170fa 	wrctl	ienable,r2
  80f764:	e0bffc17 	ldw	r2,-16(fp)
  80f768:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80f76c:	e0bffd17 	ldw	r2,-12(fp)
  80f770:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  80f774:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  80f778:	0001883a 	nop
}
  80f77c:	e037883a 	mov	sp,fp
  80f780:	df000017 	ldw	fp,0(sp)
  80f784:	dec00104 	addi	sp,sp,4
  80f788:	f800283a 	ret

0080f78c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  80f78c:	defff904 	addi	sp,sp,-28
  80f790:	df000615 	stw	fp,24(sp)
  80f794:	df000604 	addi	fp,sp,24
  80f798:	e13ffe15 	stw	r4,-8(fp)
  80f79c:	e17fff15 	stw	r5,-4(fp)
  80f7a0:	e0bfff17 	ldw	r2,-4(fp)
  80f7a4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80f7a8:	0005303a 	rdctl	r2,status
  80f7ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80f7b0:	e0fffb17 	ldw	r3,-20(fp)
  80f7b4:	00bfff84 	movi	r2,-2
  80f7b8:	1884703a 	and	r2,r3,r2
  80f7bc:	1001703a 	wrctl	status,r2
  
  return context;
  80f7c0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  80f7c4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  80f7c8:	00c00044 	movi	r3,1
  80f7cc:	e0bffa17 	ldw	r2,-24(fp)
  80f7d0:	1884983a 	sll	r2,r3,r2
  80f7d4:	0084303a 	nor	r2,zero,r2
  80f7d8:	1007883a 	mov	r3,r2
  80f7dc:	d0a03d17 	ldw	r2,-32524(gp)
  80f7e0:	1884703a 	and	r2,r3,r2
  80f7e4:	d0a03d15 	stw	r2,-32524(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  80f7e8:	d0a03d17 	ldw	r2,-32524(gp)
  80f7ec:	100170fa 	wrctl	ienable,r2
  80f7f0:	e0bffc17 	ldw	r2,-16(fp)
  80f7f4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80f7f8:	e0bffd17 	ldw	r2,-12(fp)
  80f7fc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  80f800:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  80f804:	0001883a 	nop
}
  80f808:	e037883a 	mov	sp,fp
  80f80c:	df000017 	ldw	fp,0(sp)
  80f810:	dec00104 	addi	sp,sp,4
  80f814:	f800283a 	ret

0080f818 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  80f818:	defffc04 	addi	sp,sp,-16
  80f81c:	df000315 	stw	fp,12(sp)
  80f820:	df000304 	addi	fp,sp,12
  80f824:	e13ffe15 	stw	r4,-8(fp)
  80f828:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  80f82c:	000530fa 	rdctl	r2,ienable
  80f830:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  80f834:	00c00044 	movi	r3,1
  80f838:	e0bfff17 	ldw	r2,-4(fp)
  80f83c:	1884983a 	sll	r2,r3,r2
  80f840:	1007883a 	mov	r3,r2
  80f844:	e0bffd17 	ldw	r2,-12(fp)
  80f848:	1884703a 	and	r2,r3,r2
  80f84c:	1004c03a 	cmpne	r2,r2,zero
  80f850:	10803fcc 	andi	r2,r2,255
}
  80f854:	e037883a 	mov	sp,fp
  80f858:	df000017 	ldw	fp,0(sp)
  80f85c:	dec00104 	addi	sp,sp,4
  80f860:	f800283a 	ret

0080f864 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  80f864:	defffd04 	addi	sp,sp,-12
  80f868:	dfc00215 	stw	ra,8(sp)
  80f86c:	df000115 	stw	fp,4(sp)
  80f870:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  80f874:	0009883a 	mov	r4,zero
  80f878:	080f9140 	call	80f914 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  80f87c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  80f880:	080f94c0 	call	80f94c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  80f884:	018020b4 	movhi	r6,130
  80f888:	31a72d04 	addi	r6,r6,-25420
  80f88c:	014020b4 	movhi	r5,130
  80f890:	29672d04 	addi	r5,r5,-25420
  80f894:	010020b4 	movhi	r4,130
  80f898:	21272d04 	addi	r4,r4,-25420
  80f89c:	08117b40 	call	8117b4 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  80f8a0:	08115800 	call	811580 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  80f8a4:	01002074 	movhi	r4,129
  80f8a8:	21057804 	addi	r4,r4,5600
  80f8ac:	0811ecc0 	call	811ecc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  80f8b0:	d0a03e17 	ldw	r2,-32520(gp)
  80f8b4:	d0e03f17 	ldw	r3,-32516(gp)
  80f8b8:	d1204017 	ldw	r4,-32512(gp)
  80f8bc:	200d883a 	mov	r6,r4
  80f8c0:	180b883a 	mov	r5,r3
  80f8c4:	1009883a 	mov	r4,r2
  80f8c8:	0806a740 	call	806a74 <main>
  80f8cc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  80f8d0:	01000044 	movi	r4,1
  80f8d4:	081127c0 	call	81127c <close>
  exit (result);
  80f8d8:	e13fff17 	ldw	r4,-4(fp)
  80f8dc:	0811ee00 	call	811ee0 <exit>

0080f8e0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  80f8e0:	defffd04 	addi	sp,sp,-12
  80f8e4:	dfc00215 	stw	ra,8(sp)
  80f8e8:	df000115 	stw	fp,4(sp)
  80f8ec:	df000104 	addi	fp,sp,4
  80f8f0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  80f8f4:	d1601604 	addi	r5,gp,-32680
  80f8f8:	e13fff17 	ldw	r4,-4(fp)
  80f8fc:	08113bc0 	call	8113bc <alt_dev_llist_insert>
}
  80f900:	e037883a 	mov	sp,fp
  80f904:	dfc00117 	ldw	ra,4(sp)
  80f908:	df000017 	ldw	fp,0(sp)
  80f90c:	dec00204 	addi	sp,sp,8
  80f910:	f800283a 	ret

0080f914 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  80f914:	defffd04 	addi	sp,sp,-12
  80f918:	dfc00215 	stw	ra,8(sp)
  80f91c:	df000115 	stw	fp,4(sp)
  80f920:	df000104 	addi	fp,sp,4
  80f924:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2, nios2_gen2);
  80f928:	0811cdc0 	call	811cdc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  80f92c:	00800044 	movi	r2,1
  80f930:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  80f934:	0001883a 	nop
  80f938:	e037883a 	mov	sp,fp
  80f93c:	dfc00117 	ldw	ra,4(sp)
  80f940:	df000017 	ldw	fp,0(sp)
  80f944:	dec00204 	addi	sp,sp,8
  80f948:	f800283a 	ret

0080f94c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  80f94c:	defffd04 	addi	sp,sp,-12
  80f950:	dfc00215 	stw	ra,8(sp)
  80f954:	df000115 	stw	fp,4(sp)
  80f958:	df000104 	addi	fp,sp,4
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
  80f95c:	01c0fa04 	movi	r7,1000
  80f960:	01800044 	movi	r6,1
  80f964:	000b883a 	mov	r5,zero
  80f968:	01040804 	movi	r4,4128
  80f96c:	08110980 	call	811098 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_DMA_INIT ( DMA, dma);
  80f970:	00800104 	movi	r2,4
  80f974:	d8800015 	stw	r2,0(sp)
  80f978:	000f883a 	mov	r7,zero
  80f97c:	01842004 	movi	r6,4224
  80f980:	014020b4 	movhi	r5,130
  80f984:	29687804 	addi	r5,r5,-24096
  80f988:	010020b4 	movhi	r4,130
  80f98c:	21287104 	addi	r4,r4,-24124
  80f990:	08105040 	call	810504 <alt_avalon_dma_init>
    ALTERA_AVALON_DMA_INIT ( DMA_LCD, dma_LCD);
  80f994:	008000c4 	movi	r2,3
  80f998:	d8800015 	stw	r2,0(sp)
  80f99c:	000f883a 	mov	r7,zero
  80f9a0:	01842804 	movi	r6,4256
  80f9a4:	014020b4 	movhi	r5,130
  80f9a8:	2968af04 	addi	r5,r5,-23876
  80f9ac:	010020b4 	movhi	r4,130
  80f9b0:	2128a804 	addi	r4,r4,-23904
  80f9b4:	08105040 	call	810504 <alt_avalon_dma_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
  80f9b8:	000d883a 	mov	r6,zero
  80f9bc:	000b883a 	mov	r5,zero
  80f9c0:	010020b4 	movhi	r4,130
  80f9c4:	2128c004 	addi	r4,r4,-23808
  80f9c8:	081071c0 	call	81071c <altera_avalon_jtag_uart_init>
  80f9cc:	010020b4 	movhi	r4,130
  80f9d0:	2128b604 	addi	r4,r4,-23848
  80f9d4:	080f8e00 	call	80f8e0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
  80f9d8:	0001883a 	nop
}
  80f9dc:	0001883a 	nop
  80f9e0:	e037883a 	mov	sp,fp
  80f9e4:	dfc00117 	ldw	ra,4(sp)
  80f9e8:	df000017 	ldw	fp,0(sp)
  80f9ec:	dec00204 	addi	sp,sp,8
  80f9f0:	f800283a 	ret

0080f9f4 <alt_dma_txchan_reg>:
/*
 * Register a DMA transmit channel with the system.
 */

static ALT_INLINE int alt_dma_txchan_reg (alt_dma_txchan_dev* dev)
{
  80f9f4:	defffd04 	addi	sp,sp,-12
  80f9f8:	dfc00215 	stw	ra,8(sp)
  80f9fc:	df000115 	stw	fp,4(sp)
  80fa00:	df000104 	addi	fp,sp,4
  80fa04:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dma_txchan_list;

  return alt_dev_llist_insert((alt_dev_llist*) dev, &alt_dma_txchan_list);
  80fa08:	d1601b04 	addi	r5,gp,-32660
  80fa0c:	e13fff17 	ldw	r4,-4(fp)
  80fa10:	08113bc0 	call	8113bc <alt_dev_llist_insert>
}
  80fa14:	e037883a 	mov	sp,fp
  80fa18:	dfc00117 	ldw	ra,4(sp)
  80fa1c:	df000017 	ldw	fp,0(sp)
  80fa20:	dec00204 	addi	sp,sp,8
  80fa24:	f800283a 	ret

0080fa28 <alt_dma_rxchan_reg>:
/*
 * Register a DMA receive channel with the system.
 */

static ALT_INLINE int alt_dma_rxchan_reg (alt_dma_rxchan_dev* dev)
{
  80fa28:	defffd04 	addi	sp,sp,-12
  80fa2c:	dfc00215 	stw	ra,8(sp)
  80fa30:	df000115 	stw	fp,4(sp)
  80fa34:	df000104 	addi	fp,sp,4
  80fa38:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dma_rxchan_list;

  return alt_dev_llist_insert((alt_dev_llist*) dev, &alt_dma_rxchan_list);
  80fa3c:	d1601904 	addi	r5,gp,-32668
  80fa40:	e13fff17 	ldw	r4,-4(fp)
  80fa44:	08113bc0 	call	8113bc <alt_dev_llist_insert>
}
  80fa48:	e037883a 	mov	sp,fp
  80fa4c:	dfc00117 	ldw	ra,4(sp)
  80fa50:	df000017 	ldw	fp,0(sp)
  80fa54:	dec00204 	addi	sp,sp,8
  80fa58:	f800283a 	ret

0080fa5c <alt_avalon_dma_launch_bidir>:
 * both the receive and transmit channels are using incrementing addresses,
 * i.e. both channels are accesing memory rather than devices.
 */

void alt_avalon_dma_launch_bidir (alt_avalon_dma_priv* priv)
{
  80fa5c:	defffc04 	addi	sp,sp,-16
  80fa60:	df000315 	stw	fp,12(sp)
  80fa64:	df000304 	addi	fp,sp,12
  80fa68:	e13fff15 	stw	r4,-4(fp)
  alt_avalon_dma_txslot* tx_slot;
  alt_avalon_dma_rxslot* rx_slot;

  if ((priv->tx_start != priv->tx_end) && (priv->rx_start != priv->rx_end))
  80fa6c:	e0bfff17 	ldw	r2,-4(fp)
  80fa70:	10c00117 	ldw	r3,4(r2)
  80fa74:	e0bfff17 	ldw	r2,-4(fp)
  80fa78:	10800217 	ldw	r2,8(r2)
  80fa7c:	18802e26 	beq	r3,r2,80fb38 <alt_avalon_dma_launch_bidir+0xdc>
  80fa80:	e0bfff17 	ldw	r2,-4(fp)
  80fa84:	10c00317 	ldw	r3,12(r2)
  80fa88:	e0bfff17 	ldw	r2,-4(fp)
  80fa8c:	10800417 	ldw	r2,16(r2)
  80fa90:	18802926 	beq	r3,r2,80fb38 <alt_avalon_dma_launch_bidir+0xdc>
  {
    priv->active = 1;
  80fa94:	e0bfff17 	ldw	r2,-4(fp)
  80fa98:	00c00044 	movi	r3,1
  80fa9c:	10c00815 	stw	r3,32(r2)

    tx_slot = &priv->tx_buf[priv->tx_start];
  80faa0:	e0bfff17 	ldw	r2,-4(fp)
  80faa4:	10800117 	ldw	r2,4(r2)
  80faa8:	1004913a 	slli	r2,r2,4
  80faac:	10800904 	addi	r2,r2,36
  80fab0:	e0ffff17 	ldw	r3,-4(fp)
  80fab4:	1885883a 	add	r2,r3,r2
  80fab8:	e0bffd15 	stw	r2,-12(fp)
    rx_slot = &priv->rx_buf[priv->rx_start];
  80fabc:	e0bfff17 	ldw	r2,-4(fp)
  80fac0:	10800317 	ldw	r2,12(r2)
  80fac4:	1004913a 	slli	r2,r2,4
  80fac8:	10801904 	addi	r2,r2,100
  80facc:	e0ffff17 	ldw	r3,-4(fp)
  80fad0:	1885883a 	add	r2,r3,r2
  80fad4:	e0bffe15 	stw	r2,-8(fp)

    IOWR_ALTERA_AVALON_DMA_RADDRESS (priv->base, (alt_u32) tx_slot->from);
  80fad8:	e0bfff17 	ldw	r2,-4(fp)
  80fadc:	10800017 	ldw	r2,0(r2)
  80fae0:	10800104 	addi	r2,r2,4
  80fae4:	e0fffd17 	ldw	r3,-12(fp)
  80fae8:	18c00017 	ldw	r3,0(r3)
  80faec:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_DMA_WADDRESS (priv->base, (alt_u32) rx_slot->data);
  80faf0:	e0bfff17 	ldw	r2,-4(fp)
  80faf4:	10800017 	ldw	r2,0(r2)
  80faf8:	10800204 	addi	r2,r2,8
  80fafc:	e0fffe17 	ldw	r3,-8(fp)
  80fb00:	18c00017 	ldw	r3,0(r3)
  80fb04:	10c00035 	stwio	r3,0(r2)

    IOWR_ALTERA_AVALON_DMA_LENGTH (priv->base,
  80fb08:	e0bfff17 	ldw	r2,-4(fp)
  80fb0c:	10800017 	ldw	r2,0(r2)
  80fb10:	11000304 	addi	r4,r2,12
  80fb14:	e0bffd17 	ldw	r2,-12(fp)
  80fb18:	11400117 	ldw	r5,4(r2)
  80fb1c:	e0bffe17 	ldw	r2,-8(fp)
  80fb20:	10c00117 	ldw	r3,4(r2)
  80fb24:	2805883a 	mov	r2,r5
  80fb28:	1880012e 	bgeu	r3,r2,80fb30 <alt_avalon_dma_launch_bidir+0xd4>
  80fb2c:	1805883a 	mov	r2,r3
  80fb30:	20800035 	stwio	r2,0(r4)
  80fb34:	00000206 	br	80fb40 <alt_avalon_dma_launch_bidir+0xe4>
       (tx_slot->len > rx_slot->len) ? rx_slot->len : tx_slot->len);
  }
  else
  {
    priv->active = 0;
  80fb38:	e0bfff17 	ldw	r2,-4(fp)
  80fb3c:	10000815 	stw	zero,32(r2)
  }
}
  80fb40:	0001883a 	nop
  80fb44:	e037883a 	mov	sp,fp
  80fb48:	df000017 	ldw	fp,0(sp)
  80fb4c:	dec00104 	addi	sp,sp,4
  80fb50:	f800283a 	ret

0080fb54 <alt_avalon_dma_launch_txonly>:
 * i.e. the receive channel is accessing a single memory location (which is
 * probably a device register).
 */

static void alt_avalon_dma_launch_txonly (alt_avalon_dma_priv* priv)
{
  80fb54:	defffd04 	addi	sp,sp,-12
  80fb58:	df000215 	stw	fp,8(sp)
  80fb5c:	df000204 	addi	fp,sp,8
  80fb60:	e13fff15 	stw	r4,-4(fp)
  alt_avalon_dma_txslot* tx_slot;

  if (priv->tx_start != priv->tx_end)
  80fb64:	e0bfff17 	ldw	r2,-4(fp)
  80fb68:	10c00117 	ldw	r3,4(r2)
  80fb6c:	e0bfff17 	ldw	r2,-4(fp)
  80fb70:	10800217 	ldw	r2,8(r2)
  80fb74:	18801726 	beq	r3,r2,80fbd4 <alt_avalon_dma_launch_txonly+0x80>
  {
    priv->active = 1;
  80fb78:	e0bfff17 	ldw	r2,-4(fp)
  80fb7c:	00c00044 	movi	r3,1
  80fb80:	10c00815 	stw	r3,32(r2)
    tx_slot      = &priv->tx_buf[priv->tx_start];
  80fb84:	e0bfff17 	ldw	r2,-4(fp)
  80fb88:	10800117 	ldw	r2,4(r2)
  80fb8c:	1004913a 	slli	r2,r2,4
  80fb90:	10800904 	addi	r2,r2,36
  80fb94:	e0ffff17 	ldw	r3,-4(fp)
  80fb98:	1885883a 	add	r2,r3,r2
  80fb9c:	e0bffe15 	stw	r2,-8(fp)

    IOWR_ALTERA_AVALON_DMA_RADDRESS (priv->base, (alt_u32) tx_slot->from);
  80fba0:	e0bfff17 	ldw	r2,-4(fp)
  80fba4:	10800017 	ldw	r2,0(r2)
  80fba8:	10800104 	addi	r2,r2,4
  80fbac:	e0fffe17 	ldw	r3,-8(fp)
  80fbb0:	18c00017 	ldw	r3,0(r3)
  80fbb4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_DMA_LENGTH (priv->base, tx_slot->len);
  80fbb8:	e0bfff17 	ldw	r2,-4(fp)
  80fbbc:	10800017 	ldw	r2,0(r2)
  80fbc0:	10800304 	addi	r2,r2,12
  80fbc4:	e0fffe17 	ldw	r3,-8(fp)
  80fbc8:	18c00117 	ldw	r3,4(r3)
  80fbcc:	10c00035 	stwio	r3,0(r2)
  }
  else
  {
    priv->active = 0;
  }
}
  80fbd0:	00000206 	br	80fbdc <alt_avalon_dma_launch_txonly+0x88>
    IOWR_ALTERA_AVALON_DMA_RADDRESS (priv->base, (alt_u32) tx_slot->from);
    IOWR_ALTERA_AVALON_DMA_LENGTH (priv->base, tx_slot->len);
  }
  else
  {
    priv->active = 0;
  80fbd4:	e0bfff17 	ldw	r2,-4(fp)
  80fbd8:	10000815 	stw	zero,32(r2)
  }
}
  80fbdc:	0001883a 	nop
  80fbe0:	e037883a 	mov	sp,fp
  80fbe4:	df000017 	ldw	fp,0(sp)
  80fbe8:	dec00104 	addi	sp,sp,4
  80fbec:	f800283a 	ret

0080fbf0 <alt_avalon_dma_launch_rxonly>:
 * i.e. the transmit channel is accessing a single memory location (which is
 * probably a device register).
 */

static void alt_avalon_dma_launch_rxonly (alt_avalon_dma_priv* priv)
{
  80fbf0:	defffd04 	addi	sp,sp,-12
  80fbf4:	df000215 	stw	fp,8(sp)
  80fbf8:	df000204 	addi	fp,sp,8
  80fbfc:	e13fff15 	stw	r4,-4(fp)
  alt_avalon_dma_rxslot* rx_slot;

  if (priv->rx_start != priv->rx_end)
  80fc00:	e0bfff17 	ldw	r2,-4(fp)
  80fc04:	10c00317 	ldw	r3,12(r2)
  80fc08:	e0bfff17 	ldw	r2,-4(fp)
  80fc0c:	10800417 	ldw	r2,16(r2)
  80fc10:	18801726 	beq	r3,r2,80fc70 <alt_avalon_dma_launch_rxonly+0x80>
  {
    priv->active = 1;
  80fc14:	e0bfff17 	ldw	r2,-4(fp)
  80fc18:	00c00044 	movi	r3,1
  80fc1c:	10c00815 	stw	r3,32(r2)
    rx_slot      = &priv->rx_buf[priv->rx_start];
  80fc20:	e0bfff17 	ldw	r2,-4(fp)
  80fc24:	10800317 	ldw	r2,12(r2)
  80fc28:	1004913a 	slli	r2,r2,4
  80fc2c:	10801904 	addi	r2,r2,100
  80fc30:	e0ffff17 	ldw	r3,-4(fp)
  80fc34:	1885883a 	add	r2,r3,r2
  80fc38:	e0bffe15 	stw	r2,-8(fp)

    IOWR_ALTERA_AVALON_DMA_WADDRESS (priv->base, (alt_u32) rx_slot->data);
  80fc3c:	e0bfff17 	ldw	r2,-4(fp)
  80fc40:	10800017 	ldw	r2,0(r2)
  80fc44:	10800204 	addi	r2,r2,8
  80fc48:	e0fffe17 	ldw	r3,-8(fp)
  80fc4c:	18c00017 	ldw	r3,0(r3)
  80fc50:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_AVALON_DMA_LENGTH (priv->base, rx_slot->len);
  80fc54:	e0bfff17 	ldw	r2,-4(fp)
  80fc58:	10800017 	ldw	r2,0(r2)
  80fc5c:	10800304 	addi	r2,r2,12
  80fc60:	e0fffe17 	ldw	r3,-8(fp)
  80fc64:	18c00117 	ldw	r3,4(r3)
  80fc68:	10c00035 	stwio	r3,0(r2)
  }
  else
  {
    priv->active = 0;
  }
}
  80fc6c:	00000206 	br	80fc78 <alt_avalon_dma_launch_rxonly+0x88>
    IOWR_ALTERA_AVALON_DMA_WADDRESS (priv->base, (alt_u32) rx_slot->data);
    IOWR_ALTERA_AVALON_DMA_LENGTH (priv->base, rx_slot->len);
  }
  else
  {
    priv->active = 0;
  80fc70:	e0bfff17 	ldw	r2,-4(fp)
  80fc74:	10000815 	stw	zero,32(r2)
  }
}
  80fc78:	0001883a 	nop
  80fc7c:	e037883a 	mov	sp,fp
  80fc80:	df000017 	ldw	fp,0(sp)
  80fc84:	dec00104 	addi	sp,sp,4
  80fc88:	f800283a 	ret

0080fc8c <alt_avalon_dma_ioctl>:
 * device instance. See alt_dma_dev.h for the meaning of the supported
 * ioctl requests.
 */

static int alt_avalon_dma_ioctl (alt_avalon_dma_priv* priv, int req, void* arg)
{
  80fc8c:	defffa04 	addi	sp,sp,-24
  80fc90:	df000515 	stw	fp,20(sp)
  80fc94:	df000504 	addi	fp,sp,20
  80fc98:	e13ffd15 	stw	r4,-12(fp)
  80fc9c:	e17ffe15 	stw	r5,-8(fp)
  80fca0:	e1bfff15 	stw	r6,-4(fp)
  int     status = 0;
  80fca4:	e03ffb15 	stw	zero,-20(fp)
   * since it cannot catch concurrent calls to alt_alavalon_dma_prepare()
   * or alt_avalon_dma_send(), but it should at least catch the most
   * common class of problems.
   */

  if ((priv->tx_start != priv->tx_end) ||
  80fca8:	e0bffd17 	ldw	r2,-12(fp)
  80fcac:	10c00117 	ldw	r3,4(r2)
  80fcb0:	e0bffd17 	ldw	r2,-12(fp)
  80fcb4:	10800217 	ldw	r2,8(r2)
  80fcb8:	18800a1e 	bne	r3,r2,80fce4 <alt_avalon_dma_ioctl+0x58>
      (priv->rx_start != priv->rx_end) ||
  80fcbc:	e0bffd17 	ldw	r2,-12(fp)
  80fcc0:	10c00317 	ldw	r3,12(r2)
  80fcc4:	e0bffd17 	ldw	r2,-12(fp)
  80fcc8:	10800417 	ldw	r2,16(r2)
   * since it cannot catch concurrent calls to alt_alavalon_dma_prepare()
   * or alt_avalon_dma_send(), but it should at least catch the most
   * common class of problems.
   */

  if ((priv->tx_start != priv->tx_end) ||
  80fccc:	1880051e 	bne	r3,r2,80fce4 <alt_avalon_dma_ioctl+0x58>
      (priv->rx_start != priv->rx_end) ||
      IORD_ALTERA_AVALON_DMA_LENGTH (priv->base))
  80fcd0:	e0bffd17 	ldw	r2,-12(fp)
  80fcd4:	10800017 	ldw	r2,0(r2)
  80fcd8:	10800304 	addi	r2,r2,12
  80fcdc:	10800037 	ldwio	r2,0(r2)
   * or alt_avalon_dma_send(), but it should at least catch the most
   * common class of problems.
   */

  if ((priv->tx_start != priv->tx_end) ||
      (priv->rx_start != priv->rx_end) ||
  80fce0:	10000226 	beq	r2,zero,80fcec <alt_avalon_dma_ioctl+0x60>
      IORD_ALTERA_AVALON_DMA_LENGTH (priv->base))
  {
    return -EIO;
  80fce4:	00bffec4 	movi	r2,-5
  80fce8:	0000b506 	br	80ffc0 <alt_avalon_dma_ioctl+0x334>
  }

  /* Now process the ioctl. */

  switch (req)
  80fcec:	e0bffe17 	ldw	r2,-8(fp)
  80fcf0:	108002a8 	cmpgeui	r2,r2,10
  80fcf4:	1000781e 	bne	r2,zero,80fed8 <alt_avalon_dma_ioctl+0x24c>
  80fcf8:	e0bffe17 	ldw	r2,-8(fp)
  80fcfc:	100690ba 	slli	r3,r2,2
  80fd00:	00802074 	movhi	r2,129
  80fd04:	10bf4504 	addi	r2,r2,-748
  80fd08:	1885883a 	add	r2,r3,r2
  80fd0c:	10800017 	ldw	r2,0(r2)
  80fd10:	1000683a 	jmp	r2
  80fd14:	0080fed8 	cmpnei	r2,zero,1019
  80fd18:	0080fd3c 	xorhi	r2,zero,1012
  80fd1c:	0080fd94 	movui	r2,1014
  80fd20:	0080fdc0 	call	80fdc <__alt_mem_onchip_flash+0xfdc>
  80fd24:	0080fe18 	cmpnei	r2,zero,1016
  80fd28:	0080fe44 	movi	r2,1017
  80fd2c:	0080fe60 	cmpeqi	r2,zero,1017
  80fd30:	0080fe80 	call	80fe8 <__alt_mem_onchip_flash+0xfe8>
  80fd34:	0080fea0 	cmpeqi	r2,zero,1018
  80fd38:	0080fec0 	call	80fec <__alt_mem_onchip_flash+0xfec>
  {
  case ALT_DMA_TX_STREAM_ON:
    if (!(priv->flags & ALT_AVALON_DMA_RX_STREAM))
  80fd3c:	e0bffd17 	ldw	r2,-12(fp)
  80fd40:	10800517 	ldw	r2,20(r2)
  80fd44:	1080100c 	andi	r2,r2,64
  80fd48:	10000f1e 	bne	r2,zero,80fd88 <alt_avalon_dma_ioctl+0xfc>
    {
      IOWR_ALTERA_AVALON_DMA_RADDRESS (priv->base, (alt_u32) arg);
  80fd4c:	e0bffd17 	ldw	r2,-12(fp)
  80fd50:	10800017 	ldw	r2,0(r2)
  80fd54:	10800104 	addi	r2,r2,4
  80fd58:	e0ffff17 	ldw	r3,-4(fp)
  80fd5c:	10c00035 	stwio	r3,0(r2)
      priv->flags |= ALT_AVALON_DMA_TX_STREAM;
  80fd60:	e0bffd17 	ldw	r2,-12(fp)
  80fd64:	10800517 	ldw	r2,20(r2)
  80fd68:	10c00814 	ori	r3,r2,32
  80fd6c:	e0bffd17 	ldw	r2,-12(fp)
  80fd70:	10c00515 	stw	r3,20(r2)
      priv->launch = alt_avalon_dma_launch_rxonly;
  80fd74:	e0fffd17 	ldw	r3,-12(fp)
  80fd78:	00802074 	movhi	r2,129
  80fd7c:	10befc04 	addi	r2,r2,-1040
  80fd80:	18800715 	stw	r2,28(r3)
    }
    else
    {
      status = -EIO;
    }
    break;
  80fd84:	00005606 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
      priv->flags |= ALT_AVALON_DMA_TX_STREAM;
      priv->launch = alt_avalon_dma_launch_rxonly;
    }
    else
    {
      status = -EIO;
  80fd88:	00bffec4 	movi	r2,-5
  80fd8c:	e0bffb15 	stw	r2,-20(fp)
    }
    break;
  80fd90:	00005306 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_TX_STREAM_OFF:
    priv->flags &= ~ALT_AVALON_DMA_TX_STREAM;
  80fd94:	e0bffd17 	ldw	r2,-12(fp)
  80fd98:	10c00517 	ldw	r3,20(r2)
  80fd9c:	00bff7c4 	movi	r2,-33
  80fda0:	1886703a 	and	r3,r3,r2
  80fda4:	e0bffd17 	ldw	r2,-12(fp)
  80fda8:	10c00515 	stw	r3,20(r2)
    priv->launch = alt_avalon_dma_launch_bidir;
  80fdac:	e0fffd17 	ldw	r3,-12(fp)
  80fdb0:	00802074 	movhi	r2,129
  80fdb4:	10be9704 	addi	r2,r2,-1444
  80fdb8:	18800715 	stw	r2,28(r3)
    break;
  80fdbc:	00004806 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_RX_STREAM_ON:
    if (!(priv->flags & ALT_AVALON_DMA_TX_STREAM))
  80fdc0:	e0bffd17 	ldw	r2,-12(fp)
  80fdc4:	10800517 	ldw	r2,20(r2)
  80fdc8:	1080080c 	andi	r2,r2,32
  80fdcc:	10000f1e 	bne	r2,zero,80fe0c <alt_avalon_dma_ioctl+0x180>
    {
      IOWR_ALTERA_AVALON_DMA_WADDRESS (priv->base, (alt_u32) arg);
  80fdd0:	e0bffd17 	ldw	r2,-12(fp)
  80fdd4:	10800017 	ldw	r2,0(r2)
  80fdd8:	10800204 	addi	r2,r2,8
  80fddc:	e0ffff17 	ldw	r3,-4(fp)
  80fde0:	10c00035 	stwio	r3,0(r2)
      priv->flags |= ALT_AVALON_DMA_RX_STREAM;
  80fde4:	e0bffd17 	ldw	r2,-12(fp)
  80fde8:	10800517 	ldw	r2,20(r2)
  80fdec:	10c01014 	ori	r3,r2,64
  80fdf0:	e0bffd17 	ldw	r2,-12(fp)
  80fdf4:	10c00515 	stw	r3,20(r2)
      priv->launch = alt_avalon_dma_launch_txonly;
  80fdf8:	e0fffd17 	ldw	r3,-12(fp)
  80fdfc:	00802074 	movhi	r2,129
  80fe00:	10bed504 	addi	r2,r2,-1196
  80fe04:	18800715 	stw	r2,28(r3)
    }
    else
    {
      status = -EIO;
    }
    break;
  80fe08:	00003506 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
      priv->flags |= ALT_AVALON_DMA_RX_STREAM;
      priv->launch = alt_avalon_dma_launch_txonly;
    }
    else
    {
      status = -EIO;
  80fe0c:	00bffec4 	movi	r2,-5
  80fe10:	e0bffb15 	stw	r2,-20(fp)
    }
    break;
  80fe14:	00003206 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_RX_STREAM_OFF:
    priv->flags &= ~ALT_AVALON_DMA_RX_STREAM;
  80fe18:	e0bffd17 	ldw	r2,-12(fp)
  80fe1c:	10c00517 	ldw	r3,20(r2)
  80fe20:	00bfefc4 	movi	r2,-65
  80fe24:	1886703a 	and	r3,r3,r2
  80fe28:	e0bffd17 	ldw	r2,-12(fp)
  80fe2c:	10c00515 	stw	r3,20(r2)
    priv->launch = alt_avalon_dma_launch_bidir;
  80fe30:	e0fffd17 	ldw	r3,-12(fp)
  80fe34:	00802074 	movhi	r2,129
  80fe38:	10be9704 	addi	r2,r2,-1444
  80fe3c:	18800715 	stw	r2,28(r3)
    break;
  80fe40:	00002706 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_SET_MODE_8:
    priv->flags = (priv->flags & ~ALT_AVALON_DMA_MODE_MSK) |
  80fe44:	e0bffd17 	ldw	r2,-12(fp)
  80fe48:	10c00517 	ldw	r3,20(r2)
  80fe4c:	00bffc04 	movi	r2,-16
  80fe50:	1886703a 	and	r3,r3,r2
  80fe54:	e0bffd17 	ldw	r2,-12(fp)
  80fe58:	10c00515 	stw	r3,20(r2)
      ALT_AVALON_DMA_MODE_8;
    break;
  80fe5c:	00002006 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_SET_MODE_16:
    priv->flags = (priv->flags & ~ALT_AVALON_DMA_MODE_MSK) |
  80fe60:	e0bffd17 	ldw	r2,-12(fp)
  80fe64:	10c00517 	ldw	r3,20(r2)
  80fe68:	00bffc04 	movi	r2,-16
  80fe6c:	1884703a 	and	r2,r3,r2
  80fe70:	10c00054 	ori	r3,r2,1
  80fe74:	e0bffd17 	ldw	r2,-12(fp)
  80fe78:	10c00515 	stw	r3,20(r2)
      ALT_AVALON_DMA_MODE_16;
    break;
  80fe7c:	00001806 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_SET_MODE_32:
    priv->flags = (priv->flags & ~ALT_AVALON_DMA_MODE_MSK) |
  80fe80:	e0bffd17 	ldw	r2,-12(fp)
  80fe84:	10c00517 	ldw	r3,20(r2)
  80fe88:	00bffc04 	movi	r2,-16
  80fe8c:	1884703a 	and	r2,r3,r2
  80fe90:	10c000d4 	ori	r3,r2,3
  80fe94:	e0bffd17 	ldw	r2,-12(fp)
  80fe98:	10c00515 	stw	r3,20(r2)
      ALT_AVALON_DMA_MODE_32;
    break;
  80fe9c:	00001006 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_SET_MODE_64:
    priv->flags = (priv->flags & ~ALT_AVALON_DMA_MODE_MSK) |
  80fea0:	e0bffd17 	ldw	r2,-12(fp)
  80fea4:	10c00517 	ldw	r3,20(r2)
  80fea8:	00bffc04 	movi	r2,-16
  80feac:	1884703a 	and	r2,r3,r2
  80feb0:	10c001d4 	ori	r3,r2,7
  80feb4:	e0bffd17 	ldw	r2,-12(fp)
  80feb8:	10c00515 	stw	r3,20(r2)
      ALT_AVALON_DMA_MODE_64;
    break;
  80febc:	00000806 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  case ALT_DMA_SET_MODE_128:
    priv->flags = (priv->flags & ~ALT_AVALON_DMA_MODE_MSK) |
  80fec0:	e0bffd17 	ldw	r2,-12(fp)
  80fec4:	10800517 	ldw	r2,20(r2)
  80fec8:	10c003d4 	ori	r3,r2,15
  80fecc:	e0bffd17 	ldw	r2,-12(fp)
  80fed0:	10c00515 	stw	r3,20(r2)
      ALT_AVALON_DMA_MODE_128;
    break;
  80fed4:	00000206 	br	80fee0 <alt_avalon_dma_ioctl+0x254>
  default:
    status = -ENOTTY;
  80fed8:	00bff9c4 	movi	r2,-25
  80fedc:	e0bffb15 	stw	r2,-20(fp)
  }

  if (!status)
  80fee0:	e0bffb17 	ldw	r2,-20(fp)
  80fee4:	1000351e 	bne	r2,zero,80ffbc <alt_avalon_dma_ioctl+0x330>
  {
     switch (priv->flags & ALT_AVALON_DMA_MODE_MSK)
  80fee8:	e0bffd17 	ldw	r2,-12(fp)
  80feec:	10800517 	ldw	r2,20(r2)
  80fef0:	108003cc 	andi	r2,r2,15
  80fef4:	10c00060 	cmpeqi	r3,r2,1
  80fef8:	1800091e 	bne	r3,zero,80ff20 <alt_avalon_dma_ioctl+0x294>
  80fefc:	0080052e 	bgeu	zero,r2,80ff14 <alt_avalon_dma_ioctl+0x288>
  80ff00:	10c000e0 	cmpeqi	r3,r2,3
  80ff04:	1800091e 	bne	r3,zero,80ff2c <alt_avalon_dma_ioctl+0x2a0>
  80ff08:	108001e0 	cmpeqi	r2,r2,7
  80ff0c:	10000a1e 	bne	r2,zero,80ff38 <alt_avalon_dma_ioctl+0x2ac>
  80ff10:	00000c06 	br	80ff44 <alt_avalon_dma_ioctl+0x2b8>
     {
     case ALT_AVALON_DMA_MODE_8:
       mode = ALTERA_AVALON_DMA_CONTROL_BYTE_MSK;
  80ff14:	00800044 	movi	r2,1
  80ff18:	e0bffc15 	stw	r2,-16(fp)
       break;
  80ff1c:	00000b06 	br	80ff4c <alt_avalon_dma_ioctl+0x2c0>
     case ALT_AVALON_DMA_MODE_16:
       mode = ALTERA_AVALON_DMA_CONTROL_HW_MSK;
  80ff20:	00800084 	movi	r2,2
  80ff24:	e0bffc15 	stw	r2,-16(fp)
       break;
  80ff28:	00000806 	br	80ff4c <alt_avalon_dma_ioctl+0x2c0>
     case ALT_AVALON_DMA_MODE_32:
       mode = ALTERA_AVALON_DMA_CONTROL_WORD_MSK;
  80ff2c:	00800104 	movi	r2,4
  80ff30:	e0bffc15 	stw	r2,-16(fp)
       break;
  80ff34:	00000506 	br	80ff4c <alt_avalon_dma_ioctl+0x2c0>
     case ALT_AVALON_DMA_MODE_64:
       mode = ALTERA_AVALON_DMA_CONTROL_DWORD_MSK;
  80ff38:	00810004 	movi	r2,1024
  80ff3c:	e0bffc15 	stw	r2,-16(fp)
       break;
  80ff40:	00000206 	br	80ff4c <alt_avalon_dma_ioctl+0x2c0>
     default:
       mode = ALTERA_AVALON_DMA_CONTROL_QWORD_MSK;
  80ff44:	00820004 	movi	r2,2048
  80ff48:	e0bffc15 	stw	r2,-16(fp)
     }

    if (priv->flags & ALT_AVALON_DMA_TX_STREAM)
  80ff4c:	e0bffd17 	ldw	r2,-12(fp)
  80ff50:	10800517 	ldw	r2,20(r2)
  80ff54:	1080080c 	andi	r2,r2,32
  80ff58:	10000726 	beq	r2,zero,80ff78 <alt_avalon_dma_ioctl+0x2ec>
    {
      IOWR_ALTERA_AVALON_DMA_CONTROL (priv->base,
  80ff5c:	e0bffd17 	ldw	r2,-12(fp)
  80ff60:	10800017 	ldw	r2,0(r2)
  80ff64:	10800604 	addi	r2,r2,24
  80ff68:	e0fffc17 	ldw	r3,-16(fp)
  80ff6c:	18c07e14 	ori	r3,r3,504
  80ff70:	10c00035 	stwio	r3,0(r2)
  80ff74:	00001106 	br	80ffbc <alt_avalon_dma_ioctl+0x330>
        ALTERA_AVALON_DMA_CONTROL_REEN_MSK |
        ALTERA_AVALON_DMA_CONTROL_WEEN_MSK |
        ALTERA_AVALON_DMA_CONTROL_LEEN_MSK |
        ALTERA_AVALON_DMA_CONTROL_RCON_MSK);
    }
    else if (priv->flags & ALT_AVALON_DMA_RX_STREAM)
  80ff78:	e0bffd17 	ldw	r2,-12(fp)
  80ff7c:	10800517 	ldw	r2,20(r2)
  80ff80:	1080100c 	andi	r2,r2,64
  80ff84:	10000726 	beq	r2,zero,80ffa4 <alt_avalon_dma_ioctl+0x318>
    {
      IOWR_ALTERA_AVALON_DMA_CONTROL (priv->base,
  80ff88:	e0bffd17 	ldw	r2,-12(fp)
  80ff8c:	10800017 	ldw	r2,0(r2)
  80ff90:	10800604 	addi	r2,r2,24
  80ff94:	e0fffc17 	ldw	r3,-16(fp)
  80ff98:	18c0be14 	ori	r3,r3,760
  80ff9c:	10c00035 	stwio	r3,0(r2)
  80ffa0:	00000606 	br	80ffbc <alt_avalon_dma_ioctl+0x330>
        ALTERA_AVALON_DMA_CONTROL_LEEN_MSK |
        ALTERA_AVALON_DMA_CONTROL_WCON_MSK);
    }
    else
    {
      IOWR_ALTERA_AVALON_DMA_CONTROL (priv->base,
  80ffa4:	e0bffd17 	ldw	r2,-12(fp)
  80ffa8:	10800017 	ldw	r2,0(r2)
  80ffac:	10800604 	addi	r2,r2,24
  80ffb0:	e0fffc17 	ldw	r3,-16(fp)
  80ffb4:	18c03e14 	ori	r3,r3,248
  80ffb8:	10c00035 	stwio	r3,0(r2)
        ALTERA_AVALON_DMA_CONTROL_WEEN_MSK      |
        ALTERA_AVALON_DMA_CONTROL_LEEN_MSK);
    }
  }

  return status;
  80ffbc:	e0bffb17 	ldw	r2,-20(fp)
}
  80ffc0:	e037883a 	mov	sp,fp
  80ffc4:	df000017 	ldw	fp,0(sp)
  80ffc8:	dec00104 	addi	sp,sp,4
  80ffcc:	f800283a 	ret

0080ffd0 <alt_avalon_dma_tx_ioctl>:
 */

int alt_avalon_dma_tx_ioctl (alt_dma_txchan dma,
           int req,
           void* arg)
{
  80ffd0:	defffb04 	addi	sp,sp,-20
  80ffd4:	dfc00415 	stw	ra,16(sp)
  80ffd8:	df000315 	stw	fp,12(sp)
  80ffdc:	df000304 	addi	fp,sp,12
  80ffe0:	e13ffd15 	stw	r4,-12(fp)
  80ffe4:	e17ffe15 	stw	r5,-8(fp)
  80ffe8:	e1bfff15 	stw	r6,-4(fp)
  return alt_avalon_dma_ioctl (((alt_avalon_dma_txchan*) dma)->priv,
  80ffec:	e0bffd17 	ldw	r2,-12(fp)
  80fff0:	10800617 	ldw	r2,24(r2)
  80fff4:	e1bfff17 	ldw	r6,-4(fp)
  80fff8:	e17ffe17 	ldw	r5,-8(fp)
  80fffc:	1009883a 	mov	r4,r2
  810000:	080fc8c0 	call	80fc8c <alt_avalon_dma_ioctl>
             req,
             arg);
}
  810004:	e037883a 	mov	sp,fp
  810008:	dfc00117 	ldw	ra,4(sp)
  81000c:	df000017 	ldw	fp,0(sp)
  810010:	dec00204 	addi	sp,sp,8
  810014:	f800283a 	ret

00810018 <alt_avalon_dma_rx_ioctl>:
 */

int alt_avalon_dma_rx_ioctl (alt_dma_rxchan dma,
           int req,
           void* arg)
{
  810018:	defffb04 	addi	sp,sp,-20
  81001c:	dfc00415 	stw	ra,16(sp)
  810020:	df000315 	stw	fp,12(sp)
  810024:	df000304 	addi	fp,sp,12
  810028:	e13ffd15 	stw	r4,-12(fp)
  81002c:	e17ffe15 	stw	r5,-8(fp)
  810030:	e1bfff15 	stw	r6,-4(fp)
  return alt_avalon_dma_ioctl (((alt_avalon_dma_rxchan*) dma)->priv,
  810034:	e0bffd17 	ldw	r2,-12(fp)
  810038:	10800617 	ldw	r2,24(r2)
  81003c:	e1bfff17 	ldw	r6,-4(fp)
  810040:	e17ffe17 	ldw	r5,-8(fp)
  810044:	1009883a 	mov	r4,r2
  810048:	080fc8c0 	call	80fc8c <alt_avalon_dma_ioctl>
             req,
             arg);
}
  81004c:	e037883a 	mov	sp,fp
  810050:	dfc00117 	ldw	ra,4(sp)
  810054:	df000017 	ldw	fp,0(sp)
  810058:	dec00204 	addi	sp,sp,8
  81005c:	f800283a 	ret

00810060 <alt_avalon_dma_prepare>:
int alt_avalon_dma_prepare (alt_dma_rxchan   dma,
                            void*            data,
                            alt_u32          len,
                            alt_rxchan_done* done,
                            void*            handle)
{
  810060:	defff404 	addi	sp,sp,-48
  810064:	dfc00b15 	stw	ra,44(sp)
  810068:	df000a15 	stw	fp,40(sp)
  81006c:	df000a04 	addi	fp,sp,40
  810070:	e13ffc15 	stw	r4,-16(fp)
  810074:	e17ffd15 	stw	r5,-12(fp)
  810078:	e1bffe15 	stw	r6,-8(fp)
  81007c:	e1ffff15 	stw	r7,-4(fp)
  alt_u32                end;
  alt_u32                next;
  alt_u32                align_mask;
  alt_avalon_dma_priv*   priv;

  priv = ((alt_avalon_dma_rxchan*) dma)->priv;
  810080:	e0bffc17 	ldw	r2,-16(fp)
  810084:	10800617 	ldw	r2,24(r2)
  810088:	e0bff615 	stw	r2,-40(fp)
  /*
   * Ensure that the data is correctly aligned, and that it's not too
   * big for the device.
   */

  align_mask = priv->flags & ALT_AVALON_DMA_MODE_MSK;
  81008c:	e0bff617 	ldw	r2,-40(fp)
  810090:	10800517 	ldw	r2,20(r2)
  810094:	108003cc 	andi	r2,r2,15
  810098:	e0bff715 	stw	r2,-36(fp)

  if ((((alt_u32) data) & align_mask) || (len & align_mask) ||
  81009c:	e0fffd17 	ldw	r3,-12(fp)
  8100a0:	e0bff717 	ldw	r2,-36(fp)
  8100a4:	1884703a 	and	r2,r3,r2
  8100a8:	1000081e 	bne	r2,zero,8100cc <alt_avalon_dma_prepare+0x6c>
  8100ac:	e0fffe17 	ldw	r3,-8(fp)
  8100b0:	e0bff717 	ldw	r2,-36(fp)
  8100b4:	1884703a 	and	r2,r3,r2
  8100b8:	1000041e 	bne	r2,zero,8100cc <alt_avalon_dma_prepare+0x6c>
     (len > priv->max_length))
  8100bc:	e0bff617 	ldw	r2,-40(fp)
  8100c0:	10c00617 	ldw	r3,24(r2)
   * big for the device.
   */

  align_mask = priv->flags & ALT_AVALON_DMA_MODE_MSK;

  if ((((alt_u32) data) & align_mask) || (len & align_mask) ||
  8100c4:	e0bffe17 	ldw	r2,-8(fp)
  8100c8:	1880022e 	bgeu	r3,r2,8100d4 <alt_avalon_dma_prepare+0x74>
     (len > priv->max_length))
  {
    return -EINVAL;
  8100cc:	00bffa84 	movi	r2,-22
  8100d0:	00002c06 	br	810184 <alt_avalon_dma_prepare+0x124>
  }

  start = priv->rx_start;
  8100d4:	e0bff617 	ldw	r2,-40(fp)
  8100d8:	10800317 	ldw	r2,12(r2)
  8100dc:	e0bff815 	stw	r2,-32(fp)
  end   = priv->rx_end;
  8100e0:	e0bff617 	ldw	r2,-40(fp)
  8100e4:	10800417 	ldw	r2,16(r2)
  8100e8:	e0bff915 	stw	r2,-28(fp)
  slot  = &priv->rx_buf[end];
  8100ec:	e0bff917 	ldw	r2,-28(fp)
  8100f0:	1004913a 	slli	r2,r2,4
  8100f4:	10801904 	addi	r2,r2,100
  8100f8:	e0fff617 	ldw	r3,-40(fp)
  8100fc:	1885883a 	add	r2,r3,r2
  810100:	e0bffa15 	stw	r2,-24(fp)

  next  = (end + 1) & ALT_AVALON_DMA_NSLOTS_MSK;
  810104:	e0bff917 	ldw	r2,-28(fp)
  810108:	10800044 	addi	r2,r2,1
  81010c:	108000cc 	andi	r2,r2,3
  810110:	e0bffb15 	stw	r2,-20(fp)

  if (next == start)
  810114:	e0fffb17 	ldw	r3,-20(fp)
  810118:	e0bff817 	ldw	r2,-32(fp)
  81011c:	1880021e 	bne	r3,r2,810128 <alt_avalon_dma_prepare+0xc8>
  {
    return -ENOSPC;
  810120:	00bff904 	movi	r2,-28
  810124:	00001706 	br	810184 <alt_avalon_dma_prepare+0x124>
  }

  slot->data   = data;
  810128:	e0bffa17 	ldw	r2,-24(fp)
  81012c:	e0fffd17 	ldw	r3,-12(fp)
  810130:	10c00015 	stw	r3,0(r2)
  slot->len    = len;
  810134:	e0bffa17 	ldw	r2,-24(fp)
  810138:	e0fffe17 	ldw	r3,-8(fp)
  81013c:	10c00115 	stw	r3,4(r2)
  slot->done   = done;
  810140:	e0bffa17 	ldw	r2,-24(fp)
  810144:	e0ffff17 	ldw	r3,-4(fp)
  810148:	10c00215 	stw	r3,8(r2)
  slot->handle = handle;
  81014c:	e0bffa17 	ldw	r2,-24(fp)
  810150:	e0c00217 	ldw	r3,8(fp)
  810154:	10c00315 	stw	r3,12(r2)

  priv->rx_end = next;
  810158:	e0bff617 	ldw	r2,-40(fp)
  81015c:	e0fffb17 	ldw	r3,-20(fp)
  810160:	10c00415 	stw	r3,16(r2)

  if (!priv->active)
  810164:	e0bff617 	ldw	r2,-40(fp)
  810168:	10800817 	ldw	r2,32(r2)
  81016c:	1000041e 	bne	r2,zero,810180 <alt_avalon_dma_prepare+0x120>
  {
    priv->launch (priv);
  810170:	e0bff617 	ldw	r2,-40(fp)
  810174:	10800717 	ldw	r2,28(r2)
  810178:	e13ff617 	ldw	r4,-40(fp)
  81017c:	103ee83a 	callr	r2
  }

  return 0;
  810180:	0005883a 	mov	r2,zero
}
  810184:	e037883a 	mov	sp,fp
  810188:	dfc00117 	ldw	ra,4(sp)
  81018c:	df000017 	ldw	fp,0(sp)
  810190:	dec00204 	addi	sp,sp,8
  810194:	f800283a 	ret

00810198 <alt_avalon_dma_space>:
 *
 * A negative value indicates that the value could not be determined.
 */

int alt_avalon_dma_space (alt_dma_txchan dma)
{
  810198:	defffb04 	addi	sp,sp,-20
  81019c:	df000415 	stw	fp,16(sp)
  8101a0:	df000404 	addi	fp,sp,16
  8101a4:	e13fff15 	stw	r4,-4(fp)
  alt_avalon_dma_priv* priv;

  alt_u32 start;
  alt_u32 end;

  priv = ((alt_avalon_dma_txchan*) dma)->priv;
  8101a8:	e0bfff17 	ldw	r2,-4(fp)
  8101ac:	10800617 	ldw	r2,24(r2)
  8101b0:	e0bffc15 	stw	r2,-16(fp)

  start = priv->tx_start;
  8101b4:	e0bffc17 	ldw	r2,-16(fp)
  8101b8:	10800117 	ldw	r2,4(r2)
  8101bc:	e0bffd15 	stw	r2,-12(fp)
  end   = priv->tx_end;
  8101c0:	e0bffc17 	ldw	r2,-16(fp)
  8101c4:	10800217 	ldw	r2,8(r2)
  8101c8:	e0bffe15 	stw	r2,-8(fp)

  return (start > end) ? start - end - 1 :
  8101cc:	e0bffd17 	ldw	r2,-12(fp)
  8101d0:	e0fffe17 	ldw	r3,-8(fp)
  8101d4:	1880052e 	bgeu	r3,r2,8101ec <alt_avalon_dma_space+0x54>
  8101d8:	e0fffd17 	ldw	r3,-12(fp)
  8101dc:	e0bffe17 	ldw	r2,-8(fp)
  8101e0:	1885c83a 	sub	r2,r3,r2
  8101e4:	10bfffc4 	addi	r2,r2,-1
  8101e8:	00000406 	br	8101fc <alt_avalon_dma_space+0x64>
    ALT_AVALON_DMA_NSLOTS + start - end - 1;
  8101ec:	e0fffd17 	ldw	r3,-12(fp)
  8101f0:	e0bffe17 	ldw	r2,-8(fp)
  8101f4:	1885c83a 	sub	r2,r3,r2
  8101f8:	108000c4 	addi	r2,r2,3
}
  8101fc:	e037883a 	mov	sp,fp
  810200:	df000017 	ldw	fp,0(sp)
  810204:	dec00104 	addi	sp,sp,4
  810208:	f800283a 	ret

0081020c <alt_avalon_dma_send>:
int alt_avalon_dma_send (alt_dma_txchan   dma,
                         const void*      from,
                         alt_u32          len,
                         alt_txchan_done* done,
                         void*            handle)
{
  81020c:	defff404 	addi	sp,sp,-48
  810210:	dfc00b15 	stw	ra,44(sp)
  810214:	df000a15 	stw	fp,40(sp)
  810218:	df000a04 	addi	fp,sp,40
  81021c:	e13ffc15 	stw	r4,-16(fp)
  810220:	e17ffd15 	stw	r5,-12(fp)
  810224:	e1bffe15 	stw	r6,-8(fp)
  810228:	e1ffff15 	stw	r7,-4(fp)
  alt_u32                end;
  alt_u32                align_mask;
  alt_u32                next;
  alt_avalon_dma_priv*   priv;

  priv = ((alt_avalon_dma_txchan*) dma)->priv;
  81022c:	e0bffc17 	ldw	r2,-16(fp)
  810230:	10800617 	ldw	r2,24(r2)
  810234:	e0bff615 	stw	r2,-40(fp)
  /*
   * Ensure that the data is correctly aligned, and not too large
   * for the device
   */

  align_mask = priv->flags & ALT_AVALON_DMA_MODE_MSK;
  810238:	e0bff617 	ldw	r2,-40(fp)
  81023c:	10800517 	ldw	r2,20(r2)
  810240:	108003cc 	andi	r2,r2,15
  810244:	e0bff715 	stw	r2,-36(fp)

  if ((((alt_u32) from) & align_mask) ||
  810248:	e0fffd17 	ldw	r3,-12(fp)
  81024c:	e0bff717 	ldw	r2,-36(fp)
  810250:	1884703a 	and	r2,r3,r2
  810254:	1000081e 	bne	r2,zero,810278 <alt_avalon_dma_send+0x6c>
        (len & align_mask)            ||
  810258:	e0fffe17 	ldw	r3,-8(fp)
  81025c:	e0bff717 	ldw	r2,-36(fp)
  810260:	1884703a 	and	r2,r3,r2
   * for the device
   */

  align_mask = priv->flags & ALT_AVALON_DMA_MODE_MSK;

  if ((((alt_u32) from) & align_mask) ||
  810264:	1000041e 	bne	r2,zero,810278 <alt_avalon_dma_send+0x6c>
        (len & align_mask)            ||
        (len > priv->max_length))
  810268:	e0bff617 	ldw	r2,-40(fp)
  81026c:	10c00617 	ldw	r3,24(r2)
   */

  align_mask = priv->flags & ALT_AVALON_DMA_MODE_MSK;

  if ((((alt_u32) from) & align_mask) ||
        (len & align_mask)            ||
  810270:	e0bffe17 	ldw	r2,-8(fp)
  810274:	1880022e 	bgeu	r3,r2,810280 <alt_avalon_dma_send+0x74>
        (len > priv->max_length))
  {
    return -EINVAL;
  810278:	00bffa84 	movi	r2,-22
  81027c:	00002c06 	br	810330 <alt_avalon_dma_send+0x124>
  }

  start = priv->tx_start;
  810280:	e0bff617 	ldw	r2,-40(fp)
  810284:	10800117 	ldw	r2,4(r2)
  810288:	e0bff815 	stw	r2,-32(fp)
  end   = priv->tx_end;
  81028c:	e0bff617 	ldw	r2,-40(fp)
  810290:	10800217 	ldw	r2,8(r2)
  810294:	e0bff915 	stw	r2,-28(fp)
  slot  = &priv->tx_buf[end];
  810298:	e0bff917 	ldw	r2,-28(fp)
  81029c:	1004913a 	slli	r2,r2,4
  8102a0:	10800904 	addi	r2,r2,36
  8102a4:	e0fff617 	ldw	r3,-40(fp)
  8102a8:	1885883a 	add	r2,r3,r2
  8102ac:	e0bffa15 	stw	r2,-24(fp)
  next  = (end + 1) & ALT_AVALON_DMA_NSLOTS_MSK;
  8102b0:	e0bff917 	ldw	r2,-28(fp)
  8102b4:	10800044 	addi	r2,r2,1
  8102b8:	108000cc 	andi	r2,r2,3
  8102bc:	e0bffb15 	stw	r2,-20(fp)

  if (next == start)
  8102c0:	e0fffb17 	ldw	r3,-20(fp)
  8102c4:	e0bff817 	ldw	r2,-32(fp)
  8102c8:	1880021e 	bne	r3,r2,8102d4 <alt_avalon_dma_send+0xc8>
  {
    return -ENOSPC;
  8102cc:	00bff904 	movi	r2,-28
  8102d0:	00001706 	br	810330 <alt_avalon_dma_send+0x124>
  }

  /* Fill in the descriptor */

  slot->from   = from;
  8102d4:	e0bffa17 	ldw	r2,-24(fp)
  8102d8:	e0fffd17 	ldw	r3,-12(fp)
  8102dc:	10c00015 	stw	r3,0(r2)
  slot->len    = len;
  8102e0:	e0bffa17 	ldw	r2,-24(fp)
  8102e4:	e0fffe17 	ldw	r3,-8(fp)
  8102e8:	10c00115 	stw	r3,4(r2)
  slot->done   = done;
  8102ec:	e0bffa17 	ldw	r2,-24(fp)
  8102f0:	e0ffff17 	ldw	r3,-4(fp)
  8102f4:	10c00215 	stw	r3,8(r2)
  slot->handle = handle;
  8102f8:	e0bffa17 	ldw	r2,-24(fp)
  8102fc:	e0c00217 	ldw	r3,8(fp)
  810300:	10c00315 	stw	r3,12(r2)

  priv->tx_end = next;
  810304:	e0bff617 	ldw	r2,-40(fp)
  810308:	e0fffb17 	ldw	r3,-20(fp)
  81030c:	10c00215 	stw	r3,8(r2)

  if (!priv->active)
  810310:	e0bff617 	ldw	r2,-40(fp)
  810314:	10800817 	ldw	r2,32(r2)
  810318:	1000041e 	bne	r2,zero,81032c <alt_avalon_dma_send+0x120>
  {
    priv->launch (priv);
  81031c:	e0bff617 	ldw	r2,-40(fp)
  810320:	10800717 	ldw	r2,28(r2)
  810324:	e13ff617 	ldw	r4,-40(fp)
  810328:	103ee83a 	callr	r2
  }

  return 0;
  81032c:	0005883a 	mov	r2,zero
}
  810330:	e037883a 	mov	sp,fp
  810334:	dfc00117 	ldw	ra,4(sp)
  810338:	df000017 	ldw	fp,0(sp)
  81033c:	dec00204 	addi	sp,sp,8
  810340:	f800283a 	ret

00810344 <alt_avalon_dma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_dma_irq (void* context)
#else
static void alt_avalon_dma_irq (void* context, alt_u32 id)
#endif
{
  810344:	defff104 	addi	sp,sp,-60
  810348:	dfc00e15 	stw	ra,56(sp)
  81034c:	df000d15 	stw	fp,52(sp)
  810350:	df000d04 	addi	fp,sp,52
  810354:	e13fff15 	stw	r4,-4(fp)
  alt_avalon_dma_priv* priv = (alt_avalon_dma_priv*) context;
  810358:	e0bfff17 	ldw	r2,-4(fp)
  81035c:	e0bff315 	stw	r2,-52(fp)
  alt_u32                rx_start;
  int                    stream_tx;
  int                    stream_rx;
  alt_irq_context        cpu_sr;

  stream_tx = priv->flags & ALT_AVALON_DMA_TX_STREAM;
  810360:	e0bff317 	ldw	r2,-52(fp)
  810364:	10800517 	ldw	r2,20(r2)
  810368:	1080080c 	andi	r2,r2,32
  81036c:	e0bff415 	stw	r2,-48(fp)
  stream_rx = priv->flags & ALT_AVALON_DMA_RX_STREAM;
  810370:	e0bff317 	ldw	r2,-52(fp)
  810374:	10800517 	ldw	r2,20(r2)
  810378:	1080100c 	andi	r2,r2,64
  81037c:	e0bff515 	stw	r2,-44(fp)

  tx_start = priv->tx_start;
  810380:	e0bff317 	ldw	r2,-52(fp)
  810384:	10800117 	ldw	r2,4(r2)
  810388:	e0bff615 	stw	r2,-40(fp)
  rx_start = priv->rx_start;
  81038c:	e0bff317 	ldw	r2,-52(fp)
  810390:	10800317 	ldw	r2,12(r2)
  810394:	e0bff715 	stw	r2,-36(fp)

  tx_slot = &priv->tx_buf[tx_start];
  810398:	e0bff617 	ldw	r2,-40(fp)
  81039c:	1004913a 	slli	r2,r2,4
  8103a0:	10800904 	addi	r2,r2,36
  8103a4:	e0fff317 	ldw	r3,-52(fp)
  8103a8:	1885883a 	add	r2,r3,r2
  8103ac:	e0bff815 	stw	r2,-32(fp)
  rx_slot = &priv->rx_buf[rx_start];
  8103b0:	e0bff717 	ldw	r2,-36(fp)
  8103b4:	1004913a 	slli	r2,r2,4
  8103b8:	10801904 	addi	r2,r2,100
  8103bc:	e0fff317 	ldw	r3,-52(fp)
  8103c0:	1885883a 	add	r2,r3,r2
  8103c4:	e0bff915 	stw	r2,-28(fp)

  /* Increment the descriptors */

  if (!stream_tx)
  8103c8:	e0bff417 	ldw	r2,-48(fp)
  8103cc:	1000051e 	bne	r2,zero,8103e4 <alt_avalon_dma_irq+0xa0>
  {
    priv->tx_start = (tx_start + 1) & ALT_AVALON_DMA_NSLOTS_MSK;
  8103d0:	e0bff617 	ldw	r2,-40(fp)
  8103d4:	10800044 	addi	r2,r2,1
  8103d8:	10c000cc 	andi	r3,r2,3
  8103dc:	e0bff317 	ldw	r2,-52(fp)
  8103e0:	10c00115 	stw	r3,4(r2)
  }
  if (!stream_rx)
  8103e4:	e0bff517 	ldw	r2,-44(fp)
  8103e8:	1000051e 	bne	r2,zero,810400 <alt_avalon_dma_irq+0xbc>
  {
    priv->rx_start = (rx_start + 1) & ALT_AVALON_DMA_NSLOTS_MSK;
  8103ec:	e0bff717 	ldw	r2,-36(fp)
  8103f0:	10800044 	addi	r2,r2,1
  8103f4:	10c000cc 	andi	r3,r2,3
  8103f8:	e0bff317 	ldw	r2,-52(fp)
  8103fc:	10c00315 	stw	r3,12(r2)
  }

  /* clear the interrupt */

  IOWR_ALTERA_AVALON_DMA_STATUS (priv->base, 0);
  810400:	e0bff317 	ldw	r2,-52(fp)
  810404:	10800017 	ldw	r2,0(r2)
  810408:	0007883a 	mov	r3,zero
  81040c:	10c00035 	stwio	r3,0(r2)
  
  /* Dummy read to ensure IRQ is cleared prior to ISR completion*/
  IORD_ALTERA_AVALON_DMA_STATUS (priv->base);
  810410:	e0bff317 	ldw	r2,-52(fp)
  810414:	10800017 	ldw	r2,0(r2)
  810418:	10800037 	ldwio	r2,0(r2)

  /* launch the next transaction */

  priv->launch (priv);
  81041c:	e0bff317 	ldw	r2,-52(fp)
  810420:	10800717 	ldw	r2,28(r2)
  810424:	e13ff317 	ldw	r4,-52(fp)
  810428:	103ee83a 	callr	r2
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the DMA driver to support 
   * interrupt preemption.
   */
  if (!stream_tx && tx_slot->done)
  81042c:	e0bff417 	ldw	r2,-48(fp)
  810430:	1000151e 	bne	r2,zero,810488 <alt_avalon_dma_irq+0x144>
  810434:	e0bff817 	ldw	r2,-32(fp)
  810438:	10800217 	ldw	r2,8(r2)
  81043c:	10001226 	beq	r2,zero,810488 <alt_avalon_dma_irq+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810440:	0005303a 	rdctl	r2,status
  810444:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810448:	e0fffc17 	ldw	r3,-16(fp)
  81044c:	00bfff84 	movi	r2,-2
  810450:	1884703a 	and	r2,r3,r2
  810454:	1001703a 	wrctl	status,r2
  
  return context;
  810458:	e0bffc17 	ldw	r2,-16(fp)
  {
    cpu_sr = alt_irq_disable_all();
  81045c:	e0bffb15 	stw	r2,-20(fp)
    tx_slot->done (tx_slot->handle);
  810460:	e0bff817 	ldw	r2,-32(fp)
  810464:	10800217 	ldw	r2,8(r2)
  810468:	e0fff817 	ldw	r3,-32(fp)
  81046c:	18c00317 	ldw	r3,12(r3)
  810470:	1809883a 	mov	r4,r3
  810474:	103ee83a 	callr	r2
  810478:	e0bffb17 	ldw	r2,-20(fp)
  81047c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810480:	e0bffe17 	ldw	r2,-8(fp)
  810484:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
    
  }
  if (!stream_rx && rx_slot->done)
  810488:	e0bff517 	ldw	r2,-44(fp)
  81048c:	1000171e 	bne	r2,zero,8104ec <alt_avalon_dma_irq+0x1a8>
  810490:	e0bff917 	ldw	r2,-28(fp)
  810494:	10800217 	ldw	r2,8(r2)
  810498:	10001426 	beq	r2,zero,8104ec <alt_avalon_dma_irq+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81049c:	0005303a 	rdctl	r2,status
  8104a0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8104a4:	e0fffd17 	ldw	r3,-12(fp)
  8104a8:	00bfff84 	movi	r2,-2
  8104ac:	1884703a 	and	r2,r3,r2
  8104b0:	1001703a 	wrctl	status,r2
  
  return context;
  8104b4:	e0bffd17 	ldw	r2,-12(fp)
  {
    cpu_sr = alt_irq_disable_all();
  8104b8:	e0bffb15 	stw	r2,-20(fp)
    rx_slot->done (rx_slot->handle, rx_slot->data);
  8104bc:	e0bff917 	ldw	r2,-28(fp)
  8104c0:	10800217 	ldw	r2,8(r2)
  8104c4:	e0fff917 	ldw	r3,-28(fp)
  8104c8:	19000317 	ldw	r4,12(r3)
  8104cc:	e0fff917 	ldw	r3,-28(fp)
  8104d0:	18c00017 	ldw	r3,0(r3)
  8104d4:	180b883a 	mov	r5,r3
  8104d8:	103ee83a 	callr	r2
  8104dc:	e0bffb17 	ldw	r2,-20(fp)
  8104e0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8104e4:	e0bffa17 	ldw	r2,-24(fp)
  8104e8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
  8104ec:	0001883a 	nop
  8104f0:	e037883a 	mov	sp,fp
  8104f4:	dfc00117 	ldw	ra,4(sp)
  8104f8:	df000017 	ldw	fp,0(sp)
  8104fc:	dec00204 	addi	sp,sp,8
  810500:	f800283a 	ret

00810504 <alt_avalon_dma_init>:
void alt_avalon_dma_init (alt_avalon_dma_txchan* tx,
                          alt_avalon_dma_rxchan* rx,
                          void*                  base,
                          alt_u32                ic_id,
                          alt_u32                irq)
{
  810504:	defff904 	addi	sp,sp,-28
  810508:	dfc00615 	stw	ra,24(sp)
  81050c:	df000515 	stw	fp,20(sp)
  810510:	df000504 	addi	fp,sp,20
  810514:	e13ffc15 	stw	r4,-16(fp)
  810518:	e17ffd15 	stw	r5,-12(fp)
  81051c:	e1bffe15 	stw	r6,-8(fp)
  810520:	e1ffff15 	stw	r7,-4(fp)

  /* Halt any current transactions (reset the device) */
  IOWR_ALTERA_AVALON_DMA_CONTROL (base, ALTERA_AVALON_DMA_CONTROL_SOFTWARERESET_MSK);
  810524:	e0bffe17 	ldw	r2,-8(fp)
  810528:	10800604 	addi	r2,r2,24
  81052c:	00c40004 	movi	r3,4096
  810530:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_DMA_CONTROL (base, ALTERA_AVALON_DMA_CONTROL_SOFTWARERESET_MSK);
  810534:	e0bffe17 	ldw	r2,-8(fp)
  810538:	10800604 	addi	r2,r2,24
  81053c:	00c40004 	movi	r3,4096
  810540:	10c00035 	stwio	r3,0(r2)

  /* Set the default mode of the device (32 bit block reads and writes from/to memory). */
  IOWR_ALTERA_AVALON_DMA_CONTROL (base,
  810544:	e0bffe17 	ldw	r2,-8(fp)
  810548:	10800604 	addi	r2,r2,24
  81054c:	00c03f04 	movi	r3,252
  810550:	10c00035 	stwio	r3,0(r2)
                          ALTERA_AVALON_DMA_CONTROL_REEN_MSK      |
                          ALTERA_AVALON_DMA_CONTROL_WEEN_MSK      |
                          ALTERA_AVALON_DMA_CONTROL_LEEN_MSK);

  /* Clear any pending interrupts and the DONE flag */
  IOWR_ALTERA_AVALON_DMA_STATUS (base, 0);
  810554:	0007883a 	mov	r3,zero
  810558:	e0bffe17 	ldw	r2,-8(fp)
  81055c:	10c00035 	stwio	r3,0(r2)
  /*
   * Register the interrupt handler, and make the device available to the
   * system.
   */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  if (alt_ic_isr_register(ic_id, irq, alt_avalon_dma_irq, tx->priv, 0x0) >= 0)
  810560:	e0bffc17 	ldw	r2,-16(fp)
  810564:	10800617 	ldw	r2,24(r2)
  810568:	d8000015 	stw	zero,0(sp)
  81056c:	100f883a 	mov	r7,r2
  810570:	01802074 	movhi	r6,129
  810574:	3180d104 	addi	r6,r6,836
  810578:	e1400217 	ldw	r5,8(fp)
  81057c:	e13fff17 	ldw	r4,-4(fp)
  810580:	080f6b40 	call	80f6b4 <alt_ic_isr_register>
  810584:	10000616 	blt	r2,zero,8105a0 <alt_avalon_dma_init+0x9c>
#else
  if (alt_irq_register (irq, tx->priv, alt_avalon_dma_irq) >= 0)
#endif  
  {
    alt_dma_txchan_reg (&tx->dev);
  810588:	e0bffc17 	ldw	r2,-16(fp)
  81058c:	1009883a 	mov	r4,r2
  810590:	080f9f40 	call	80f9f4 <alt_dma_txchan_reg>
    alt_dma_rxchan_reg (&rx->dev);
  810594:	e0bffd17 	ldw	r2,-12(fp)
  810598:	1009883a 	mov	r4,r2
  81059c:	080fa280 	call	80fa28 <alt_dma_rxchan_reg>
  }
}
  8105a0:	0001883a 	nop
  8105a4:	e037883a 	mov	sp,fp
  8105a8:	dfc00117 	ldw	ra,4(sp)
  8105ac:	df000017 	ldw	fp,0(sp)
  8105b0:	dec00204 	addi	sp,sp,8
  8105b4:	f800283a 	ret

008105b8 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  8105b8:	defffa04 	addi	sp,sp,-24
  8105bc:	dfc00515 	stw	ra,20(sp)
  8105c0:	df000415 	stw	fp,16(sp)
  8105c4:	df000404 	addi	fp,sp,16
  8105c8:	e13ffd15 	stw	r4,-12(fp)
  8105cc:	e17ffe15 	stw	r5,-8(fp)
  8105d0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  8105d4:	e0bffd17 	ldw	r2,-12(fp)
  8105d8:	10800017 	ldw	r2,0(r2)
  8105dc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  8105e0:	e0bffc17 	ldw	r2,-16(fp)
  8105e4:	10c00a04 	addi	r3,r2,40
  8105e8:	e0bffd17 	ldw	r2,-12(fp)
  8105ec:	10800217 	ldw	r2,8(r2)
  8105f0:	100f883a 	mov	r7,r2
  8105f4:	e1bfff17 	ldw	r6,-4(fp)
  8105f8:	e17ffe17 	ldw	r5,-8(fp)
  8105fc:	1809883a 	mov	r4,r3
  810600:	0810be00 	call	810be0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  810604:	e037883a 	mov	sp,fp
  810608:	dfc00117 	ldw	ra,4(sp)
  81060c:	df000017 	ldw	fp,0(sp)
  810610:	dec00204 	addi	sp,sp,8
  810614:	f800283a 	ret

00810618 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  810618:	defffa04 	addi	sp,sp,-24
  81061c:	dfc00515 	stw	ra,20(sp)
  810620:	df000415 	stw	fp,16(sp)
  810624:	df000404 	addi	fp,sp,16
  810628:	e13ffd15 	stw	r4,-12(fp)
  81062c:	e17ffe15 	stw	r5,-8(fp)
  810630:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  810634:	e0bffd17 	ldw	r2,-12(fp)
  810638:	10800017 	ldw	r2,0(r2)
  81063c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  810640:	e0bffc17 	ldw	r2,-16(fp)
  810644:	10c00a04 	addi	r3,r2,40
  810648:	e0bffd17 	ldw	r2,-12(fp)
  81064c:	10800217 	ldw	r2,8(r2)
  810650:	100f883a 	mov	r7,r2
  810654:	e1bfff17 	ldw	r6,-4(fp)
  810658:	e17ffe17 	ldw	r5,-8(fp)
  81065c:	1809883a 	mov	r4,r3
  810660:	0810dfc0 	call	810dfc <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  810664:	e037883a 	mov	sp,fp
  810668:	dfc00117 	ldw	ra,4(sp)
  81066c:	df000017 	ldw	fp,0(sp)
  810670:	dec00204 	addi	sp,sp,8
  810674:	f800283a 	ret

00810678 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  810678:	defffc04 	addi	sp,sp,-16
  81067c:	dfc00315 	stw	ra,12(sp)
  810680:	df000215 	stw	fp,8(sp)
  810684:	df000204 	addi	fp,sp,8
  810688:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  81068c:	e0bfff17 	ldw	r2,-4(fp)
  810690:	10800017 	ldw	r2,0(r2)
  810694:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  810698:	e0bffe17 	ldw	r2,-8(fp)
  81069c:	10c00a04 	addi	r3,r2,40
  8106a0:	e0bfff17 	ldw	r2,-4(fp)
  8106a4:	10800217 	ldw	r2,8(r2)
  8106a8:	100b883a 	mov	r5,r2
  8106ac:	1809883a 	mov	r4,r3
  8106b0:	0810a880 	call	810a88 <altera_avalon_jtag_uart_close>
}
  8106b4:	e037883a 	mov	sp,fp
  8106b8:	dfc00117 	ldw	ra,4(sp)
  8106bc:	df000017 	ldw	fp,0(sp)
  8106c0:	dec00204 	addi	sp,sp,8
  8106c4:	f800283a 	ret

008106c8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  8106c8:	defffa04 	addi	sp,sp,-24
  8106cc:	dfc00515 	stw	ra,20(sp)
  8106d0:	df000415 	stw	fp,16(sp)
  8106d4:	df000404 	addi	fp,sp,16
  8106d8:	e13ffd15 	stw	r4,-12(fp)
  8106dc:	e17ffe15 	stw	r5,-8(fp)
  8106e0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  8106e4:	e0bffd17 	ldw	r2,-12(fp)
  8106e8:	10800017 	ldw	r2,0(r2)
  8106ec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  8106f0:	e0bffc17 	ldw	r2,-16(fp)
  8106f4:	10800a04 	addi	r2,r2,40
  8106f8:	e1bfff17 	ldw	r6,-4(fp)
  8106fc:	e17ffe17 	ldw	r5,-8(fp)
  810700:	1009883a 	mov	r4,r2
  810704:	0810af00 	call	810af0 <altera_avalon_jtag_uart_ioctl>
}
  810708:	e037883a 	mov	sp,fp
  81070c:	dfc00117 	ldw	ra,4(sp)
  810710:	df000017 	ldw	fp,0(sp)
  810714:	dec00204 	addi	sp,sp,8
  810718:	f800283a 	ret

0081071c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  81071c:	defffa04 	addi	sp,sp,-24
  810720:	dfc00515 	stw	ra,20(sp)
  810724:	df000415 	stw	fp,16(sp)
  810728:	df000404 	addi	fp,sp,16
  81072c:	e13ffd15 	stw	r4,-12(fp)
  810730:	e17ffe15 	stw	r5,-8(fp)
  810734:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  810738:	e0bffd17 	ldw	r2,-12(fp)
  81073c:	00c00044 	movi	r3,1
  810740:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  810744:	e0bffd17 	ldw	r2,-12(fp)
  810748:	10800017 	ldw	r2,0(r2)
  81074c:	10800104 	addi	r2,r2,4
  810750:	1007883a 	mov	r3,r2
  810754:	e0bffd17 	ldw	r2,-12(fp)
  810758:	10800817 	ldw	r2,32(r2)
  81075c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  810760:	e0bffe17 	ldw	r2,-8(fp)
  810764:	e0ffff17 	ldw	r3,-4(fp)
  810768:	d8000015 	stw	zero,0(sp)
  81076c:	e1fffd17 	ldw	r7,-12(fp)
  810770:	01802074 	movhi	r6,129
  810774:	3181f704 	addi	r6,r6,2012
  810778:	180b883a 	mov	r5,r3
  81077c:	1009883a 	mov	r4,r2
  810780:	080f6b40 	call	80f6b4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  810784:	e0bffd17 	ldw	r2,-12(fp)
  810788:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  81078c:	e0bffd17 	ldw	r2,-12(fp)
  810790:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  810794:	d0e04117 	ldw	r3,-32508(gp)
  810798:	e1fffd17 	ldw	r7,-12(fp)
  81079c:	01802074 	movhi	r6,129
  8107a0:	31827a04 	addi	r6,r6,2536
  8107a4:	180b883a 	mov	r5,r3
  8107a8:	1009883a 	mov	r4,r2
  8107ac:	08111140 	call	811114 <alt_alarm_start>
  8107b0:	1000040e 	bge	r2,zero,8107c4 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  8107b4:	e0fffd17 	ldw	r3,-12(fp)
  8107b8:	00a00034 	movhi	r2,32768
  8107bc:	10bfffc4 	addi	r2,r2,-1
  8107c0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  8107c4:	0001883a 	nop
  8107c8:	e037883a 	mov	sp,fp
  8107cc:	dfc00117 	ldw	ra,4(sp)
  8107d0:	df000017 	ldw	fp,0(sp)
  8107d4:	dec00204 	addi	sp,sp,8
  8107d8:	f800283a 	ret

008107dc <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  8107dc:	defff804 	addi	sp,sp,-32
  8107e0:	df000715 	stw	fp,28(sp)
  8107e4:	df000704 	addi	fp,sp,28
  8107e8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  8107ec:	e0bfff17 	ldw	r2,-4(fp)
  8107f0:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  8107f4:	e0bffb17 	ldw	r2,-20(fp)
  8107f8:	10800017 	ldw	r2,0(r2)
  8107fc:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  810800:	e0bffc17 	ldw	r2,-16(fp)
  810804:	10800104 	addi	r2,r2,4
  810808:	10800037 	ldwio	r2,0(r2)
  81080c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  810810:	e0bffd17 	ldw	r2,-12(fp)
  810814:	1080c00c 	andi	r2,r2,768
  810818:	10006d26 	beq	r2,zero,8109d0 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  81081c:	e0bffd17 	ldw	r2,-12(fp)
  810820:	1080400c 	andi	r2,r2,256
  810824:	10003526 	beq	r2,zero,8108fc <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  810828:	00800074 	movhi	r2,1
  81082c:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  810830:	e0bffb17 	ldw	r2,-20(fp)
  810834:	10800a17 	ldw	r2,40(r2)
  810838:	10800044 	addi	r2,r2,1
  81083c:	1081ffcc 	andi	r2,r2,2047
  810840:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  810844:	e0bffb17 	ldw	r2,-20(fp)
  810848:	10c00b17 	ldw	r3,44(r2)
  81084c:	e0bffe17 	ldw	r2,-8(fp)
  810850:	18801526 	beq	r3,r2,8108a8 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  810854:	e0bffc17 	ldw	r2,-16(fp)
  810858:	10800037 	ldwio	r2,0(r2)
  81085c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  810860:	e0bff917 	ldw	r2,-28(fp)
  810864:	10a0000c 	andi	r2,r2,32768
  810868:	10001126 	beq	r2,zero,8108b0 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  81086c:	e0bffb17 	ldw	r2,-20(fp)
  810870:	10800a17 	ldw	r2,40(r2)
  810874:	e0fff917 	ldw	r3,-28(fp)
  810878:	1809883a 	mov	r4,r3
  81087c:	e0fffb17 	ldw	r3,-20(fp)
  810880:	1885883a 	add	r2,r3,r2
  810884:	10800e04 	addi	r2,r2,56
  810888:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  81088c:	e0bffb17 	ldw	r2,-20(fp)
  810890:	10800a17 	ldw	r2,40(r2)
  810894:	10800044 	addi	r2,r2,1
  810898:	10c1ffcc 	andi	r3,r2,2047
  81089c:	e0bffb17 	ldw	r2,-20(fp)
  8108a0:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  8108a4:	003fe206 	br	810830 <__alt_data_end+0xfff10830>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  8108a8:	0001883a 	nop
  8108ac:	00000106 	br	8108b4 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  8108b0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  8108b4:	e0bff917 	ldw	r2,-28(fp)
  8108b8:	10bfffec 	andhi	r2,r2,65535
  8108bc:	10000f26 	beq	r2,zero,8108fc <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  8108c0:	e0bffb17 	ldw	r2,-20(fp)
  8108c4:	10c00817 	ldw	r3,32(r2)
  8108c8:	00bfff84 	movi	r2,-2
  8108cc:	1886703a 	and	r3,r3,r2
  8108d0:	e0bffb17 	ldw	r2,-20(fp)
  8108d4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  8108d8:	e0bffc17 	ldw	r2,-16(fp)
  8108dc:	10800104 	addi	r2,r2,4
  8108e0:	1007883a 	mov	r3,r2
  8108e4:	e0bffb17 	ldw	r2,-20(fp)
  8108e8:	10800817 	ldw	r2,32(r2)
  8108ec:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  8108f0:	e0bffc17 	ldw	r2,-16(fp)
  8108f4:	10800104 	addi	r2,r2,4
  8108f8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  8108fc:	e0bffd17 	ldw	r2,-12(fp)
  810900:	1080800c 	andi	r2,r2,512
  810904:	103fbe26 	beq	r2,zero,810800 <__alt_data_end+0xfff10800>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  810908:	e0bffd17 	ldw	r2,-12(fp)
  81090c:	1004d43a 	srli	r2,r2,16
  810910:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  810914:	00001406 	br	810968 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  810918:	e0bffc17 	ldw	r2,-16(fp)
  81091c:	e0fffb17 	ldw	r3,-20(fp)
  810920:	18c00d17 	ldw	r3,52(r3)
  810924:	e13ffb17 	ldw	r4,-20(fp)
  810928:	20c7883a 	add	r3,r4,r3
  81092c:	18c20e04 	addi	r3,r3,2104
  810930:	18c00003 	ldbu	r3,0(r3)
  810934:	18c03fcc 	andi	r3,r3,255
  810938:	18c0201c 	xori	r3,r3,128
  81093c:	18ffe004 	addi	r3,r3,-128
  810940:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  810944:	e0bffb17 	ldw	r2,-20(fp)
  810948:	10800d17 	ldw	r2,52(r2)
  81094c:	10800044 	addi	r2,r2,1
  810950:	10c1ffcc 	andi	r3,r2,2047
  810954:	e0bffb17 	ldw	r2,-20(fp)
  810958:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  81095c:	e0bffa17 	ldw	r2,-24(fp)
  810960:	10bfffc4 	addi	r2,r2,-1
  810964:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  810968:	e0bffa17 	ldw	r2,-24(fp)
  81096c:	10000526 	beq	r2,zero,810984 <altera_avalon_jtag_uart_irq+0x1a8>
  810970:	e0bffb17 	ldw	r2,-20(fp)
  810974:	10c00d17 	ldw	r3,52(r2)
  810978:	e0bffb17 	ldw	r2,-20(fp)
  81097c:	10800c17 	ldw	r2,48(r2)
  810980:	18bfe51e 	bne	r3,r2,810918 <__alt_data_end+0xfff10918>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  810984:	e0bffa17 	ldw	r2,-24(fp)
  810988:	103f9d26 	beq	r2,zero,810800 <__alt_data_end+0xfff10800>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  81098c:	e0bffb17 	ldw	r2,-20(fp)
  810990:	10c00817 	ldw	r3,32(r2)
  810994:	00bfff44 	movi	r2,-3
  810998:	1886703a 	and	r3,r3,r2
  81099c:	e0bffb17 	ldw	r2,-20(fp)
  8109a0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  8109a4:	e0bffb17 	ldw	r2,-20(fp)
  8109a8:	10800017 	ldw	r2,0(r2)
  8109ac:	10800104 	addi	r2,r2,4
  8109b0:	1007883a 	mov	r3,r2
  8109b4:	e0bffb17 	ldw	r2,-20(fp)
  8109b8:	10800817 	ldw	r2,32(r2)
  8109bc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  8109c0:	e0bffc17 	ldw	r2,-16(fp)
  8109c4:	10800104 	addi	r2,r2,4
  8109c8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  8109cc:	003f8c06 	br	810800 <__alt_data_end+0xfff10800>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  8109d0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  8109d4:	0001883a 	nop
  8109d8:	e037883a 	mov	sp,fp
  8109dc:	df000017 	ldw	fp,0(sp)
  8109e0:	dec00104 	addi	sp,sp,4
  8109e4:	f800283a 	ret

008109e8 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  8109e8:	defff804 	addi	sp,sp,-32
  8109ec:	df000715 	stw	fp,28(sp)
  8109f0:	df000704 	addi	fp,sp,28
  8109f4:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  8109f8:	e0bffb17 	ldw	r2,-20(fp)
  8109fc:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  810a00:	e0bff917 	ldw	r2,-28(fp)
  810a04:	10800017 	ldw	r2,0(r2)
  810a08:	10800104 	addi	r2,r2,4
  810a0c:	10800037 	ldwio	r2,0(r2)
  810a10:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  810a14:	e0bffa17 	ldw	r2,-24(fp)
  810a18:	1081000c 	andi	r2,r2,1024
  810a1c:	10000b26 	beq	r2,zero,810a4c <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  810a20:	e0bff917 	ldw	r2,-28(fp)
  810a24:	10800017 	ldw	r2,0(r2)
  810a28:	10800104 	addi	r2,r2,4
  810a2c:	1007883a 	mov	r3,r2
  810a30:	e0bff917 	ldw	r2,-28(fp)
  810a34:	10800817 	ldw	r2,32(r2)
  810a38:	10810014 	ori	r2,r2,1024
  810a3c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  810a40:	e0bff917 	ldw	r2,-28(fp)
  810a44:	10000915 	stw	zero,36(r2)
  810a48:	00000a06 	br	810a74 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  810a4c:	e0bff917 	ldw	r2,-28(fp)
  810a50:	10c00917 	ldw	r3,36(r2)
  810a54:	00a00034 	movhi	r2,32768
  810a58:	10bfff04 	addi	r2,r2,-4
  810a5c:	10c00536 	bltu	r2,r3,810a74 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  810a60:	e0bff917 	ldw	r2,-28(fp)
  810a64:	10800917 	ldw	r2,36(r2)
  810a68:	10c00044 	addi	r3,r2,1
  810a6c:	e0bff917 	ldw	r2,-28(fp)
  810a70:	10c00915 	stw	r3,36(r2)
  810a74:	d0a04117 	ldw	r2,-32508(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  810a78:	e037883a 	mov	sp,fp
  810a7c:	df000017 	ldw	fp,0(sp)
  810a80:	dec00104 	addi	sp,sp,4
  810a84:	f800283a 	ret

00810a88 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  810a88:	defffd04 	addi	sp,sp,-12
  810a8c:	df000215 	stw	fp,8(sp)
  810a90:	df000204 	addi	fp,sp,8
  810a94:	e13ffe15 	stw	r4,-8(fp)
  810a98:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  810a9c:	00000506 	br	810ab4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  810aa0:	e0bfff17 	ldw	r2,-4(fp)
  810aa4:	1090000c 	andi	r2,r2,16384
  810aa8:	10000226 	beq	r2,zero,810ab4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  810aac:	00bffd44 	movi	r2,-11
  810ab0:	00000b06 	br	810ae0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  810ab4:	e0bffe17 	ldw	r2,-8(fp)
  810ab8:	10c00d17 	ldw	r3,52(r2)
  810abc:	e0bffe17 	ldw	r2,-8(fp)
  810ac0:	10800c17 	ldw	r2,48(r2)
  810ac4:	18800526 	beq	r3,r2,810adc <altera_avalon_jtag_uart_close+0x54>
  810ac8:	e0bffe17 	ldw	r2,-8(fp)
  810acc:	10c00917 	ldw	r3,36(r2)
  810ad0:	e0bffe17 	ldw	r2,-8(fp)
  810ad4:	10800117 	ldw	r2,4(r2)
  810ad8:	18bff136 	bltu	r3,r2,810aa0 <__alt_data_end+0xfff10aa0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  810adc:	0005883a 	mov	r2,zero
}
  810ae0:	e037883a 	mov	sp,fp
  810ae4:	df000017 	ldw	fp,0(sp)
  810ae8:	dec00104 	addi	sp,sp,4
  810aec:	f800283a 	ret

00810af0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  810af0:	defffa04 	addi	sp,sp,-24
  810af4:	df000515 	stw	fp,20(sp)
  810af8:	df000504 	addi	fp,sp,20
  810afc:	e13ffd15 	stw	r4,-12(fp)
  810b00:	e17ffe15 	stw	r5,-8(fp)
  810b04:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  810b08:	00bff9c4 	movi	r2,-25
  810b0c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  810b10:	e0bffe17 	ldw	r2,-8(fp)
  810b14:	10da8060 	cmpeqi	r3,r2,27137
  810b18:	1800031e 	bne	r3,zero,810b28 <altera_avalon_jtag_uart_ioctl+0x38>
  810b1c:	109a80a0 	cmpeqi	r2,r2,27138
  810b20:	1000181e 	bne	r2,zero,810b84 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
  810b24:	00002906 	br	810bcc <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  810b28:	e0bffd17 	ldw	r2,-12(fp)
  810b2c:	10c00117 	ldw	r3,4(r2)
  810b30:	00a00034 	movhi	r2,32768
  810b34:	10bfffc4 	addi	r2,r2,-1
  810b38:	18802126 	beq	r3,r2,810bc0 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
  810b3c:	e0bfff17 	ldw	r2,-4(fp)
  810b40:	10800017 	ldw	r2,0(r2)
  810b44:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  810b48:	e0bffc17 	ldw	r2,-16(fp)
  810b4c:	10800090 	cmplti	r2,r2,2
  810b50:	1000061e 	bne	r2,zero,810b6c <altera_avalon_jtag_uart_ioctl+0x7c>
  810b54:	e0fffc17 	ldw	r3,-16(fp)
  810b58:	00a00034 	movhi	r2,32768
  810b5c:	10bfffc4 	addi	r2,r2,-1
  810b60:	18800226 	beq	r3,r2,810b6c <altera_avalon_jtag_uart_ioctl+0x7c>
  810b64:	e0bffc17 	ldw	r2,-16(fp)
  810b68:	00000206 	br	810b74 <altera_avalon_jtag_uart_ioctl+0x84>
  810b6c:	00a00034 	movhi	r2,32768
  810b70:	10bfff84 	addi	r2,r2,-2
  810b74:	e0fffd17 	ldw	r3,-12(fp)
  810b78:	18800115 	stw	r2,4(r3)
      rc = 0;
  810b7c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  810b80:	00000f06 	br	810bc0 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  810b84:	e0bffd17 	ldw	r2,-12(fp)
  810b88:	10c00117 	ldw	r3,4(r2)
  810b8c:	00a00034 	movhi	r2,32768
  810b90:	10bfffc4 	addi	r2,r2,-1
  810b94:	18800c26 	beq	r3,r2,810bc8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  810b98:	e0bffd17 	ldw	r2,-12(fp)
  810b9c:	10c00917 	ldw	r3,36(r2)
  810ba0:	e0bffd17 	ldw	r2,-12(fp)
  810ba4:	10800117 	ldw	r2,4(r2)
  810ba8:	1885803a 	cmpltu	r2,r3,r2
  810bac:	10c03fcc 	andi	r3,r2,255
  810bb0:	e0bfff17 	ldw	r2,-4(fp)
  810bb4:	10c00015 	stw	r3,0(r2)
      rc = 0;
  810bb8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  810bbc:	00000206 	br	810bc8 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  810bc0:	0001883a 	nop
  810bc4:	00000106 	br	810bcc <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  810bc8:	0001883a 	nop

  default:
    break;
  }

  return rc;
  810bcc:	e0bffb17 	ldw	r2,-20(fp)
}
  810bd0:	e037883a 	mov	sp,fp
  810bd4:	df000017 	ldw	fp,0(sp)
  810bd8:	dec00104 	addi	sp,sp,4
  810bdc:	f800283a 	ret

00810be0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  810be0:	defff304 	addi	sp,sp,-52
  810be4:	dfc00c15 	stw	ra,48(sp)
  810be8:	df000b15 	stw	fp,44(sp)
  810bec:	df000b04 	addi	fp,sp,44
  810bf0:	e13ffc15 	stw	r4,-16(fp)
  810bf4:	e17ffd15 	stw	r5,-12(fp)
  810bf8:	e1bffe15 	stw	r6,-8(fp)
  810bfc:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  810c00:	e0bffd17 	ldw	r2,-12(fp)
  810c04:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  810c08:	00004706 	br	810d28 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  810c0c:	e0bffc17 	ldw	r2,-16(fp)
  810c10:	10800a17 	ldw	r2,40(r2)
  810c14:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  810c18:	e0bffc17 	ldw	r2,-16(fp)
  810c1c:	10800b17 	ldw	r2,44(r2)
  810c20:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  810c24:	e0fff717 	ldw	r3,-36(fp)
  810c28:	e0bff817 	ldw	r2,-32(fp)
  810c2c:	18800536 	bltu	r3,r2,810c44 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  810c30:	e0fff717 	ldw	r3,-36(fp)
  810c34:	e0bff817 	ldw	r2,-32(fp)
  810c38:	1885c83a 	sub	r2,r3,r2
  810c3c:	e0bff615 	stw	r2,-40(fp)
  810c40:	00000406 	br	810c54 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  810c44:	00c20004 	movi	r3,2048
  810c48:	e0bff817 	ldw	r2,-32(fp)
  810c4c:	1885c83a 	sub	r2,r3,r2
  810c50:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  810c54:	e0bff617 	ldw	r2,-40(fp)
  810c58:	10001e26 	beq	r2,zero,810cd4 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  810c5c:	e0fffe17 	ldw	r3,-8(fp)
  810c60:	e0bff617 	ldw	r2,-40(fp)
  810c64:	1880022e 	bgeu	r3,r2,810c70 <altera_avalon_jtag_uart_read+0x90>
        n = space;
  810c68:	e0bffe17 	ldw	r2,-8(fp)
  810c6c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  810c70:	e0bffc17 	ldw	r2,-16(fp)
  810c74:	10c00e04 	addi	r3,r2,56
  810c78:	e0bff817 	ldw	r2,-32(fp)
  810c7c:	1885883a 	add	r2,r3,r2
  810c80:	e1bff617 	ldw	r6,-40(fp)
  810c84:	100b883a 	mov	r5,r2
  810c88:	e13ff517 	ldw	r4,-44(fp)
  810c8c:	080f4440 	call	80f444 <memcpy>
      ptr   += n;
  810c90:	e0fff517 	ldw	r3,-44(fp)
  810c94:	e0bff617 	ldw	r2,-40(fp)
  810c98:	1885883a 	add	r2,r3,r2
  810c9c:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  810ca0:	e0fffe17 	ldw	r3,-8(fp)
  810ca4:	e0bff617 	ldw	r2,-40(fp)
  810ca8:	1885c83a 	sub	r2,r3,r2
  810cac:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  810cb0:	e0fff817 	ldw	r3,-32(fp)
  810cb4:	e0bff617 	ldw	r2,-40(fp)
  810cb8:	1885883a 	add	r2,r3,r2
  810cbc:	10c1ffcc 	andi	r3,r2,2047
  810cc0:	e0bffc17 	ldw	r2,-16(fp)
  810cc4:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  810cc8:	e0bffe17 	ldw	r2,-8(fp)
  810ccc:	00bfcf16 	blt	zero,r2,810c0c <__alt_data_end+0xfff10c0c>
  810cd0:	00000106 	br	810cd8 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  810cd4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  810cd8:	e0fff517 	ldw	r3,-44(fp)
  810cdc:	e0bffd17 	ldw	r2,-12(fp)
  810ce0:	1880141e 	bne	r3,r2,810d34 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  810ce4:	e0bfff17 	ldw	r2,-4(fp)
  810ce8:	1090000c 	andi	r2,r2,16384
  810cec:	1000131e 	bne	r2,zero,810d3c <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  810cf0:	0001883a 	nop
  810cf4:	e0bffc17 	ldw	r2,-16(fp)
  810cf8:	10c00a17 	ldw	r3,40(r2)
  810cfc:	e0bff717 	ldw	r2,-36(fp)
  810d00:	1880051e 	bne	r3,r2,810d18 <altera_avalon_jtag_uart_read+0x138>
  810d04:	e0bffc17 	ldw	r2,-16(fp)
  810d08:	10c00917 	ldw	r3,36(r2)
  810d0c:	e0bffc17 	ldw	r2,-16(fp)
  810d10:	10800117 	ldw	r2,4(r2)
  810d14:	18bff736 	bltu	r3,r2,810cf4 <__alt_data_end+0xfff10cf4>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  810d18:	e0bffc17 	ldw	r2,-16(fp)
  810d1c:	10c00a17 	ldw	r3,40(r2)
  810d20:	e0bff717 	ldw	r2,-36(fp)
  810d24:	18800726 	beq	r3,r2,810d44 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  810d28:	e0bffe17 	ldw	r2,-8(fp)
  810d2c:	00bfb716 	blt	zero,r2,810c0c <__alt_data_end+0xfff10c0c>
  810d30:	00000506 	br	810d48 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  810d34:	0001883a 	nop
  810d38:	00000306 	br	810d48 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  810d3c:	0001883a 	nop
  810d40:	00000106 	br	810d48 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  810d44:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  810d48:	e0fff517 	ldw	r3,-44(fp)
  810d4c:	e0bffd17 	ldw	r2,-12(fp)
  810d50:	18801826 	beq	r3,r2,810db4 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810d54:	0005303a 	rdctl	r2,status
  810d58:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810d5c:	e0fffb17 	ldw	r3,-20(fp)
  810d60:	00bfff84 	movi	r2,-2
  810d64:	1884703a 	and	r2,r3,r2
  810d68:	1001703a 	wrctl	status,r2
  
  return context;
  810d6c:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  810d70:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  810d74:	e0bffc17 	ldw	r2,-16(fp)
  810d78:	10800817 	ldw	r2,32(r2)
  810d7c:	10c00054 	ori	r3,r2,1
  810d80:	e0bffc17 	ldw	r2,-16(fp)
  810d84:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  810d88:	e0bffc17 	ldw	r2,-16(fp)
  810d8c:	10800017 	ldw	r2,0(r2)
  810d90:	10800104 	addi	r2,r2,4
  810d94:	1007883a 	mov	r3,r2
  810d98:	e0bffc17 	ldw	r2,-16(fp)
  810d9c:	10800817 	ldw	r2,32(r2)
  810da0:	18800035 	stwio	r2,0(r3)
  810da4:	e0bffa17 	ldw	r2,-24(fp)
  810da8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810dac:	e0bff917 	ldw	r2,-28(fp)
  810db0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  810db4:	e0fff517 	ldw	r3,-44(fp)
  810db8:	e0bffd17 	ldw	r2,-12(fp)
  810dbc:	18800426 	beq	r3,r2,810dd0 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
  810dc0:	e0fff517 	ldw	r3,-44(fp)
  810dc4:	e0bffd17 	ldw	r2,-12(fp)
  810dc8:	1885c83a 	sub	r2,r3,r2
  810dcc:	00000606 	br	810de8 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
  810dd0:	e0bfff17 	ldw	r2,-4(fp)
  810dd4:	1090000c 	andi	r2,r2,16384
  810dd8:	10000226 	beq	r2,zero,810de4 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
  810ddc:	00bffd44 	movi	r2,-11
  810de0:	00000106 	br	810de8 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
  810de4:	00bffec4 	movi	r2,-5
}
  810de8:	e037883a 	mov	sp,fp
  810dec:	dfc00117 	ldw	ra,4(sp)
  810df0:	df000017 	ldw	fp,0(sp)
  810df4:	dec00204 	addi	sp,sp,8
  810df8:	f800283a 	ret

00810dfc <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  810dfc:	defff304 	addi	sp,sp,-52
  810e00:	dfc00c15 	stw	ra,48(sp)
  810e04:	df000b15 	stw	fp,44(sp)
  810e08:	df000b04 	addi	fp,sp,44
  810e0c:	e13ffc15 	stw	r4,-16(fp)
  810e10:	e17ffd15 	stw	r5,-12(fp)
  810e14:	e1bffe15 	stw	r6,-8(fp)
  810e18:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  810e1c:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  810e20:	e0bffd17 	ldw	r2,-12(fp)
  810e24:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  810e28:	00003706 	br	810f08 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  810e2c:	e0bffc17 	ldw	r2,-16(fp)
  810e30:	10800c17 	ldw	r2,48(r2)
  810e34:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
  810e38:	e0bffc17 	ldw	r2,-16(fp)
  810e3c:	10800d17 	ldw	r2,52(r2)
  810e40:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  810e44:	e0fff917 	ldw	r3,-28(fp)
  810e48:	e0bff517 	ldw	r2,-44(fp)
  810e4c:	1880062e 	bgeu	r3,r2,810e68 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  810e50:	e0fff517 	ldw	r3,-44(fp)
  810e54:	e0bff917 	ldw	r2,-28(fp)
  810e58:	1885c83a 	sub	r2,r3,r2
  810e5c:	10bfffc4 	addi	r2,r2,-1
  810e60:	e0bff615 	stw	r2,-40(fp)
  810e64:	00000b06 	br	810e94 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  810e68:	e0bff517 	ldw	r2,-44(fp)
  810e6c:	10000526 	beq	r2,zero,810e84 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  810e70:	00c20004 	movi	r3,2048
  810e74:	e0bff917 	ldw	r2,-28(fp)
  810e78:	1885c83a 	sub	r2,r3,r2
  810e7c:	e0bff615 	stw	r2,-40(fp)
  810e80:	00000406 	br	810e94 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  810e84:	00c1ffc4 	movi	r3,2047
  810e88:	e0bff917 	ldw	r2,-28(fp)
  810e8c:	1885c83a 	sub	r2,r3,r2
  810e90:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  810e94:	e0bff617 	ldw	r2,-40(fp)
  810e98:	10001e26 	beq	r2,zero,810f14 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  810e9c:	e0fffe17 	ldw	r3,-8(fp)
  810ea0:	e0bff617 	ldw	r2,-40(fp)
  810ea4:	1880022e 	bgeu	r3,r2,810eb0 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  810ea8:	e0bffe17 	ldw	r2,-8(fp)
  810eac:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  810eb0:	e0bffc17 	ldw	r2,-16(fp)
  810eb4:	10c20e04 	addi	r3,r2,2104
  810eb8:	e0bff917 	ldw	r2,-28(fp)
  810ebc:	1885883a 	add	r2,r3,r2
  810ec0:	e1bff617 	ldw	r6,-40(fp)
  810ec4:	e17ffd17 	ldw	r5,-12(fp)
  810ec8:	1009883a 	mov	r4,r2
  810ecc:	080f4440 	call	80f444 <memcpy>
      ptr   += n;
  810ed0:	e0fffd17 	ldw	r3,-12(fp)
  810ed4:	e0bff617 	ldw	r2,-40(fp)
  810ed8:	1885883a 	add	r2,r3,r2
  810edc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  810ee0:	e0fffe17 	ldw	r3,-8(fp)
  810ee4:	e0bff617 	ldw	r2,-40(fp)
  810ee8:	1885c83a 	sub	r2,r3,r2
  810eec:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  810ef0:	e0fff917 	ldw	r3,-28(fp)
  810ef4:	e0bff617 	ldw	r2,-40(fp)
  810ef8:	1885883a 	add	r2,r3,r2
  810efc:	10c1ffcc 	andi	r3,r2,2047
  810f00:	e0bffc17 	ldw	r2,-16(fp)
  810f04:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  810f08:	e0bffe17 	ldw	r2,-8(fp)
  810f0c:	00bfc716 	blt	zero,r2,810e2c <__alt_data_end+0xfff10e2c>
  810f10:	00000106 	br	810f18 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  810f14:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810f18:	0005303a 	rdctl	r2,status
  810f1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810f20:	e0fffb17 	ldw	r3,-20(fp)
  810f24:	00bfff84 	movi	r2,-2
  810f28:	1884703a 	and	r2,r3,r2
  810f2c:	1001703a 	wrctl	status,r2
  
  return context;
  810f30:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  810f34:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  810f38:	e0bffc17 	ldw	r2,-16(fp)
  810f3c:	10800817 	ldw	r2,32(r2)
  810f40:	10c00094 	ori	r3,r2,2
  810f44:	e0bffc17 	ldw	r2,-16(fp)
  810f48:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  810f4c:	e0bffc17 	ldw	r2,-16(fp)
  810f50:	10800017 	ldw	r2,0(r2)
  810f54:	10800104 	addi	r2,r2,4
  810f58:	1007883a 	mov	r3,r2
  810f5c:	e0bffc17 	ldw	r2,-16(fp)
  810f60:	10800817 	ldw	r2,32(r2)
  810f64:	18800035 	stwio	r2,0(r3)
  810f68:	e0bffa17 	ldw	r2,-24(fp)
  810f6c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810f70:	e0bff817 	ldw	r2,-32(fp)
  810f74:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  810f78:	e0bffe17 	ldw	r2,-8(fp)
  810f7c:	0080100e 	bge	zero,r2,810fc0 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  810f80:	e0bfff17 	ldw	r2,-4(fp)
  810f84:	1090000c 	andi	r2,r2,16384
  810f88:	1000101e 	bne	r2,zero,810fcc <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  810f8c:	0001883a 	nop
  810f90:	e0bffc17 	ldw	r2,-16(fp)
  810f94:	10c00d17 	ldw	r3,52(r2)
  810f98:	e0bff517 	ldw	r2,-44(fp)
  810f9c:	1880051e 	bne	r3,r2,810fb4 <altera_avalon_jtag_uart_write+0x1b8>
  810fa0:	e0bffc17 	ldw	r2,-16(fp)
  810fa4:	10c00917 	ldw	r3,36(r2)
  810fa8:	e0bffc17 	ldw	r2,-16(fp)
  810fac:	10800117 	ldw	r2,4(r2)
  810fb0:	18bff736 	bltu	r3,r2,810f90 <__alt_data_end+0xfff10f90>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  810fb4:	e0bffc17 	ldw	r2,-16(fp)
  810fb8:	10800917 	ldw	r2,36(r2)
  810fbc:	1000051e 	bne	r2,zero,810fd4 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  810fc0:	e0bffe17 	ldw	r2,-8(fp)
  810fc4:	00bfd016 	blt	zero,r2,810f08 <__alt_data_end+0xfff10f08>
  810fc8:	00000306 	br	810fd8 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  810fcc:	0001883a 	nop
  810fd0:	00000106 	br	810fd8 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
  810fd4:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  810fd8:	e0fffd17 	ldw	r3,-12(fp)
  810fdc:	e0bff717 	ldw	r2,-36(fp)
  810fe0:	18800426 	beq	r3,r2,810ff4 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  810fe4:	e0fffd17 	ldw	r3,-12(fp)
  810fe8:	e0bff717 	ldw	r2,-36(fp)
  810fec:	1885c83a 	sub	r2,r3,r2
  810ff0:	00000606 	br	81100c <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  810ff4:	e0bfff17 	ldw	r2,-4(fp)
  810ff8:	1090000c 	andi	r2,r2,16384
  810ffc:	10000226 	beq	r2,zero,811008 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  811000:	00bffd44 	movi	r2,-11
  811004:	00000106 	br	81100c <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  811008:	00bffec4 	movi	r2,-5
}
  81100c:	e037883a 	mov	sp,fp
  811010:	dfc00117 	ldw	ra,4(sp)
  811014:	df000017 	ldw	fp,0(sp)
  811018:	dec00204 	addi	sp,sp,8
  81101c:	f800283a 	ret

00811020 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  811020:	defffa04 	addi	sp,sp,-24
  811024:	dfc00515 	stw	ra,20(sp)
  811028:	df000415 	stw	fp,16(sp)
  81102c:	df000404 	addi	fp,sp,16
  811030:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  811034:	0007883a 	mov	r3,zero
  811038:	e0bfff17 	ldw	r2,-4(fp)
  81103c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  811040:	e0bfff17 	ldw	r2,-4(fp)
  811044:	10800104 	addi	r2,r2,4
  811048:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81104c:	0005303a 	rdctl	r2,status
  811050:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811054:	e0fffd17 	ldw	r3,-12(fp)
  811058:	00bfff84 	movi	r2,-2
  81105c:	1884703a 	and	r2,r3,r2
  811060:	1001703a 	wrctl	status,r2
  
  return context;
  811064:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  811068:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  81106c:	0811bd40 	call	811bd4 <alt_tick>
  811070:	e0bffc17 	ldw	r2,-16(fp)
  811074:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811078:	e0bffe17 	ldw	r2,-8(fp)
  81107c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  811080:	0001883a 	nop
  811084:	e037883a 	mov	sp,fp
  811088:	dfc00117 	ldw	ra,4(sp)
  81108c:	df000017 	ldw	fp,0(sp)
  811090:	dec00204 	addi	sp,sp,8
  811094:	f800283a 	ret

00811098 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  811098:	defff804 	addi	sp,sp,-32
  81109c:	dfc00715 	stw	ra,28(sp)
  8110a0:	df000615 	stw	fp,24(sp)
  8110a4:	df000604 	addi	fp,sp,24
  8110a8:	e13ffc15 	stw	r4,-16(fp)
  8110ac:	e17ffd15 	stw	r5,-12(fp)
  8110b0:	e1bffe15 	stw	r6,-8(fp)
  8110b4:	e1ffff15 	stw	r7,-4(fp)
  8110b8:	e0bfff17 	ldw	r2,-4(fp)
  8110bc:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  8110c0:	d0a04117 	ldw	r2,-32508(gp)
  8110c4:	1000021e 	bne	r2,zero,8110d0 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
  8110c8:	e0bffb17 	ldw	r2,-20(fp)
  8110cc:	d0a04115 	stw	r2,-32508(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  8110d0:	e0bffc17 	ldw	r2,-16(fp)
  8110d4:	10800104 	addi	r2,r2,4
  8110d8:	00c001c4 	movi	r3,7
  8110dc:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  8110e0:	d8000015 	stw	zero,0(sp)
  8110e4:	e1fffc17 	ldw	r7,-16(fp)
  8110e8:	01802074 	movhi	r6,129
  8110ec:	31840804 	addi	r6,r6,4128
  8110f0:	e17ffe17 	ldw	r5,-8(fp)
  8110f4:	e13ffd17 	ldw	r4,-12(fp)
  8110f8:	080f6b40 	call	80f6b4 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  8110fc:	0001883a 	nop
  811100:	e037883a 	mov	sp,fp
  811104:	dfc00117 	ldw	ra,4(sp)
  811108:	df000017 	ldw	fp,0(sp)
  81110c:	dec00204 	addi	sp,sp,8
  811110:	f800283a 	ret

00811114 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  811114:	defff504 	addi	sp,sp,-44
  811118:	df000a15 	stw	fp,40(sp)
  81111c:	df000a04 	addi	fp,sp,40
  811120:	e13ffc15 	stw	r4,-16(fp)
  811124:	e17ffd15 	stw	r5,-12(fp)
  811128:	e1bffe15 	stw	r6,-8(fp)
  81112c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  811130:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  811134:	d0a04117 	ldw	r2,-32508(gp)
  
  if (alt_ticks_per_second ())
  811138:	10003c26 	beq	r2,zero,81122c <alt_alarm_start+0x118>
  {
    if (alarm)
  81113c:	e0bffc17 	ldw	r2,-16(fp)
  811140:	10003826 	beq	r2,zero,811224 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
  811144:	e0bffc17 	ldw	r2,-16(fp)
  811148:	e0fffe17 	ldw	r3,-8(fp)
  81114c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  811150:	e0bffc17 	ldw	r2,-16(fp)
  811154:	e0ffff17 	ldw	r3,-4(fp)
  811158:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81115c:	0005303a 	rdctl	r2,status
  811160:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811164:	e0fff917 	ldw	r3,-28(fp)
  811168:	00bfff84 	movi	r2,-2
  81116c:	1884703a 	and	r2,r3,r2
  811170:	1001703a 	wrctl	status,r2
  
  return context;
  811174:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
  811178:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  81117c:	d0a04217 	ldw	r2,-32504(gp)
      
      current_nticks = alt_nticks();
  811180:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  811184:	e0fffd17 	ldw	r3,-12(fp)
  811188:	e0bff617 	ldw	r2,-40(fp)
  81118c:	1885883a 	add	r2,r3,r2
  811190:	10c00044 	addi	r3,r2,1
  811194:	e0bffc17 	ldw	r2,-16(fp)
  811198:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  81119c:	e0bffc17 	ldw	r2,-16(fp)
  8111a0:	10c00217 	ldw	r3,8(r2)
  8111a4:	e0bff617 	ldw	r2,-40(fp)
  8111a8:	1880042e 	bgeu	r3,r2,8111bc <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
  8111ac:	e0bffc17 	ldw	r2,-16(fp)
  8111b0:	00c00044 	movi	r3,1
  8111b4:	10c00405 	stb	r3,16(r2)
  8111b8:	00000206 	br	8111c4 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
  8111bc:	e0bffc17 	ldw	r2,-16(fp)
  8111c0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  8111c4:	e0bffc17 	ldw	r2,-16(fp)
  8111c8:	d0e01e04 	addi	r3,gp,-32648
  8111cc:	e0fffa15 	stw	r3,-24(fp)
  8111d0:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  8111d4:	e0bffb17 	ldw	r2,-20(fp)
  8111d8:	e0fffa17 	ldw	r3,-24(fp)
  8111dc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  8111e0:	e0bffa17 	ldw	r2,-24(fp)
  8111e4:	10c00017 	ldw	r3,0(r2)
  8111e8:	e0bffb17 	ldw	r2,-20(fp)
  8111ec:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  8111f0:	e0bffa17 	ldw	r2,-24(fp)
  8111f4:	10800017 	ldw	r2,0(r2)
  8111f8:	e0fffb17 	ldw	r3,-20(fp)
  8111fc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  811200:	e0bffa17 	ldw	r2,-24(fp)
  811204:	e0fffb17 	ldw	r3,-20(fp)
  811208:	10c00015 	stw	r3,0(r2)
  81120c:	e0bff817 	ldw	r2,-32(fp)
  811210:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811214:	e0bff717 	ldw	r2,-36(fp)
  811218:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  81121c:	0005883a 	mov	r2,zero
  811220:	00000306 	br	811230 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
  811224:	00bffa84 	movi	r2,-22
  811228:	00000106 	br	811230 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
  81122c:	00bfde84 	movi	r2,-134
  }
}
  811230:	e037883a 	mov	sp,fp
  811234:	df000017 	ldw	fp,0(sp)
  811238:	dec00104 	addi	sp,sp,4
  81123c:	f800283a 	ret

00811240 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  811240:	defffe04 	addi	sp,sp,-8
  811244:	dfc00115 	stw	ra,4(sp)
  811248:	df000015 	stw	fp,0(sp)
  81124c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  811250:	d0a01d17 	ldw	r2,-32652(gp)
  811254:	10000326 	beq	r2,zero,811264 <alt_get_errno+0x24>
  811258:	d0a01d17 	ldw	r2,-32652(gp)
  81125c:	103ee83a 	callr	r2
  811260:	00000106 	br	811268 <alt_get_errno+0x28>
  811264:	d0a04304 	addi	r2,gp,-32500
}
  811268:	e037883a 	mov	sp,fp
  81126c:	dfc00117 	ldw	ra,4(sp)
  811270:	df000017 	ldw	fp,0(sp)
  811274:	dec00204 	addi	sp,sp,8
  811278:	f800283a 	ret

0081127c <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  81127c:	defffb04 	addi	sp,sp,-20
  811280:	dfc00415 	stw	ra,16(sp)
  811284:	df000315 	stw	fp,12(sp)
  811288:	df000304 	addi	fp,sp,12
  81128c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  811290:	e0bfff17 	ldw	r2,-4(fp)
  811294:	10000816 	blt	r2,zero,8112b8 <close+0x3c>
  811298:	01400304 	movi	r5,12
  81129c:	e13fff17 	ldw	r4,-4(fp)
  8112a0:	080b2480 	call	80b248 <__mulsi3>
  8112a4:	1007883a 	mov	r3,r2
  8112a8:	008020b4 	movhi	r2,130
  8112ac:	10acd804 	addi	r2,r2,-19616
  8112b0:	1885883a 	add	r2,r3,r2
  8112b4:	00000106 	br	8112bc <close+0x40>
  8112b8:	0005883a 	mov	r2,zero
  8112bc:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  8112c0:	e0bffd17 	ldw	r2,-12(fp)
  8112c4:	10001926 	beq	r2,zero,81132c <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  8112c8:	e0bffd17 	ldw	r2,-12(fp)
  8112cc:	10800017 	ldw	r2,0(r2)
  8112d0:	10800417 	ldw	r2,16(r2)
  8112d4:	10000626 	beq	r2,zero,8112f0 <close+0x74>
  8112d8:	e0bffd17 	ldw	r2,-12(fp)
  8112dc:	10800017 	ldw	r2,0(r2)
  8112e0:	10800417 	ldw	r2,16(r2)
  8112e4:	e13ffd17 	ldw	r4,-12(fp)
  8112e8:	103ee83a 	callr	r2
  8112ec:	00000106 	br	8112f4 <close+0x78>
  8112f0:	0005883a 	mov	r2,zero
  8112f4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  8112f8:	e13fff17 	ldw	r4,-4(fp)
  8112fc:	0811ab40 	call	811ab4 <alt_release_fd>
    if (rval < 0)
  811300:	e0bffe17 	ldw	r2,-8(fp)
  811304:	1000070e 	bge	r2,zero,811324 <close+0xa8>
    {
      ALT_ERRNO = -rval;
  811308:	08112400 	call	811240 <alt_get_errno>
  81130c:	1007883a 	mov	r3,r2
  811310:	e0bffe17 	ldw	r2,-8(fp)
  811314:	0085c83a 	sub	r2,zero,r2
  811318:	18800015 	stw	r2,0(r3)
      return -1;
  81131c:	00bfffc4 	movi	r2,-1
  811320:	00000706 	br	811340 <close+0xc4>
    }
    return 0;
  811324:	0005883a 	mov	r2,zero
  811328:	00000506 	br	811340 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  81132c:	08112400 	call	811240 <alt_get_errno>
  811330:	1007883a 	mov	r3,r2
  811334:	00801444 	movi	r2,81
  811338:	18800015 	stw	r2,0(r3)
    return -1;
  81133c:	00bfffc4 	movi	r2,-1
  }
}
  811340:	e037883a 	mov	sp,fp
  811344:	dfc00117 	ldw	ra,4(sp)
  811348:	df000017 	ldw	fp,0(sp)
  81134c:	dec00204 	addi	sp,sp,8
  811350:	f800283a 	ret

00811354 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  811354:	defffc04 	addi	sp,sp,-16
  811358:	df000315 	stw	fp,12(sp)
  81135c:	df000304 	addi	fp,sp,12
  811360:	e13ffd15 	stw	r4,-12(fp)
  811364:	e17ffe15 	stw	r5,-8(fp)
  811368:	e1bfff15 	stw	r6,-4(fp)
  return len;
  81136c:	e0bfff17 	ldw	r2,-4(fp)
}
  811370:	e037883a 	mov	sp,fp
  811374:	df000017 	ldw	fp,0(sp)
  811378:	dec00104 	addi	sp,sp,4
  81137c:	f800283a 	ret

00811380 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  811380:	defffe04 	addi	sp,sp,-8
  811384:	dfc00115 	stw	ra,4(sp)
  811388:	df000015 	stw	fp,0(sp)
  81138c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  811390:	d0a01d17 	ldw	r2,-32652(gp)
  811394:	10000326 	beq	r2,zero,8113a4 <alt_get_errno+0x24>
  811398:	d0a01d17 	ldw	r2,-32652(gp)
  81139c:	103ee83a 	callr	r2
  8113a0:	00000106 	br	8113a8 <alt_get_errno+0x28>
  8113a4:	d0a04304 	addi	r2,gp,-32500
}
  8113a8:	e037883a 	mov	sp,fp
  8113ac:	dfc00117 	ldw	ra,4(sp)
  8113b0:	df000017 	ldw	fp,0(sp)
  8113b4:	dec00204 	addi	sp,sp,8
  8113b8:	f800283a 	ret

008113bc <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  8113bc:	defffa04 	addi	sp,sp,-24
  8113c0:	dfc00515 	stw	ra,20(sp)
  8113c4:	df000415 	stw	fp,16(sp)
  8113c8:	df000404 	addi	fp,sp,16
  8113cc:	e13ffe15 	stw	r4,-8(fp)
  8113d0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  8113d4:	e0bffe17 	ldw	r2,-8(fp)
  8113d8:	10000326 	beq	r2,zero,8113e8 <alt_dev_llist_insert+0x2c>
  8113dc:	e0bffe17 	ldw	r2,-8(fp)
  8113e0:	10800217 	ldw	r2,8(r2)
  8113e4:	1000061e 	bne	r2,zero,811400 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  8113e8:	08113800 	call	811380 <alt_get_errno>
  8113ec:	1007883a 	mov	r3,r2
  8113f0:	00800584 	movi	r2,22
  8113f4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  8113f8:	00bffa84 	movi	r2,-22
  8113fc:	00001306 	br	81144c <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  811400:	e0bffe17 	ldw	r2,-8(fp)
  811404:	e0ffff17 	ldw	r3,-4(fp)
  811408:	e0fffc15 	stw	r3,-16(fp)
  81140c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  811410:	e0bffd17 	ldw	r2,-12(fp)
  811414:	e0fffc17 	ldw	r3,-16(fp)
  811418:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  81141c:	e0bffc17 	ldw	r2,-16(fp)
  811420:	10c00017 	ldw	r3,0(r2)
  811424:	e0bffd17 	ldw	r2,-12(fp)
  811428:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  81142c:	e0bffc17 	ldw	r2,-16(fp)
  811430:	10800017 	ldw	r2,0(r2)
  811434:	e0fffd17 	ldw	r3,-12(fp)
  811438:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  81143c:	e0bffc17 	ldw	r2,-16(fp)
  811440:	e0fffd17 	ldw	r3,-12(fp)
  811444:	10c00015 	stw	r3,0(r2)

  return 0;  
  811448:	0005883a 	mov	r2,zero
}
  81144c:	e037883a 	mov	sp,fp
  811450:	dfc00117 	ldw	ra,4(sp)
  811454:	df000017 	ldw	fp,0(sp)
  811458:	dec00204 	addi	sp,sp,8
  81145c:	f800283a 	ret

00811460 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  811460:	defffe04 	addi	sp,sp,-8
  811464:	dfc00115 	stw	ra,4(sp)
  811468:	df000015 	stw	fp,0(sp)
  81146c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  811470:	d0a01d17 	ldw	r2,-32652(gp)
  811474:	10000326 	beq	r2,zero,811484 <alt_get_errno+0x24>
  811478:	d0a01d17 	ldw	r2,-32652(gp)
  81147c:	103ee83a 	callr	r2
  811480:	00000106 	br	811488 <alt_get_errno+0x28>
  811484:	d0a04304 	addi	r2,gp,-32500
}
  811488:	e037883a 	mov	sp,fp
  81148c:	dfc00117 	ldw	ra,4(sp)
  811490:	df000017 	ldw	fp,0(sp)
  811494:	dec00204 	addi	sp,sp,8
  811498:	f800283a 	ret

0081149c <alt_dma_rxchan_open>:
 *
 * The return value will be NULL on failure, and non-NULL otherwise. 
 */

alt_dma_rxchan alt_dma_rxchan_open (const char* name)
{
  81149c:	defffc04 	addi	sp,sp,-16
  8114a0:	dfc00315 	stw	ra,12(sp)
  8114a4:	df000215 	stw	fp,8(sp)
  8114a8:	df000204 	addi	fp,sp,8
  8114ac:	e13fff15 	stw	r4,-4(fp)
  alt_dma_rxchan dev;

  dev = (alt_dma_rxchan) alt_find_dev (name, &alt_dma_rxchan_list);
  8114b0:	d1601904 	addi	r5,gp,-32668
  8114b4:	e13fff17 	ldw	r4,-4(fp)
  8114b8:	08116400 	call	811640 <alt_find_dev>
  8114bc:	e0bffe15 	stw	r2,-8(fp)

  if (!dev)
  8114c0:	e0bffe17 	ldw	r2,-8(fp)
  8114c4:	1000041e 	bne	r2,zero,8114d8 <alt_dma_rxchan_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
  8114c8:	08114600 	call	811460 <alt_get_errno>
  8114cc:	1007883a 	mov	r3,r2
  8114d0:	008004c4 	movi	r2,19
  8114d4:	18800015 	stw	r2,0(r3)
  }

  return dev;
  8114d8:	e0bffe17 	ldw	r2,-8(fp)
}
  8114dc:	e037883a 	mov	sp,fp
  8114e0:	dfc00117 	ldw	ra,4(sp)
  8114e4:	df000017 	ldw	fp,0(sp)
  8114e8:	dec00204 	addi	sp,sp,8
  8114ec:	f800283a 	ret

008114f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  8114f0:	defffe04 	addi	sp,sp,-8
  8114f4:	dfc00115 	stw	ra,4(sp)
  8114f8:	df000015 	stw	fp,0(sp)
  8114fc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  811500:	d0a01d17 	ldw	r2,-32652(gp)
  811504:	10000326 	beq	r2,zero,811514 <alt_get_errno+0x24>
  811508:	d0a01d17 	ldw	r2,-32652(gp)
  81150c:	103ee83a 	callr	r2
  811510:	00000106 	br	811518 <alt_get_errno+0x28>
  811514:	d0a04304 	addi	r2,gp,-32500
}
  811518:	e037883a 	mov	sp,fp
  81151c:	dfc00117 	ldw	ra,4(sp)
  811520:	df000017 	ldw	fp,0(sp)
  811524:	dec00204 	addi	sp,sp,8
  811528:	f800283a 	ret

0081152c <alt_dma_txchan_open>:
 *
 * The return value will be NULL on failure, and non-NULL otherwise. 
 */

alt_dma_txchan alt_dma_txchan_open (const char* name)
{
  81152c:	defffc04 	addi	sp,sp,-16
  811530:	dfc00315 	stw	ra,12(sp)
  811534:	df000215 	stw	fp,8(sp)
  811538:	df000204 	addi	fp,sp,8
  81153c:	e13fff15 	stw	r4,-4(fp)
  alt_dma_txchan dev;

  dev = (alt_dma_txchan) alt_find_dev (name, &alt_dma_txchan_list);
  811540:	d1601b04 	addi	r5,gp,-32660
  811544:	e13fff17 	ldw	r4,-4(fp)
  811548:	08116400 	call	811640 <alt_find_dev>
  81154c:	e0bffe15 	stw	r2,-8(fp)

  if (!dev)
  811550:	e0bffe17 	ldw	r2,-8(fp)
  811554:	1000041e 	bne	r2,zero,811568 <alt_dma_txchan_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
  811558:	08114f00 	call	8114f0 <alt_get_errno>
  81155c:	1007883a 	mov	r3,r2
  811560:	008004c4 	movi	r2,19
  811564:	18800015 	stw	r2,0(r3)
  }

  return dev;
  811568:	e0bffe17 	ldw	r2,-8(fp)
}
  81156c:	e037883a 	mov	sp,fp
  811570:	dfc00117 	ldw	ra,4(sp)
  811574:	df000017 	ldw	fp,0(sp)
  811578:	dec00204 	addi	sp,sp,8
  81157c:	f800283a 	ret

00811580 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  811580:	defffd04 	addi	sp,sp,-12
  811584:	dfc00215 	stw	ra,8(sp)
  811588:	df000115 	stw	fp,4(sp)
  81158c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  811590:	00802074 	movhi	r2,129
  811594:	1088bd04 	addi	r2,r2,8948
  811598:	e0bfff15 	stw	r2,-4(fp)
  81159c:	00000606 	br	8115b8 <_do_ctors+0x38>
        (*ctor) (); 
  8115a0:	e0bfff17 	ldw	r2,-4(fp)
  8115a4:	10800017 	ldw	r2,0(r2)
  8115a8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  8115ac:	e0bfff17 	ldw	r2,-4(fp)
  8115b0:	10bfff04 	addi	r2,r2,-4
  8115b4:	e0bfff15 	stw	r2,-4(fp)
  8115b8:	e0ffff17 	ldw	r3,-4(fp)
  8115bc:	00802074 	movhi	r2,129
  8115c0:	1088be04 	addi	r2,r2,8952
  8115c4:	18bff62e 	bgeu	r3,r2,8115a0 <__alt_data_end+0xfff115a0>
        (*ctor) (); 
}
  8115c8:	0001883a 	nop
  8115cc:	e037883a 	mov	sp,fp
  8115d0:	dfc00117 	ldw	ra,4(sp)
  8115d4:	df000017 	ldw	fp,0(sp)
  8115d8:	dec00204 	addi	sp,sp,8
  8115dc:	f800283a 	ret

008115e0 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  8115e0:	defffd04 	addi	sp,sp,-12
  8115e4:	dfc00215 	stw	ra,8(sp)
  8115e8:	df000115 	stw	fp,4(sp)
  8115ec:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  8115f0:	00802074 	movhi	r2,129
  8115f4:	1088bd04 	addi	r2,r2,8948
  8115f8:	e0bfff15 	stw	r2,-4(fp)
  8115fc:	00000606 	br	811618 <_do_dtors+0x38>
        (*dtor) (); 
  811600:	e0bfff17 	ldw	r2,-4(fp)
  811604:	10800017 	ldw	r2,0(r2)
  811608:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  81160c:	e0bfff17 	ldw	r2,-4(fp)
  811610:	10bfff04 	addi	r2,r2,-4
  811614:	e0bfff15 	stw	r2,-4(fp)
  811618:	e0ffff17 	ldw	r3,-4(fp)
  81161c:	00802074 	movhi	r2,129
  811620:	1088be04 	addi	r2,r2,8952
  811624:	18bff62e 	bgeu	r3,r2,811600 <__alt_data_end+0xfff11600>
        (*dtor) (); 
}
  811628:	0001883a 	nop
  81162c:	e037883a 	mov	sp,fp
  811630:	dfc00117 	ldw	ra,4(sp)
  811634:	df000017 	ldw	fp,0(sp)
  811638:	dec00204 	addi	sp,sp,8
  81163c:	f800283a 	ret

00811640 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  811640:	defffa04 	addi	sp,sp,-24
  811644:	dfc00515 	stw	ra,20(sp)
  811648:	df000415 	stw	fp,16(sp)
  81164c:	df000404 	addi	fp,sp,16
  811650:	e13ffe15 	stw	r4,-8(fp)
  811654:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  811658:	e0bfff17 	ldw	r2,-4(fp)
  81165c:	10800017 	ldw	r2,0(r2)
  811660:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  811664:	e13ffe17 	ldw	r4,-8(fp)
  811668:	0811f940 	call	811f94 <strlen>
  81166c:	10800044 	addi	r2,r2,1
  811670:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  811674:	00000d06 	br	8116ac <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  811678:	e0bffc17 	ldw	r2,-16(fp)
  81167c:	10800217 	ldw	r2,8(r2)
  811680:	e0fffd17 	ldw	r3,-12(fp)
  811684:	180d883a 	mov	r6,r3
  811688:	e17ffe17 	ldw	r5,-8(fp)
  81168c:	1009883a 	mov	r4,r2
  811690:	0811f180 	call	811f18 <memcmp>
  811694:	1000021e 	bne	r2,zero,8116a0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  811698:	e0bffc17 	ldw	r2,-16(fp)
  81169c:	00000706 	br	8116bc <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  8116a0:	e0bffc17 	ldw	r2,-16(fp)
  8116a4:	10800017 	ldw	r2,0(r2)
  8116a8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  8116ac:	e0fffc17 	ldw	r3,-16(fp)
  8116b0:	e0bfff17 	ldw	r2,-4(fp)
  8116b4:	18bff01e 	bne	r3,r2,811678 <__alt_data_end+0xfff11678>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  8116b8:	0005883a 	mov	r2,zero
}
  8116bc:	e037883a 	mov	sp,fp
  8116c0:	dfc00117 	ldw	ra,4(sp)
  8116c4:	df000017 	ldw	fp,0(sp)
  8116c8:	dec00204 	addi	sp,sp,8
  8116cc:	f800283a 	ret

008116d0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  8116d0:	defff804 	addi	sp,sp,-32
  8116d4:	dfc00715 	stw	ra,28(sp)
  8116d8:	df000615 	stw	fp,24(sp)
  8116dc:	dc000515 	stw	r16,20(sp)
  8116e0:	df000604 	addi	fp,sp,24
  8116e4:	e13ffb15 	stw	r4,-20(fp)
  8116e8:	e17ffc15 	stw	r5,-16(fp)
  8116ec:	e1bffd15 	stw	r6,-12(fp)
  8116f0:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
  8116f4:	e1bffe17 	ldw	r6,-8(fp)
  8116f8:	e17ffd17 	ldw	r5,-12(fp)
  8116fc:	e13ffc17 	ldw	r4,-16(fp)
  811700:	08119580 	call	811958 <open>
  811704:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
  811708:	e0bffa17 	ldw	r2,-24(fp)
  81170c:	10002216 	blt	r2,zero,811798 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  811710:	040020b4 	movhi	r16,130
  811714:	842cd804 	addi	r16,r16,-19616
  811718:	e0bffa17 	ldw	r2,-24(fp)
  81171c:	01400304 	movi	r5,12
  811720:	1009883a 	mov	r4,r2
  811724:	080b2480 	call	80b248 <__mulsi3>
  811728:	8085883a 	add	r2,r16,r2
  81172c:	10c00017 	ldw	r3,0(r2)
  811730:	e0bffb17 	ldw	r2,-20(fp)
  811734:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  811738:	040020b4 	movhi	r16,130
  81173c:	842cd804 	addi	r16,r16,-19616
  811740:	e0bffa17 	ldw	r2,-24(fp)
  811744:	01400304 	movi	r5,12
  811748:	1009883a 	mov	r4,r2
  81174c:	080b2480 	call	80b248 <__mulsi3>
  811750:	8085883a 	add	r2,r16,r2
  811754:	10800104 	addi	r2,r2,4
  811758:	10c00017 	ldw	r3,0(r2)
  81175c:	e0bffb17 	ldw	r2,-20(fp)
  811760:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  811764:	040020b4 	movhi	r16,130
  811768:	842cd804 	addi	r16,r16,-19616
  81176c:	e0bffa17 	ldw	r2,-24(fp)
  811770:	01400304 	movi	r5,12
  811774:	1009883a 	mov	r4,r2
  811778:	080b2480 	call	80b248 <__mulsi3>
  81177c:	8085883a 	add	r2,r16,r2
  811780:	10800204 	addi	r2,r2,8
  811784:	10c00017 	ldw	r3,0(r2)
  811788:	e0bffb17 	ldw	r2,-20(fp)
  81178c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  811790:	e13ffa17 	ldw	r4,-24(fp)
  811794:	0811ab40 	call	811ab4 <alt_release_fd>
  }
} 
  811798:	0001883a 	nop
  81179c:	e6ffff04 	addi	sp,fp,-4
  8117a0:	dfc00217 	ldw	ra,8(sp)
  8117a4:	df000117 	ldw	fp,4(sp)
  8117a8:	dc000017 	ldw	r16,0(sp)
  8117ac:	dec00304 	addi	sp,sp,12
  8117b0:	f800283a 	ret

008117b4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  8117b4:	defffb04 	addi	sp,sp,-20
  8117b8:	dfc00415 	stw	ra,16(sp)
  8117bc:	df000315 	stw	fp,12(sp)
  8117c0:	df000304 	addi	fp,sp,12
  8117c4:	e13ffd15 	stw	r4,-12(fp)
  8117c8:	e17ffe15 	stw	r5,-8(fp)
  8117cc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  8117d0:	01c07fc4 	movi	r7,511
  8117d4:	01800044 	movi	r6,1
  8117d8:	e17ffd17 	ldw	r5,-12(fp)
  8117dc:	010020b4 	movhi	r4,130
  8117e0:	212cdb04 	addi	r4,r4,-19604
  8117e4:	08116d00 	call	8116d0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  8117e8:	01c07fc4 	movi	r7,511
  8117ec:	000d883a 	mov	r6,zero
  8117f0:	e17ffe17 	ldw	r5,-8(fp)
  8117f4:	010020b4 	movhi	r4,130
  8117f8:	212cd804 	addi	r4,r4,-19616
  8117fc:	08116d00 	call	8116d0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  811800:	01c07fc4 	movi	r7,511
  811804:	01800044 	movi	r6,1
  811808:	e17fff17 	ldw	r5,-4(fp)
  81180c:	010020b4 	movhi	r4,130
  811810:	212cde04 	addi	r4,r4,-19592
  811814:	08116d00 	call	8116d0 <alt_open_fd>
}  
  811818:	0001883a 	nop
  81181c:	e037883a 	mov	sp,fp
  811820:	dfc00117 	ldw	ra,4(sp)
  811824:	df000017 	ldw	fp,0(sp)
  811828:	dec00204 	addi	sp,sp,8
  81182c:	f800283a 	ret

00811830 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  811830:	defffe04 	addi	sp,sp,-8
  811834:	dfc00115 	stw	ra,4(sp)
  811838:	df000015 	stw	fp,0(sp)
  81183c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  811840:	d0a01d17 	ldw	r2,-32652(gp)
  811844:	10000326 	beq	r2,zero,811854 <alt_get_errno+0x24>
  811848:	d0a01d17 	ldw	r2,-32652(gp)
  81184c:	103ee83a 	callr	r2
  811850:	00000106 	br	811858 <alt_get_errno+0x28>
  811854:	d0a04304 	addi	r2,gp,-32500
}
  811858:	e037883a 	mov	sp,fp
  81185c:	dfc00117 	ldw	ra,4(sp)
  811860:	df000017 	ldw	fp,0(sp)
  811864:	dec00204 	addi	sp,sp,8
  811868:	f800283a 	ret

0081186c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  81186c:	defffb04 	addi	sp,sp,-20
  811870:	dfc00415 	stw	ra,16(sp)
  811874:	df000315 	stw	fp,12(sp)
  811878:	dc000215 	stw	r16,8(sp)
  81187c:	df000304 	addi	fp,sp,12
  811880:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  811884:	e0bffe17 	ldw	r2,-8(fp)
  811888:	10800217 	ldw	r2,8(r2)
  81188c:	10d00034 	orhi	r3,r2,16384
  811890:	e0bffe17 	ldw	r2,-8(fp)
  811894:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  811898:	e03ffd15 	stw	zero,-12(fp)
  81189c:	00002306 	br	81192c <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  8118a0:	040020b4 	movhi	r16,130
  8118a4:	842cd804 	addi	r16,r16,-19616
  8118a8:	e0bffd17 	ldw	r2,-12(fp)
  8118ac:	01400304 	movi	r5,12
  8118b0:	1009883a 	mov	r4,r2
  8118b4:	080b2480 	call	80b248 <__mulsi3>
  8118b8:	8085883a 	add	r2,r16,r2
  8118bc:	10c00017 	ldw	r3,0(r2)
  8118c0:	e0bffe17 	ldw	r2,-8(fp)
  8118c4:	10800017 	ldw	r2,0(r2)
  8118c8:	1880151e 	bne	r3,r2,811920 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  8118cc:	040020b4 	movhi	r16,130
  8118d0:	842cd804 	addi	r16,r16,-19616
  8118d4:	e0bffd17 	ldw	r2,-12(fp)
  8118d8:	01400304 	movi	r5,12
  8118dc:	1009883a 	mov	r4,r2
  8118e0:	080b2480 	call	80b248 <__mulsi3>
  8118e4:	8085883a 	add	r2,r16,r2
  8118e8:	10800204 	addi	r2,r2,8
  8118ec:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  8118f0:	10000b0e 	bge	r2,zero,811920 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  8118f4:	01400304 	movi	r5,12
  8118f8:	e13ffd17 	ldw	r4,-12(fp)
  8118fc:	080b2480 	call	80b248 <__mulsi3>
  811900:	1007883a 	mov	r3,r2
  811904:	008020b4 	movhi	r2,130
  811908:	10acd804 	addi	r2,r2,-19616
  81190c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  811910:	e0bffe17 	ldw	r2,-8(fp)
  811914:	18800226 	beq	r3,r2,811920 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  811918:	00bffcc4 	movi	r2,-13
  81191c:	00000806 	br	811940 <alt_file_locked+0xd4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  811920:	e0bffd17 	ldw	r2,-12(fp)
  811924:	10800044 	addi	r2,r2,1
  811928:	e0bffd15 	stw	r2,-12(fp)
  81192c:	d0a01817 	ldw	r2,-32672(gp)
  811930:	1007883a 	mov	r3,r2
  811934:	e0bffd17 	ldw	r2,-12(fp)
  811938:	18bfd92e 	bgeu	r3,r2,8118a0 <__alt_data_end+0xfff118a0>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  81193c:	0005883a 	mov	r2,zero
}
  811940:	e6ffff04 	addi	sp,fp,-4
  811944:	dfc00217 	ldw	ra,8(sp)
  811948:	df000117 	ldw	fp,4(sp)
  81194c:	dc000017 	ldw	r16,0(sp)
  811950:	dec00304 	addi	sp,sp,12
  811954:	f800283a 	ret

00811958 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  811958:	defff604 	addi	sp,sp,-40
  81195c:	dfc00915 	stw	ra,36(sp)
  811960:	df000815 	stw	fp,32(sp)
  811964:	df000804 	addi	fp,sp,32
  811968:	e13ffd15 	stw	r4,-12(fp)
  81196c:	e17ffe15 	stw	r5,-8(fp)
  811970:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  811974:	00bfffc4 	movi	r2,-1
  811978:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  81197c:	00bffb44 	movi	r2,-19
  811980:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  811984:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  811988:	d1601604 	addi	r5,gp,-32680
  81198c:	e13ffd17 	ldw	r4,-12(fp)
  811990:	08116400 	call	811640 <alt_find_dev>
  811994:	e0bff815 	stw	r2,-32(fp)
  811998:	e0bff817 	ldw	r2,-32(fp)
  81199c:	1000051e 	bne	r2,zero,8119b4 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  8119a0:	e13ffd17 	ldw	r4,-12(fp)
  8119a4:	0811d000 	call	811d00 <alt_find_file>
  8119a8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  8119ac:	00800044 	movi	r2,1
  8119b0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  8119b4:	e0bff817 	ldw	r2,-32(fp)
  8119b8:	10002b26 	beq	r2,zero,811a68 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
  8119bc:	e13ff817 	ldw	r4,-32(fp)
  8119c0:	0811e080 	call	811e08 <alt_get_fd>
  8119c4:	e0bff915 	stw	r2,-28(fp)
  8119c8:	e0bff917 	ldw	r2,-28(fp)
  8119cc:	1000030e 	bge	r2,zero,8119dc <open+0x84>
    {
      status = index;
  8119d0:	e0bff917 	ldw	r2,-28(fp)
  8119d4:	e0bffa15 	stw	r2,-24(fp)
  8119d8:	00002506 	br	811a70 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
  8119dc:	01400304 	movi	r5,12
  8119e0:	e13ff917 	ldw	r4,-28(fp)
  8119e4:	080b2480 	call	80b248 <__mulsi3>
  8119e8:	1007883a 	mov	r3,r2
  8119ec:	008020b4 	movhi	r2,130
  8119f0:	10acd804 	addi	r2,r2,-19616
  8119f4:	1885883a 	add	r2,r3,r2
  8119f8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  8119fc:	e0fffe17 	ldw	r3,-8(fp)
  811a00:	00900034 	movhi	r2,16384
  811a04:	10bfffc4 	addi	r2,r2,-1
  811a08:	1886703a 	and	r3,r3,r2
  811a0c:	e0bffc17 	ldw	r2,-16(fp)
  811a10:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  811a14:	e0bffb17 	ldw	r2,-20(fp)
  811a18:	1000051e 	bne	r2,zero,811a30 <open+0xd8>
  811a1c:	e13ffc17 	ldw	r4,-16(fp)
  811a20:	081186c0 	call	81186c <alt_file_locked>
  811a24:	e0bffa15 	stw	r2,-24(fp)
  811a28:	e0bffa17 	ldw	r2,-24(fp)
  811a2c:	10001016 	blt	r2,zero,811a70 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  811a30:	e0bff817 	ldw	r2,-32(fp)
  811a34:	10800317 	ldw	r2,12(r2)
  811a38:	10000826 	beq	r2,zero,811a5c <open+0x104>
  811a3c:	e0bff817 	ldw	r2,-32(fp)
  811a40:	10800317 	ldw	r2,12(r2)
  811a44:	e1ffff17 	ldw	r7,-4(fp)
  811a48:	e1bffe17 	ldw	r6,-8(fp)
  811a4c:	e17ffd17 	ldw	r5,-12(fp)
  811a50:	e13ffc17 	ldw	r4,-16(fp)
  811a54:	103ee83a 	callr	r2
  811a58:	00000106 	br	811a60 <open+0x108>
  811a5c:	0005883a 	mov	r2,zero
  811a60:	e0bffa15 	stw	r2,-24(fp)
  811a64:	00000206 	br	811a70 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
  811a68:	00bffb44 	movi	r2,-19
  811a6c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  811a70:	e0bffa17 	ldw	r2,-24(fp)
  811a74:	1000090e 	bge	r2,zero,811a9c <open+0x144>
  {
    alt_release_fd (index);  
  811a78:	e13ff917 	ldw	r4,-28(fp)
  811a7c:	0811ab40 	call	811ab4 <alt_release_fd>
    ALT_ERRNO = -status;
  811a80:	08118300 	call	811830 <alt_get_errno>
  811a84:	1007883a 	mov	r3,r2
  811a88:	e0bffa17 	ldw	r2,-24(fp)
  811a8c:	0085c83a 	sub	r2,zero,r2
  811a90:	18800015 	stw	r2,0(r3)
    return -1;
  811a94:	00bfffc4 	movi	r2,-1
  811a98:	00000106 	br	811aa0 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
  811a9c:	e0bff917 	ldw	r2,-28(fp)
}
  811aa0:	e037883a 	mov	sp,fp
  811aa4:	dfc00117 	ldw	ra,4(sp)
  811aa8:	df000017 	ldw	fp,0(sp)
  811aac:	dec00204 	addi	sp,sp,8
  811ab0:	f800283a 	ret

00811ab4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  811ab4:	defffc04 	addi	sp,sp,-16
  811ab8:	dfc00315 	stw	ra,12(sp)
  811abc:	df000215 	stw	fp,8(sp)
  811ac0:	dc000115 	stw	r16,4(sp)
  811ac4:	df000204 	addi	fp,sp,8
  811ac8:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
  811acc:	e0bffe17 	ldw	r2,-8(fp)
  811ad0:	108000d0 	cmplti	r2,r2,3
  811ad4:	1000111e 	bne	r2,zero,811b1c <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  811ad8:	040020b4 	movhi	r16,130
  811adc:	842cd804 	addi	r16,r16,-19616
  811ae0:	e0bffe17 	ldw	r2,-8(fp)
  811ae4:	01400304 	movi	r5,12
  811ae8:	1009883a 	mov	r4,r2
  811aec:	080b2480 	call	80b248 <__mulsi3>
  811af0:	8085883a 	add	r2,r16,r2
  811af4:	10800204 	addi	r2,r2,8
  811af8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  811afc:	040020b4 	movhi	r16,130
  811b00:	842cd804 	addi	r16,r16,-19616
  811b04:	e0bffe17 	ldw	r2,-8(fp)
  811b08:	01400304 	movi	r5,12
  811b0c:	1009883a 	mov	r4,r2
  811b10:	080b2480 	call	80b248 <__mulsi3>
  811b14:	8085883a 	add	r2,r16,r2
  811b18:	10000015 	stw	zero,0(r2)
  }
}
  811b1c:	0001883a 	nop
  811b20:	e6ffff04 	addi	sp,fp,-4
  811b24:	dfc00217 	ldw	ra,8(sp)
  811b28:	df000117 	ldw	fp,4(sp)
  811b2c:	dc000017 	ldw	r16,0(sp)
  811b30:	dec00304 	addi	sp,sp,12
  811b34:	f800283a 	ret

00811b38 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  811b38:	defffa04 	addi	sp,sp,-24
  811b3c:	df000515 	stw	fp,20(sp)
  811b40:	df000504 	addi	fp,sp,20
  811b44:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811b48:	0005303a 	rdctl	r2,status
  811b4c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811b50:	e0fffc17 	ldw	r3,-16(fp)
  811b54:	00bfff84 	movi	r2,-2
  811b58:	1884703a 	and	r2,r3,r2
  811b5c:	1001703a 	wrctl	status,r2
  
  return context;
  811b60:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  811b64:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  811b68:	e0bfff17 	ldw	r2,-4(fp)
  811b6c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  811b70:	e0bffd17 	ldw	r2,-12(fp)
  811b74:	10800017 	ldw	r2,0(r2)
  811b78:	e0fffd17 	ldw	r3,-12(fp)
  811b7c:	18c00117 	ldw	r3,4(r3)
  811b80:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  811b84:	e0bffd17 	ldw	r2,-12(fp)
  811b88:	10800117 	ldw	r2,4(r2)
  811b8c:	e0fffd17 	ldw	r3,-12(fp)
  811b90:	18c00017 	ldw	r3,0(r3)
  811b94:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  811b98:	e0bffd17 	ldw	r2,-12(fp)
  811b9c:	e0fffd17 	ldw	r3,-12(fp)
  811ba0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  811ba4:	e0bffd17 	ldw	r2,-12(fp)
  811ba8:	e0fffd17 	ldw	r3,-12(fp)
  811bac:	10c00015 	stw	r3,0(r2)
  811bb0:	e0bffb17 	ldw	r2,-20(fp)
  811bb4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811bb8:	e0bffe17 	ldw	r2,-8(fp)
  811bbc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  811bc0:	0001883a 	nop
  811bc4:	e037883a 	mov	sp,fp
  811bc8:	df000017 	ldw	fp,0(sp)
  811bcc:	dec00104 	addi	sp,sp,4
  811bd0:	f800283a 	ret

00811bd4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  811bd4:	defffb04 	addi	sp,sp,-20
  811bd8:	dfc00415 	stw	ra,16(sp)
  811bdc:	df000315 	stw	fp,12(sp)
  811be0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  811be4:	d0a01e17 	ldw	r2,-32648(gp)
  811be8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  811bec:	d0a04217 	ldw	r2,-32504(gp)
  811bf0:	10800044 	addi	r2,r2,1
  811bf4:	d0a04215 	stw	r2,-32504(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  811bf8:	00002e06 	br	811cb4 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  811bfc:	e0bffd17 	ldw	r2,-12(fp)
  811c00:	10800017 	ldw	r2,0(r2)
  811c04:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  811c08:	e0bffd17 	ldw	r2,-12(fp)
  811c0c:	10800403 	ldbu	r2,16(r2)
  811c10:	10803fcc 	andi	r2,r2,255
  811c14:	10000426 	beq	r2,zero,811c28 <alt_tick+0x54>
  811c18:	d0a04217 	ldw	r2,-32504(gp)
  811c1c:	1000021e 	bne	r2,zero,811c28 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  811c20:	e0bffd17 	ldw	r2,-12(fp)
  811c24:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  811c28:	e0bffd17 	ldw	r2,-12(fp)
  811c2c:	10800217 	ldw	r2,8(r2)
  811c30:	d0e04217 	ldw	r3,-32504(gp)
  811c34:	18801d36 	bltu	r3,r2,811cac <alt_tick+0xd8>
  811c38:	e0bffd17 	ldw	r2,-12(fp)
  811c3c:	10800403 	ldbu	r2,16(r2)
  811c40:	10803fcc 	andi	r2,r2,255
  811c44:	1000191e 	bne	r2,zero,811cac <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  811c48:	e0bffd17 	ldw	r2,-12(fp)
  811c4c:	10800317 	ldw	r2,12(r2)
  811c50:	e0fffd17 	ldw	r3,-12(fp)
  811c54:	18c00517 	ldw	r3,20(r3)
  811c58:	1809883a 	mov	r4,r3
  811c5c:	103ee83a 	callr	r2
  811c60:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  811c64:	e0bfff17 	ldw	r2,-4(fp)
  811c68:	1000031e 	bne	r2,zero,811c78 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  811c6c:	e13ffd17 	ldw	r4,-12(fp)
  811c70:	0811b380 	call	811b38 <alt_alarm_stop>
  811c74:	00000d06 	br	811cac <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  811c78:	e0bffd17 	ldw	r2,-12(fp)
  811c7c:	10c00217 	ldw	r3,8(r2)
  811c80:	e0bfff17 	ldw	r2,-4(fp)
  811c84:	1887883a 	add	r3,r3,r2
  811c88:	e0bffd17 	ldw	r2,-12(fp)
  811c8c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  811c90:	e0bffd17 	ldw	r2,-12(fp)
  811c94:	10c00217 	ldw	r3,8(r2)
  811c98:	d0a04217 	ldw	r2,-32504(gp)
  811c9c:	1880032e 	bgeu	r3,r2,811cac <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  811ca0:	e0bffd17 	ldw	r2,-12(fp)
  811ca4:	00c00044 	movi	r3,1
  811ca8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  811cac:	e0bffe17 	ldw	r2,-8(fp)
  811cb0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  811cb4:	e0fffd17 	ldw	r3,-12(fp)
  811cb8:	d0a01e04 	addi	r2,gp,-32648
  811cbc:	18bfcf1e 	bne	r3,r2,811bfc <__alt_data_end+0xfff11bfc>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  811cc0:	0001883a 	nop
}
  811cc4:	0001883a 	nop
  811cc8:	e037883a 	mov	sp,fp
  811ccc:	dfc00117 	ldw	ra,4(sp)
  811cd0:	df000017 	ldw	fp,0(sp)
  811cd4:	dec00204 	addi	sp,sp,8
  811cd8:	f800283a 	ret

00811cdc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  811cdc:	deffff04 	addi	sp,sp,-4
  811ce0:	df000015 	stw	fp,0(sp)
  811ce4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  811ce8:	000170fa 	wrctl	ienable,zero
}
  811cec:	0001883a 	nop
  811cf0:	e037883a 	mov	sp,fp
  811cf4:	df000017 	ldw	fp,0(sp)
  811cf8:	dec00104 	addi	sp,sp,4
  811cfc:	f800283a 	ret

00811d00 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  811d00:	defffb04 	addi	sp,sp,-20
  811d04:	dfc00415 	stw	ra,16(sp)
  811d08:	df000315 	stw	fp,12(sp)
  811d0c:	df000304 	addi	fp,sp,12
  811d10:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  811d14:	d0a01417 	ldw	r2,-32688(gp)
  811d18:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  811d1c:	00003106 	br	811de4 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
  811d20:	e0bffd17 	ldw	r2,-12(fp)
  811d24:	10800217 	ldw	r2,8(r2)
  811d28:	1009883a 	mov	r4,r2
  811d2c:	0811f940 	call	811f94 <strlen>
  811d30:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  811d34:	e0bffd17 	ldw	r2,-12(fp)
  811d38:	10c00217 	ldw	r3,8(r2)
  811d3c:	e0bffe17 	ldw	r2,-8(fp)
  811d40:	10bfffc4 	addi	r2,r2,-1
  811d44:	1885883a 	add	r2,r3,r2
  811d48:	10800003 	ldbu	r2,0(r2)
  811d4c:	10803fcc 	andi	r2,r2,255
  811d50:	1080201c 	xori	r2,r2,128
  811d54:	10bfe004 	addi	r2,r2,-128
  811d58:	10800bd8 	cmpnei	r2,r2,47
  811d5c:	1000031e 	bne	r2,zero,811d6c <alt_find_file+0x6c>
    {
      len -= 1;
  811d60:	e0bffe17 	ldw	r2,-8(fp)
  811d64:	10bfffc4 	addi	r2,r2,-1
  811d68:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  811d6c:	e0bffe17 	ldw	r2,-8(fp)
  811d70:	e0ffff17 	ldw	r3,-4(fp)
  811d74:	1885883a 	add	r2,r3,r2
  811d78:	10800003 	ldbu	r2,0(r2)
  811d7c:	10803fcc 	andi	r2,r2,255
  811d80:	1080201c 	xori	r2,r2,128
  811d84:	10bfe004 	addi	r2,r2,-128
  811d88:	10800be0 	cmpeqi	r2,r2,47
  811d8c:	1000081e 	bne	r2,zero,811db0 <alt_find_file+0xb0>
  811d90:	e0bffe17 	ldw	r2,-8(fp)
  811d94:	e0ffff17 	ldw	r3,-4(fp)
  811d98:	1885883a 	add	r2,r3,r2
  811d9c:	10800003 	ldbu	r2,0(r2)
  811da0:	10803fcc 	andi	r2,r2,255
  811da4:	1080201c 	xori	r2,r2,128
  811da8:	10bfe004 	addi	r2,r2,-128
  811dac:	10000a1e 	bne	r2,zero,811dd8 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
  811db0:	e0bffd17 	ldw	r2,-12(fp)
  811db4:	10800217 	ldw	r2,8(r2)
  811db8:	e0fffe17 	ldw	r3,-8(fp)
  811dbc:	180d883a 	mov	r6,r3
  811dc0:	e17fff17 	ldw	r5,-4(fp)
  811dc4:	1009883a 	mov	r4,r2
  811dc8:	0811f180 	call	811f18 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  811dcc:	1000021e 	bne	r2,zero,811dd8 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  811dd0:	e0bffd17 	ldw	r2,-12(fp)
  811dd4:	00000706 	br	811df4 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
  811dd8:	e0bffd17 	ldw	r2,-12(fp)
  811ddc:	10800017 	ldw	r2,0(r2)
  811de0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  811de4:	e0fffd17 	ldw	r3,-12(fp)
  811de8:	d0a01404 	addi	r2,gp,-32688
  811dec:	18bfcc1e 	bne	r3,r2,811d20 <__alt_data_end+0xfff11d20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  811df0:	0005883a 	mov	r2,zero
}
  811df4:	e037883a 	mov	sp,fp
  811df8:	dfc00117 	ldw	ra,4(sp)
  811dfc:	df000017 	ldw	fp,0(sp)
  811e00:	dec00204 	addi	sp,sp,8
  811e04:	f800283a 	ret

00811e08 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  811e08:	defffa04 	addi	sp,sp,-24
  811e0c:	dfc00515 	stw	ra,20(sp)
  811e10:	df000415 	stw	fp,16(sp)
  811e14:	dc000315 	stw	r16,12(sp)
  811e18:	df000404 	addi	fp,sp,16
  811e1c:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
  811e20:	00bffa04 	movi	r2,-24
  811e24:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  811e28:	e03ffc15 	stw	zero,-16(fp)
  811e2c:	00001d06 	br	811ea4 <alt_get_fd+0x9c>
  {
    if (!alt_fd_list[i].dev)
  811e30:	040020b4 	movhi	r16,130
  811e34:	842cd804 	addi	r16,r16,-19616
  811e38:	e0bffc17 	ldw	r2,-16(fp)
  811e3c:	01400304 	movi	r5,12
  811e40:	1009883a 	mov	r4,r2
  811e44:	080b2480 	call	80b248 <__mulsi3>
  811e48:	8085883a 	add	r2,r16,r2
  811e4c:	10800017 	ldw	r2,0(r2)
  811e50:	1000111e 	bne	r2,zero,811e98 <alt_get_fd+0x90>
    {
      alt_fd_list[i].dev = dev;
  811e54:	040020b4 	movhi	r16,130
  811e58:	842cd804 	addi	r16,r16,-19616
  811e5c:	e0bffc17 	ldw	r2,-16(fp)
  811e60:	01400304 	movi	r5,12
  811e64:	1009883a 	mov	r4,r2
  811e68:	080b2480 	call	80b248 <__mulsi3>
  811e6c:	8085883a 	add	r2,r16,r2
  811e70:	e0fffe17 	ldw	r3,-8(fp)
  811e74:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  811e78:	d0e01817 	ldw	r3,-32672(gp)
  811e7c:	e0bffc17 	ldw	r2,-16(fp)
  811e80:	1880020e 	bge	r3,r2,811e8c <alt_get_fd+0x84>
      {
        alt_max_fd = i;
  811e84:	e0bffc17 	ldw	r2,-16(fp)
  811e88:	d0a01815 	stw	r2,-32672(gp)
      }
      rc = i;
  811e8c:	e0bffc17 	ldw	r2,-16(fp)
  811e90:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  811e94:	00000606 	br	811eb0 <alt_get_fd+0xa8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  811e98:	e0bffc17 	ldw	r2,-16(fp)
  811e9c:	10800044 	addi	r2,r2,1
  811ea0:	e0bffc15 	stw	r2,-16(fp)
  811ea4:	e0bffc17 	ldw	r2,-16(fp)
  811ea8:	10800810 	cmplti	r2,r2,32
  811eac:	103fe01e 	bne	r2,zero,811e30 <__alt_data_end+0xfff11e30>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  811eb0:	e0bffd17 	ldw	r2,-12(fp)
}
  811eb4:	e6ffff04 	addi	sp,fp,-4
  811eb8:	dfc00217 	ldw	ra,8(sp)
  811ebc:	df000117 	ldw	fp,4(sp)
  811ec0:	dc000017 	ldw	r16,0(sp)
  811ec4:	dec00304 	addi	sp,sp,12
  811ec8:	f800283a 	ret

00811ecc <atexit>:
  811ecc:	200b883a 	mov	r5,r4
  811ed0:	000f883a 	mov	r7,zero
  811ed4:	000d883a 	mov	r6,zero
  811ed8:	0009883a 	mov	r4,zero
  811edc:	081202c1 	jmpi	81202c <__register_exitproc>

00811ee0 <exit>:
  811ee0:	defffe04 	addi	sp,sp,-8
  811ee4:	000b883a 	mov	r5,zero
  811ee8:	dc000015 	stw	r16,0(sp)
  811eec:	dfc00115 	stw	ra,4(sp)
  811ef0:	2021883a 	mov	r16,r4
  811ef4:	08121440 	call	812144 <__call_exitprocs>
  811ef8:	008020b4 	movhi	r2,130
  811efc:	10ad4904 	addi	r2,r2,-19164
  811f00:	11000017 	ldw	r4,0(r2)
  811f04:	20800f17 	ldw	r2,60(r4)
  811f08:	10000126 	beq	r2,zero,811f10 <exit+0x30>
  811f0c:	103ee83a 	callr	r2
  811f10:	8009883a 	mov	r4,r16
  811f14:	08122c40 	call	8122c4 <_exit>

00811f18 <memcmp>:
  811f18:	01c000c4 	movi	r7,3
  811f1c:	3980192e 	bgeu	r7,r6,811f84 <memcmp+0x6c>
  811f20:	2144b03a 	or	r2,r4,r5
  811f24:	11c4703a 	and	r2,r2,r7
  811f28:	10000f26 	beq	r2,zero,811f68 <memcmp+0x50>
  811f2c:	20800003 	ldbu	r2,0(r4)
  811f30:	28c00003 	ldbu	r3,0(r5)
  811f34:	10c0151e 	bne	r2,r3,811f8c <memcmp+0x74>
  811f38:	31bfff84 	addi	r6,r6,-2
  811f3c:	01ffffc4 	movi	r7,-1
  811f40:	00000406 	br	811f54 <memcmp+0x3c>
  811f44:	20800003 	ldbu	r2,0(r4)
  811f48:	28c00003 	ldbu	r3,0(r5)
  811f4c:	31bfffc4 	addi	r6,r6,-1
  811f50:	10c00e1e 	bne	r2,r3,811f8c <memcmp+0x74>
  811f54:	21000044 	addi	r4,r4,1
  811f58:	29400044 	addi	r5,r5,1
  811f5c:	31fff91e 	bne	r6,r7,811f44 <__alt_data_end+0xfff11f44>
  811f60:	0005883a 	mov	r2,zero
  811f64:	f800283a 	ret
  811f68:	20c00017 	ldw	r3,0(r4)
  811f6c:	28800017 	ldw	r2,0(r5)
  811f70:	18bfee1e 	bne	r3,r2,811f2c <__alt_data_end+0xfff11f2c>
  811f74:	31bfff04 	addi	r6,r6,-4
  811f78:	21000104 	addi	r4,r4,4
  811f7c:	29400104 	addi	r5,r5,4
  811f80:	39bff936 	bltu	r7,r6,811f68 <__alt_data_end+0xfff11f68>
  811f84:	303fe91e 	bne	r6,zero,811f2c <__alt_data_end+0xfff11f2c>
  811f88:	003ff506 	br	811f60 <__alt_data_end+0xfff11f60>
  811f8c:	10c5c83a 	sub	r2,r2,r3
  811f90:	f800283a 	ret

00811f94 <strlen>:
  811f94:	208000cc 	andi	r2,r4,3
  811f98:	10002026 	beq	r2,zero,81201c <strlen+0x88>
  811f9c:	20800007 	ldb	r2,0(r4)
  811fa0:	10002026 	beq	r2,zero,812024 <strlen+0x90>
  811fa4:	2005883a 	mov	r2,r4
  811fa8:	00000206 	br	811fb4 <strlen+0x20>
  811fac:	10c00007 	ldb	r3,0(r2)
  811fb0:	18001826 	beq	r3,zero,812014 <strlen+0x80>
  811fb4:	10800044 	addi	r2,r2,1
  811fb8:	10c000cc 	andi	r3,r2,3
  811fbc:	183ffb1e 	bne	r3,zero,811fac <__alt_data_end+0xfff11fac>
  811fc0:	10c00017 	ldw	r3,0(r2)
  811fc4:	01ffbff4 	movhi	r7,65279
  811fc8:	39ffbfc4 	addi	r7,r7,-257
  811fcc:	00ca303a 	nor	r5,zero,r3
  811fd0:	01a02074 	movhi	r6,32897
  811fd4:	19c7883a 	add	r3,r3,r7
  811fd8:	31a02004 	addi	r6,r6,-32640
  811fdc:	1946703a 	and	r3,r3,r5
  811fe0:	1986703a 	and	r3,r3,r6
  811fe4:	1800091e 	bne	r3,zero,81200c <strlen+0x78>
  811fe8:	10800104 	addi	r2,r2,4
  811fec:	10c00017 	ldw	r3,0(r2)
  811ff0:	19cb883a 	add	r5,r3,r7
  811ff4:	00c6303a 	nor	r3,zero,r3
  811ff8:	28c6703a 	and	r3,r5,r3
  811ffc:	1986703a 	and	r3,r3,r6
  812000:	183ff926 	beq	r3,zero,811fe8 <__alt_data_end+0xfff11fe8>
  812004:	00000106 	br	81200c <strlen+0x78>
  812008:	10800044 	addi	r2,r2,1
  81200c:	10c00007 	ldb	r3,0(r2)
  812010:	183ffd1e 	bne	r3,zero,812008 <__alt_data_end+0xfff12008>
  812014:	1105c83a 	sub	r2,r2,r4
  812018:	f800283a 	ret
  81201c:	2005883a 	mov	r2,r4
  812020:	003fe706 	br	811fc0 <__alt_data_end+0xfff11fc0>
  812024:	0005883a 	mov	r2,zero
  812028:	f800283a 	ret

0081202c <__register_exitproc>:
  81202c:	defffa04 	addi	sp,sp,-24
  812030:	dc000315 	stw	r16,12(sp)
  812034:	040020b4 	movhi	r16,130
  812038:	842d4904 	addi	r16,r16,-19164
  81203c:	80c00017 	ldw	r3,0(r16)
  812040:	dc400415 	stw	r17,16(sp)
  812044:	dfc00515 	stw	ra,20(sp)
  812048:	18805217 	ldw	r2,328(r3)
  81204c:	2023883a 	mov	r17,r4
  812050:	10003726 	beq	r2,zero,812130 <__register_exitproc+0x104>
  812054:	10c00117 	ldw	r3,4(r2)
  812058:	010007c4 	movi	r4,31
  81205c:	20c00e16 	blt	r4,r3,812098 <__register_exitproc+0x6c>
  812060:	1a000044 	addi	r8,r3,1
  812064:	8800221e 	bne	r17,zero,8120f0 <__register_exitproc+0xc4>
  812068:	18c00084 	addi	r3,r3,2
  81206c:	18c7883a 	add	r3,r3,r3
  812070:	18c7883a 	add	r3,r3,r3
  812074:	12000115 	stw	r8,4(r2)
  812078:	10c7883a 	add	r3,r2,r3
  81207c:	19400015 	stw	r5,0(r3)
  812080:	0005883a 	mov	r2,zero
  812084:	dfc00517 	ldw	ra,20(sp)
  812088:	dc400417 	ldw	r17,16(sp)
  81208c:	dc000317 	ldw	r16,12(sp)
  812090:	dec00604 	addi	sp,sp,24
  812094:	f800283a 	ret
  812098:	00800034 	movhi	r2,0
  81209c:	10800004 	addi	r2,r2,0
  8120a0:	10002626 	beq	r2,zero,81213c <__register_exitproc+0x110>
  8120a4:	01006404 	movi	r4,400
  8120a8:	d9400015 	stw	r5,0(sp)
  8120ac:	d9800115 	stw	r6,4(sp)
  8120b0:	d9c00215 	stw	r7,8(sp)
  8120b4:	00000000 	call	0 <__alt_mem_serialflash-0x2000>
  8120b8:	d9400017 	ldw	r5,0(sp)
  8120bc:	d9800117 	ldw	r6,4(sp)
  8120c0:	d9c00217 	ldw	r7,8(sp)
  8120c4:	10001d26 	beq	r2,zero,81213c <__register_exitproc+0x110>
  8120c8:	81000017 	ldw	r4,0(r16)
  8120cc:	10000115 	stw	zero,4(r2)
  8120d0:	02000044 	movi	r8,1
  8120d4:	22405217 	ldw	r9,328(r4)
  8120d8:	0007883a 	mov	r3,zero
  8120dc:	12400015 	stw	r9,0(r2)
  8120e0:	20805215 	stw	r2,328(r4)
  8120e4:	10006215 	stw	zero,392(r2)
  8120e8:	10006315 	stw	zero,396(r2)
  8120ec:	883fde26 	beq	r17,zero,812068 <__alt_data_end+0xfff12068>
  8120f0:	18c9883a 	add	r4,r3,r3
  8120f4:	2109883a 	add	r4,r4,r4
  8120f8:	1109883a 	add	r4,r2,r4
  8120fc:	21802215 	stw	r6,136(r4)
  812100:	01800044 	movi	r6,1
  812104:	12406217 	ldw	r9,392(r2)
  812108:	30cc983a 	sll	r6,r6,r3
  81210c:	4992b03a 	or	r9,r9,r6
  812110:	12406215 	stw	r9,392(r2)
  812114:	21c04215 	stw	r7,264(r4)
  812118:	01000084 	movi	r4,2
  81211c:	893fd21e 	bne	r17,r4,812068 <__alt_data_end+0xfff12068>
  812120:	11006317 	ldw	r4,396(r2)
  812124:	218cb03a 	or	r6,r4,r6
  812128:	11806315 	stw	r6,396(r2)
  81212c:	003fce06 	br	812068 <__alt_data_end+0xfff12068>
  812130:	18805304 	addi	r2,r3,332
  812134:	18805215 	stw	r2,328(r3)
  812138:	003fc606 	br	812054 <__alt_data_end+0xfff12054>
  81213c:	00bfffc4 	movi	r2,-1
  812140:	003fd006 	br	812084 <__alt_data_end+0xfff12084>

00812144 <__call_exitprocs>:
  812144:	defff504 	addi	sp,sp,-44
  812148:	df000915 	stw	fp,36(sp)
  81214c:	dd400615 	stw	r21,24(sp)
  812150:	dc800315 	stw	r18,12(sp)
  812154:	dfc00a15 	stw	ra,40(sp)
  812158:	ddc00815 	stw	r23,32(sp)
  81215c:	dd800715 	stw	r22,28(sp)
  812160:	dd000515 	stw	r20,20(sp)
  812164:	dcc00415 	stw	r19,16(sp)
  812168:	dc400215 	stw	r17,8(sp)
  81216c:	dc000115 	stw	r16,4(sp)
  812170:	d9000015 	stw	r4,0(sp)
  812174:	2839883a 	mov	fp,r5
  812178:	04800044 	movi	r18,1
  81217c:	057fffc4 	movi	r21,-1
  812180:	008020b4 	movhi	r2,130
  812184:	10ad4904 	addi	r2,r2,-19164
  812188:	12000017 	ldw	r8,0(r2)
  81218c:	45005217 	ldw	r20,328(r8)
  812190:	44c05204 	addi	r19,r8,328
  812194:	a0001c26 	beq	r20,zero,812208 <__call_exitprocs+0xc4>
  812198:	a0800117 	ldw	r2,4(r20)
  81219c:	15ffffc4 	addi	r23,r2,-1
  8121a0:	b8000d16 	blt	r23,zero,8121d8 <__call_exitprocs+0x94>
  8121a4:	14000044 	addi	r16,r2,1
  8121a8:	8421883a 	add	r16,r16,r16
  8121ac:	8421883a 	add	r16,r16,r16
  8121b0:	84402004 	addi	r17,r16,128
  8121b4:	a463883a 	add	r17,r20,r17
  8121b8:	a421883a 	add	r16,r20,r16
  8121bc:	e0001e26 	beq	fp,zero,812238 <__call_exitprocs+0xf4>
  8121c0:	80804017 	ldw	r2,256(r16)
  8121c4:	e0801c26 	beq	fp,r2,812238 <__call_exitprocs+0xf4>
  8121c8:	bdffffc4 	addi	r23,r23,-1
  8121cc:	843fff04 	addi	r16,r16,-4
  8121d0:	8c7fff04 	addi	r17,r17,-4
  8121d4:	bd7ff91e 	bne	r23,r21,8121bc <__alt_data_end+0xfff121bc>
  8121d8:	00800034 	movhi	r2,0
  8121dc:	10800004 	addi	r2,r2,0
  8121e0:	10000926 	beq	r2,zero,812208 <__call_exitprocs+0xc4>
  8121e4:	a0800117 	ldw	r2,4(r20)
  8121e8:	1000301e 	bne	r2,zero,8122ac <__call_exitprocs+0x168>
  8121ec:	a0800017 	ldw	r2,0(r20)
  8121f0:	10003226 	beq	r2,zero,8122bc <__call_exitprocs+0x178>
  8121f4:	a009883a 	mov	r4,r20
  8121f8:	98800015 	stw	r2,0(r19)
  8121fc:	00000000 	call	0 <__alt_mem_serialflash-0x2000>
  812200:	9d000017 	ldw	r20,0(r19)
  812204:	a03fe41e 	bne	r20,zero,812198 <__alt_data_end+0xfff12198>
  812208:	dfc00a17 	ldw	ra,40(sp)
  81220c:	df000917 	ldw	fp,36(sp)
  812210:	ddc00817 	ldw	r23,32(sp)
  812214:	dd800717 	ldw	r22,28(sp)
  812218:	dd400617 	ldw	r21,24(sp)
  81221c:	dd000517 	ldw	r20,20(sp)
  812220:	dcc00417 	ldw	r19,16(sp)
  812224:	dc800317 	ldw	r18,12(sp)
  812228:	dc400217 	ldw	r17,8(sp)
  81222c:	dc000117 	ldw	r16,4(sp)
  812230:	dec00b04 	addi	sp,sp,44
  812234:	f800283a 	ret
  812238:	a0800117 	ldw	r2,4(r20)
  81223c:	80c00017 	ldw	r3,0(r16)
  812240:	10bfffc4 	addi	r2,r2,-1
  812244:	15c01426 	beq	r2,r23,812298 <__call_exitprocs+0x154>
  812248:	80000015 	stw	zero,0(r16)
  81224c:	183fde26 	beq	r3,zero,8121c8 <__alt_data_end+0xfff121c8>
  812250:	95c8983a 	sll	r4,r18,r23
  812254:	a0806217 	ldw	r2,392(r20)
  812258:	a5800117 	ldw	r22,4(r20)
  81225c:	2084703a 	and	r2,r4,r2
  812260:	10000b26 	beq	r2,zero,812290 <__call_exitprocs+0x14c>
  812264:	a0806317 	ldw	r2,396(r20)
  812268:	2088703a 	and	r4,r4,r2
  81226c:	20000c1e 	bne	r4,zero,8122a0 <__call_exitprocs+0x15c>
  812270:	89400017 	ldw	r5,0(r17)
  812274:	d9000017 	ldw	r4,0(sp)
  812278:	183ee83a 	callr	r3
  81227c:	a0800117 	ldw	r2,4(r20)
  812280:	15bfbf1e 	bne	r2,r22,812180 <__alt_data_end+0xfff12180>
  812284:	98800017 	ldw	r2,0(r19)
  812288:	153fcf26 	beq	r2,r20,8121c8 <__alt_data_end+0xfff121c8>
  81228c:	003fbc06 	br	812180 <__alt_data_end+0xfff12180>
  812290:	183ee83a 	callr	r3
  812294:	003ff906 	br	81227c <__alt_data_end+0xfff1227c>
  812298:	a5c00115 	stw	r23,4(r20)
  81229c:	003feb06 	br	81224c <__alt_data_end+0xfff1224c>
  8122a0:	89000017 	ldw	r4,0(r17)
  8122a4:	183ee83a 	callr	r3
  8122a8:	003ff406 	br	81227c <__alt_data_end+0xfff1227c>
  8122ac:	a0800017 	ldw	r2,0(r20)
  8122b0:	a027883a 	mov	r19,r20
  8122b4:	1029883a 	mov	r20,r2
  8122b8:	003fb606 	br	812194 <__alt_data_end+0xfff12194>
  8122bc:	0005883a 	mov	r2,zero
  8122c0:	003ffb06 	br	8122b0 <__alt_data_end+0xfff122b0>

008122c4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  8122c4:	defffd04 	addi	sp,sp,-12
  8122c8:	df000215 	stw	fp,8(sp)
  8122cc:	df000204 	addi	fp,sp,8
  8122d0:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  8122d4:	0001883a 	nop
  8122d8:	e0bfff17 	ldw	r2,-4(fp)
  8122dc:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  8122e0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  8122e4:	10000226 	beq	r2,zero,8122f0 <_exit+0x2c>
    ALT_SIM_FAIL();
  8122e8:	002af070 	cmpltui	zero,zero,43969
  8122ec:	00000106 	br	8122f4 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  8122f0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  8122f4:	003fff06 	br	8122f4 <__alt_data_end+0xfff122f4>
